<html>
<head>
  <title>indexOf实现引申出来的各种字符串匹配算法</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1361"/>
<h1>indexOf实现引申出来的各种字符串匹配算法</h1>

<div>
<span><div><h2 style="margin-top: 10px; font-size: 1em; color: rgb(0, 0, 0); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(238, 238, 221);"><a href="http://www.cnblogs.com/rubylouvre/p/6658625.html" style="font-size: 1em; color: rgb(119, 0, 0); font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(238, 238, 221);">indexOf实现引申出来的各种字符串匹配算法</a></h2><div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">我们在表单验证时，经常遇到字符串的包含问题，比如说邮件必须包含indexOf。我们现在说一下indexOf。这是es3.1引进的API ，与lastIndexOf是一套的。可以用于字符串与数组中。一些面试经常用问数组的indexOf是如何实现的，但鲜有问如何实现字符串的indexOf是如何实现，因为这是很难很难。要知道，我们平时业务都是与字符串与数组打交道，像数字与日期则更加专业（涉及到二进制，历法）是通过库来处理。</span></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">我们回来想一下为什么字符串的indexOf为何如此难？这涉及到前缀与后缀的问题，或更专业的说，你应该想到前缀树或后缀树。如果你连这些概念都没有，你是写不好indexOf。字符串的问题，可以简单理解为遍历，分为全部遍历或跳着查找。</span></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">我们看最简单的Brute-Force算法（又被戏称为boyfirend算法）。有两个字符串，长的称之为目标串，短的一般叫模式串。</span></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">其算法思想是从目标串的第一个字符串与模式串的第一字符串比较，如果相等，移动目标串的索引，将模式串的索引归零，让目标串的子串与模式串继续逐字比较。</span></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><img src="https://images2015.cnblogs.com/blog/65123/201704/65123-20170410103444094-679215048.png" style="border: 0px; max-width: 900px;"></img></div><h2 style="margin: 15px 0px !important; font-size: 18px; font-weight: bold; line-height: 25px; background-color: rgb(0, 154, 97); text-shadow: gray 0px 1px 0px; padding: 10px; border-radius: 5px; color: white; box-shadow: gray 0px 0px 5px; font-family: 微软雅黑, 宋体, 黑体, Arial; height: 25px;"><span style="font-size: 18px; font-weight: bold; line-height: 25px; background-color: rgb(0, 154, 97); text-shadow: gray 0px 1px 0px; border-radius: 5px; color: white; box-shadow: gray 0px 0px 5px; font-family: 微软雅黑, 宋体, 黑体, Arial; height: 25px;">Brute-Force算法</span></h2><div style="margin-top: 10px; margin-bottom: 10px; white-space: pre-wrap; word-wrap: break-word;"><div style="margin: auto; vertical-align: middle; background: rgb(255, 255, 255); height: auto; overflow-x: auto; color: rgb(0, 0, 0); line-height: 1.5 !important; font-family: &quot;Courier New&quot;, sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; padding: 5px !important; border-radius: 3px !important;"><div><br/></div><div><span style="color: rgb(0, 0, 255);">function</span> <span style="color: rgb(163, 21, 21);">indexOf</span>(longStr, shortStr, pos) {</div><div><br/></div><div><span style="color: rgb(0, 0, 255);">var</span> i = pos || 0</div><div><span style="color: green;">/*------------------------------------*/</span></div><div><span style="color: green;">//若串S中从第pos(S的下标0&lt;= pos &lt;=StrLength(S))个字符起存在和串T相同的子串，则匹配成功。</span></div><div><span style="color: green;">//返回第一个这样的子串在串S中的下标；否则返回-1</span></div><div><br/></div><div><span style="color: rgb(0, 0, 255);">var</span> j = 0;</div><div><span style="color: rgb(0, 0, 255);">while</span> (<span style="color: rgb(163, 21, 21);">true</span>) {</div><div><span style="color: rgb(0, 0, 255);">if</span> (longStr[i + j] == <span style="color: rgb(0, 0, 255);">void</span> 0)</div><div><span style="color: rgb(0, 0, 255);">break</span></div><div><span style="color: rgb(0, 0, 255);">if</span> (longStr[i + j] === shortStr[j]) {</div><div>j++; <span style="color: green;">//继续比较后一个字符</span></div><div><span style="color: rgb(0, 0, 255);">if</span> (shortStr[j] === <span style="color: rgb(0, 0, 255);">void</span> 0) {</div><div><span style="color: rgb(0, 0, 255);">return</span> i</div><div>}</div><div>} <span style="color: rgb(0, 0, 255);">else</span> {</div><div><span style="color: green;">//重新开始新一轮的匹配</span></div><div>i++;</div><div>j = 0;</div><div>}</div><div>}</div><div><br/></div><div><span style="color: rgb(0, 0, 255);">return</span> -1; <span style="color: green;">//串S中(第pos个字符起)不存在和串T相同的子串</span></div><div>}</div><div><span style="color: rgb(0, 0, 255);">console</span>.log(indexOf(<span style="color: rgb(163, 21, 21);">'aadddaa'</span>, <span style="color: rgb(163, 21, 21);">'ddd'</span>))</div></div></div><h2 style="margin: 15px 0px !important; font-size: 18px; font-weight: bold; line-height: 25px; background-color: rgb(0, 154, 97); text-shadow: gray 0px 1px 0px; padding: 10px; border-radius: 5px; color: white; box-shadow: gray 0px 0px 5px; font-family: 微软雅黑, 宋体, 黑体, Arial; height: 25px;"><span style="font-size: 18px; font-weight: bold; line-height: 25px; background-color: rgb(0, 154, 97); text-shadow: gray 0px 1px 0px; border-radius: 5px; color: white; box-shadow: gray 0px 0px 5px; font-family: 微软雅黑, 宋体, 黑体, Arial; height: 25px;">KMP算法</span></h2><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">第二个是大名鼎鼎的“看毛片”算法，由Knuth，Morris，Pratt三人分别独立研究出来，其对于任何模式和目标序列，都可以在线性时间内完成匹配查找，而不会发生退化，是一个非常优秀的模式匹配算法。它的核心思想是预处理模式串，将模式串构造一个跳转表，有两种形式的跳转表，next与nextval, nextval可以基于next构建，也可以不。</span></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">下面这篇文章详KMP 的工件原理，大家有兴趣看看</span></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><a href="http://blog.csdn.net/qq_29501587/article/details/52075200" style="line-height: 1.5; text-indent: 2em; font-size: 14px; color: rgb(119, 0, 0);">http://blog.csdn.net/qq_29501587/article/details/52075200</a></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">但如何构建next,nextval呢？我搜了许多文章终于找到相关介绍，我汇总在下面的算法中了。</span></div><div style="margin-top: 10px; margin-bottom: 10px; white-space: pre-wrap; word-wrap: break-word;"><div style="margin: auto; vertical-align: middle; background: rgb(255, 255, 255); height: auto; overflow-x: auto; color: rgb(0, 0, 0); line-height: 1.5 !important; font-family: &quot;Courier New&quot;, sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; padding: 5px !important; border-radius: 3px !important;"><div><span style="color: rgb(0, 0, 255);">function</span> <span style="color: rgb(163, 21, 21);">getNext</span>(str) {</div><div><span style="color: green;">// 求出每个子串的前后缀的共有长度，然后全部整体后移一位，首项为定值-1，得到next数组：</span></div><div><span style="color: green;">//首先可以肯定的是第一位的next值为0，第二位的next值为1，后面求解每一位的next值时，</span></div><div><span style="color: green;">//根据前一位的next值对应的字符与当前字符比较，相同，在前一位的next值加1，</span></div><div><span style="color: green;">//否则直接让它与第一个字符比较，求得共有长度</span></div><div><span style="color: green;">//比如说ababcabc</span></div><div><span style="color: rgb(0, 0, 255);">var</span> next = [0] <span style="color: green;">//第一个子串只有一个字母，不用比较，没有公共部分，为0</span></div><div><span style="color: rgb(0, 0, 255);">for</span> (<span style="color: rgb(0, 0, 255);">var</span> i = 1, n = str.length; i &lt; n; i++) {</div><div><span style="color: rgb(0, 0, 255);">var</span> c = str[i]</div><div><span style="color: rgb(0, 0, 255);">var</span> index = next[i - 1]</div><div><span style="color: rgb(0, 0, 255);">if</span> (str[index] === c) { <span style="color: green;">// a, a</span></div><div>next[i] = index + 1</div><div>} <span style="color: rgb(0, 0, 255);">else</span> {</div><div>next[i] = str[0] === c ? 1 : 0 <span style="color: green;">//第一次比较a, b</span></div><div>}</div><div>}</div><div><span style="color: green;">// [0, 0, 1, 2, 0, 1, 2, 0]</span></div><div>next.unshift(-1)</div><div>next.pop();</div><div><span style="color: green;">// -1, 0 , 0, 1,2 ,0,1,2</span></div><div><span style="color: rgb(0, 0, 255);">return</span> next</div><div>}</div><div><br/></div><div><span style="color: rgb(0, 0, 255);">function</span> <span style="color: rgb(163, 21, 21);">getNextVal</span>(str) {</div><div><span style="color: green;">//<a href="http://blog.csdn.net/liuhuanjun222/article/details/48091547">http://blog.csdn.net/liuhuanjun222/article/details/48091547</a></span></div><div><span style="color: rgb(0, 0, 255);">var</span> next = getNext(str)</div><div><span style="color: green;">//我们令 nextval[0] = -1。从 nextval[1] 开始，如果某位(字符)与它 next 值指向的位(字符)相同，</span></div><div><span style="color: green;">//则该位的 nextval 值就是指向位的 nextval 值(nextval[i] = nextval[ next[i] ])；</span></div><div><span style="color: green;">//如果不同，则该位的 nextval 值就是它自己的 next 值(nextvalue[i] = next[i])。</span></div><div><span style="color: rgb(0, 0, 255);">var</span> nextval = [-1]</div><div><span style="color: rgb(0, 0, 255);">for</span> (<span style="color: rgb(0, 0, 255);">var</span> i = 0, n = str.length; i &lt; n; i++) {</div><div><span style="color: rgb(0, 0, 255);">if</span> (str[i] === str[next[i]]) {</div><div>nextval[i] = nextval[next[i]]</div><div>} <span style="color: rgb(0, 0, 255);">else</span> {</div><div>nextval[i] = next[i]</div><div>}</div><div>}</div><div><span style="color: rgb(0, 0, 255);">return</span> nextval</div><div>}</div><div><br/></div><div><span style="color: green;">/**</span> <span style="color: green;">* KMP 算法分三分，第一步求next数组，第二步求nextval数组，第三步匹配</span> <span style="color: green;">* <a href="http://blog.csdn.net/v_july_v/article/details/7041827">http://blog.csdn.net/v_july_v/article/details/7041827</a></span> <span style="color: green;">*</span> <span style="color: green;">* 前两步的求法</span> <span style="color: green;">* <a href="http://blog.csdn.net/liuhuanjun222/article/details/48091547">http://blog.csdn.net/liuhuanjun222/article/details/48091547</a></span> <span style="color: green;">*</span> <span style="color: green;">*/</span></div><div><span style="color: rgb(0, 0, 255);">function</span> <span style="color: rgb(163, 21, 21);">KmpSearch</span>(s, p) {</div><div><span style="color: rgb(0, 0, 255);">var</span> i = 0;</div><div><span style="color: rgb(0, 0, 255);">var</span> j = 0;</div><div><span style="color: rgb(0, 0, 255);">var</span> sLen = s.length</div><div><span style="color: rgb(0, 0, 255);">var</span> pLen = p.length</div><div><span style="color: rgb(0, 0, 255);">var</span> next = getNextVal(p)</div><div><span style="color: rgb(0, 0, 255);">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen) {</div><div><span style="color: green;">//①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++</span></div><div><span style="color: rgb(0, 0, 255);">if</span> (j == -1 || s[i] == p[j]) {</div><div>i++;</div><div>j++;</div><div>} <span style="color: rgb(0, 0, 255);">else</span> {</div><div><span style="color: green;">//②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]</span></div><div><span style="color: green;">//next[j]即为j所对应的next值</span></div><div>j = next[j];</div><div>}</div><div>}</div><div><span style="color: rgb(0, 0, 255);">if</span> (j == pLen)</div><div><span style="color: rgb(0, 0, 255);">return</span> i - j;</div><div><span style="color: rgb(0, 0, 255);">else</span></div><div><span style="color: rgb(0, 0, 255);">return</span> -1;</div><div>}</div><div><span style="color: rgb(0, 0, 255);">console</span>.log(KmpSearch(<span style="color: rgb(163, 21, 21);">'abacababc'</span>, <span style="color: rgb(163, 21, 21);">'abab'</span>))</div></div></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">你可以将这种算法看成DFA （有穷状态自动机）的一种退化写法，但非常晦涩，它是世界第一次打破字符串快速匹配的困局，启迪人们如何跳着匹配字符串了。</span></div><h2 style="margin: 15px 0px !important; font-size: 18px; font-weight: bold; line-height: 25px; background-color: rgb(0, 154, 97); text-shadow: gray 0px 1px 0px; padding: 10px; border-radius: 5px; color: white; box-shadow: gray 0px 0px 5px; font-family: 微软雅黑, 宋体, 黑体, Arial; height: 25px;"><span style="font-size: 18px; font-weight: bold; line-height: 25px; background-color: rgb(0, 154, 97); text-shadow: gray 0px 1px 0px; border-radius: 5px; color: white; box-shadow: gray 0px 0px 5px; font-family: 微软雅黑, 宋体, 黑体, Arial; height: 25px;">Boyer-Moore算法</span></h2><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">Boyer-Moore算法是我们文本编辑器进行diff时，使用的一种高效算法，比KMP快三到四倍，思想也是预处理模式串，得到坏字符规则和好后缀规则移动的映射表，下面代码中MakeSkip是建立坏字符规则移动的映射表，MakeShift是建立好后缀规则的移动映射表。</span></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">下面是阮一峰的文章，简单介绍什么是坏字符串与好后缀，但没有如何介绍如何实现。</span></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><a href="http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html" style="line-height: 1.5; text-indent: 2em; font-size: 14px; color: rgb(119, 0, 0);">http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html</a></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">坏字符串还能轻松搞定，但好后缀就难了，都是n^2, n^3的复杂度，里面的循环大家估计也很难看懂。。。</span></div><div style="margin-top: 10px; margin-bottom: 10px; white-space: pre-wrap; word-wrap: break-word;"><div style="margin: auto; vertical-align: middle; background: rgb(255, 255, 255); height: auto; overflow-x: auto; color: rgb(0, 0, 0); line-height: 1.5 !important; font-family: &quot;Courier New&quot;, sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; padding: 5px !important; border-radius: 3px !important;"><div><span style="color: green;">//<a href="http://blog.csdn.net/joylnwang/article/details/6785743">http://blog.csdn.net/joylnwang/article/details/6785743</a></span></div><div><span style="color: green;">// <a href="http://blog.chinaunix.net/uid-24774106-id-2901288.html">http://blog.chinaunix.net/uid-24774106-id-2901288.html</a></span></div><div><br/></div><div><span style="color: rgb(0, 0, 255);">function</span> <span style="color: rgb(163, 21, 21);">makeSkip</span>(pattern) { <span style="color: green;">//效率更高</span></div><div><span style="color: rgb(0, 0, 255);">var</span> skip = {}</div><div><span style="color: rgb(0, 0, 255);">for</span> (<span style="color: rgb(0, 0, 255);">var</span> n = pattern.length - 1, i = 0; n &gt;= 0; n--, i++) {</div><div><span style="color: rgb(0, 0, 255);">var</span> c = pattern[n]</div><div><span style="color: rgb(0, 0, 255);">if</span> (!(c <span style="color: rgb(0, 0, 255);">in</span> skip)) {</div><div>skip[c] = i <span style="color: green;">//最后一个字符串为0，倒二为1，倒三为2，重复跳过</span></div><div>}</div><div>}</div><div><span style="color: rgb(0, 0, 255);">return</span> skip</div><div>}</div><div><br/></div><div><span style="color: rgb(0, 0, 255);">function</span> <span style="color: rgb(163, 21, 21);">makeShift</span>(pattern) {</div><div><span style="color: rgb(0, 0, 255);">var</span> i, j, c, goods = []</div><div><span style="color: rgb(0, 0, 255);">var</span> patternLen = pattern.length</div><div><span style="color: rgb(0, 0, 255);">var</span> len = patternLen - 1</div><div><span style="color: rgb(0, 0, 255);">for</span> (i = 0; i &lt; len; ++i) {</div><div>goods[i] = patternLen</div><div>}</div><div><br/></div><div><span style="color: green;">//初始化pattern最末元素的好后缀值</span></div><div>goods[len] = 1;</div><div><br/></div><div><span style="color: green;">//此循环找出pattern中各元素的pre值，这里goods数组先当作pre数组使用</span></div><div><span style="color: rgb(0, 0, 255);">for</span> (i = len, c = 0; i != 0; --i) {</div><div><span style="color: rgb(0, 0, 255);">for</span> (j = 0; j &lt; i; ++j) {</div><div><span style="color: rgb(0, 0, 255);">if</span> (pattern.slice(i, len) === pattern.slice(j, len)) {</div><div><span style="color: rgb(0, 0, 255);">if</span> (j == 0) {</div><div>c = patternLen - i;</div><div>} <span style="color: rgb(0, 0, 255);">else</span> {</div><div><span style="color: rgb(0, 0, 255);">if</span> (pattern[i - 1] != pattern[j - 1]) {</div><div>goods[i - 1] = j - 1;</div><div>}</div><div>}</div><div>}</div><div>}</div><div>}</div><div><br/></div><div><span style="color: green;">//根据pattern中个元素的pre值，计算goods值</span></div><div><span style="color: rgb(0, 0, 255);">for</span> (i = 0; i &lt; len; i++) {</div><div><span style="color: rgb(0, 0, 255);">if</span> (goods[i] != patternLen) {</div><div>goods[i] = len - goods[i];</div><div>} <span style="color: rgb(0, 0, 255);">else</span> {</div><div>goods[i] = len - i + goods[i];</div><div><br/></div><div><span style="color: rgb(0, 0, 255);">if</span> (c != 0 &amp;&amp; len - i &gt;= c) {</div><div>goods[i] -= c;</div><div>}</div><div>}</div><div>}</div><div><span style="color: rgb(0, 0, 255);">return</span> goods</div><div>}</div><div><br/></div><div><span style="color: rgb(0, 0, 255);">function</span> <span style="color: rgb(163, 21, 21);">BMSearch</span>(text, pattern) {</div><div><span style="color: rgb(0, 0, 255);">var</span> i, j, m = 0</div><div><span style="color: rgb(0, 0, 255);">var</span> patternLen = pattern.length</div><div><span style="color: rgb(0, 0, 255);">var</span> textLen = text.length</div><div>i = j = patternLen - 1</div><div><br/></div><div><span style="color: rgb(0, 0, 255);">var</span> skip = makeSkip(pattern) <span style="color: green;">//坏字符表</span></div><div><span style="color: rgb(0, 0, 255);">console</span>.log(skip)</div><div><span style="color: rgb(0, 0, 255);">var</span> goods = makeShift(pattern) <span style="color: green;">//好后缀表</span></div><div><span style="color: rgb(0, 0, 255);">var</span> matches = []</div><div><span style="color: rgb(0, 0, 255);">while</span> (j &lt; textLen) { <span style="color: green;">//j 是给text使用</span></div><div><span style="color: green;">//发现目标传与模式传从后向前第1个不匹配的位置</span></div><div><span style="color: rgb(0, 0, 255);">while</span> ((i != 0) &amp;&amp; (pattern[i] == text[j])) {</div><div>--i</div><div>--j</div><div>}</div><div><br/></div><div><span style="color: green;">//找到一个匹配的情况</span></div><div><span style="color: rgb(0, 0, 255);">var</span> c = text[j]</div><div><span style="color: rgb(0, 0, 255);">if</span> (i == 0 &amp;&amp; pattern[i] == c) {</div><div>matches.push(j)</div><div>j += goods[0]</div><div>} <span style="color: rgb(0, 0, 255);">else</span> {</div><div><span style="color: green;">//坏字符表用字典构建比较合适</span></div><div>j += <span style="color: rgb(0, 0, 255);">Math</span>.max(goods[i], <span style="color: rgb(0, 0, 255);">typeof</span> skip[c] === <span style="color: rgb(163, 21, 21);">'number'</span> ? skip[c] : patternLen)</div><div>}</div><div><br/></div><div>i = patternLen - 1 <span style="color: green;">//回到最后一位</span></div><div>}</div><div><br/></div><div><span style="color: rgb(0, 0, 255);">return</span> matches</div><div>}</div><div><br/></div><div><br/></div><div><span style="color: rgb(0, 0, 255);">console</span>.log(BMSearch(<span style="color: rgb(163, 21, 21);">'HERE IS ASIMPLE EXAMPLE'</span>, <span style="color: rgb(163, 21, 21);">'EXAMPLE'</span>))</div></div></div><blockquote style="background: none rgb(245, 245, 245); border-top: none; border-right: none; border-bottom: none; border-left: 4px solid rgb(221, 221, 221); padding: 5px 15px; margin: 15px 0px; color: rgb(119, 119, 119);"><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">对于进阶的单模式匹配算法而言，子串（前缀/后缀）的自包含，是至关重要的概念，是加速模式匹配效率的金钥匙，而将其发扬光大的无疑是KMP算法，BM算法使用后缀自包含，从&gt;后向前匹配模式串的灵感，也源于此，只有透彻理解KMP算法，才可能透彻理解BM算法。</span></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">坏字符表，可以用于加速任何的单模式匹配算法，而不仅限于BM算法，对于KMP算法，坏字符表同样可以起到大幅增加匹配速度的效果。对于大字符集的文字，我们需要改变坏字符表&gt;的使用思路，用字典来保存模式串中的字符的跳转步数，对于在字典中没有查到的字符，说明其不在模式串中，目标串当前字符直接滑动patlen个字符。</span></div></blockquote><h2 style="margin: 15px 0px !important; font-size: 18px; font-weight: bold; line-height: 25px; background-color: rgb(0, 154, 97); text-shadow: gray 0px 1px 0px; padding: 10px; border-radius: 5px; color: white; box-shadow: gray 0px 0px 5px; font-family: 微软雅黑, 宋体, 黑体, Arial; height: 25px;"><span style="font-size: 18px; font-weight: bold; line-height: 25px; background-color: rgb(0, 154, 97); text-shadow: gray 0px 1px 0px; border-radius: 5px; color: white; box-shadow: gray 0px 0px 5px; font-family: 微软雅黑, 宋体, 黑体, Arial; height: 25px;">BMH算法</span></h2><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">BMH 算法是在BM算法上改进而来，舍弃晦涩复杂的后好缀算法，仅考虑了“坏字符”策略。它首先比较文本指针所指字符和模式串的最后一个字符，如果相等再比较其余m一1个字符。无论文本中哪个字符造成了匹配失败，都将由文本中和模式串最后一个位置对应的字符来启发模式向右的移动。关于“坏字符”启发和“好尾缀”启发的对比，孙克雷的研究表明：“坏字符”启发在匹配过程中占主导地位的概率为94．O3 ，远远高于“好尾缀”启发。在一般情况下，BMH算法比BM有更好的性能，它简化了初始化过程，省去了计算“好尾缀”启发的移动距离，并省去了比较“坏字符”和“好尾缀”的过程。</span></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">算法思想：</span></div><ol style="padding-left: 40px;"><li style="list-style-type: decimal;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">搜索文本时，从后到前搜索；</span></li><li style="list-style-type: decimal;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">如果碰到不匹配时，移动pattern，重新与text进行匹配；</span></li></ol><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">关键：移动位置的计算shift_table如下图所示。</span></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">其中k为Pattern[0 ... m-2]中，使Pattern [ k ] ==Text [ i+m-1 ]的最大值；</span></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">如果没有可以匹配的字符，则使Pattern[ 0 ]==Text [ i+m ]，即移动m个位置</span></div><ol style="padding-left: 40px;"><li style="list-style-type: decimal;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">如果与Pattern完全匹配，返回在Text中对应的位置；</span></li><li style="list-style-type: decimal;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">如果搜索完Text仍然找不到完全匹配的位置，则返回-1，即查找失败</span></li></ol><div style="margin-top: 10px; margin-bottom: 10px; white-space: pre-wrap; word-wrap: break-word;"><div style="margin: auto; vertical-align: middle; background: rgb(255, 255, 255); height: auto; overflow-x: auto; color: rgb(0, 0, 0); line-height: 1.5 !important; font-family: &quot;Courier New&quot;, sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; padding: 5px !important; border-radius: 3px !important;"><div><br/></div><div><span style="color: rgb(0, 0, 255);">function</span> <span style="color: rgb(163, 21, 21);">BMHSearch</span>(test, pattern) {</div><div><span style="color: rgb(0, 0, 255);">var</span> n = test.length</div><div><span style="color: rgb(0, 0, 255);">var</span> m = pattern.length</div><div><span style="color: rgb(0, 0, 255);">var</span> shift = {}</div><div><br/></div><div><span style="color: green;">// 模式串P中每个字母出现的最后的下标，最后一个字母除外</span></div><div><span style="color: green;">// 主串从不匹配最后一个字符，所需要左移的位数</span></div><div><span style="color: rgb(0, 0, 255);">for</span> (<span style="color: rgb(0, 0, 255);">var</span> i = 0; i &lt; m - 1; i++) {</div><div>shift[pattern[i]] = m - i - 1; <span style="color: green;">//就是BM的坏字母表</span></div><div>}</div><div><br/></div><div><span style="color: green;">// 模式串开始位置在主串的哪里</span></div><div><span style="color: rgb(0, 0, 255);">var</span> s = 0;</div><div><span style="color: green;">// 从后往前匹配的变量</span></div><div><span style="color: rgb(0, 0, 255);">var</span> j;</div><div><span style="color: rgb(0, 0, 255);">while</span> (s &lt;= n - m) {</div><div>j = m - 1;</div><div><span style="color: green;">// 从模式串尾部开始匹配</span></div><div><span style="color: rgb(0, 0, 255);">while</span> (test[s + j] == pattern[j]) {</div><div>j--;</div><div><span style="color: green;">// 匹配成功</span></div><div><span style="color: rgb(0, 0, 255);">if</span> (j &lt; 0) {</div><div><span style="color: rgb(0, 0, 255);">return</span> s;</div><div>}</div><div>}</div><div><span style="color: green;">// 找到坏字符(当前跟模式串匹配的最后一个字符)</span></div><div><span style="color: green;">// 在模式串中出现最后的位置(最后一位除外)</span></div><div><span style="color: green;">// 所需要从模式串末尾移动到该位置的步数</span></div><div><span style="color: rgb(0, 0, 255);">var</span> c = test[s + m - 1]</div><div>s = s + (<span style="color: rgb(0, 0, 255);">typeof</span> shift[c] === <span style="color: rgb(163, 21, 21);">'number'</span> ? shift[c] : m)</div><div>}</div><div><span style="color: rgb(0, 0, 255);">return</span> -1;</div><div>}</div><div><span style="color: rgb(0, 0, 255);">console</span>.log(BMHSearch(<span style="color: rgb(163, 21, 21);">'HERE IS ASIMPLE EXAMPLE'</span>, <span style="color: rgb(163, 21, 21);">'EXAMPLE'</span>))</div><div><span style="color: rgb(0, 0, 255);">console</span>.log(BMHSearch(<span style="color: rgb(163, 21, 21);">'missipipi'</span>, <span style="color: rgb(163, 21, 21);">'pip'</span>))</div></div></div><h2 style="margin: 15px 0px !important; font-size: 18px; font-weight: bold; line-height: 25px; background-color: rgb(0, 154, 97); text-shadow: gray 0px 1px 0px; padding: 10px; border-radius: 5px; color: white; box-shadow: gray 0px 0px 5px; font-family: 微软雅黑, 宋体, 黑体, Arial; height: 25px;"><span style="font-size: 18px; font-weight: bold; line-height: 25px; background-color: rgb(0, 154, 97); text-shadow: gray 0px 1px 0px; border-radius: 5px; color: white; box-shadow: gray 0px 0px 5px; font-family: 微软雅黑, 宋体, 黑体, Arial; height: 25px;">Sunday算法</span></h2><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">Sunday算法思想跟BM算法很相似，在匹配失败时关注的是文本串中参加匹配的最末位字符的下一位字符。如果该字符没有在匹配串中出现则直接跳过，即移动步长= 匹配串长度+1；否则，同BM算法一样其移动步长=匹配串中最右端的该字符到末尾的距离+1。</span></div><div style="margin-top: 10px; margin-bottom: 10px; white-space: pre-wrap; word-wrap: break-word;"><div style="margin: auto; vertical-align: middle; background: rgb(255, 255, 255); height: auto; overflow-x: auto; color: rgb(0, 0, 0); line-height: 1.5 !important; font-family: &quot;Courier New&quot;, sans-serif !important; font-size: 12px !important; border: 1px solid rgb(204, 204, 204) !important; padding: 5px !important; border-radius: 3px !important;"><div><span style="color: rgb(0, 0, 255);">function</span> <span style="color: rgb(163, 21, 21);">sundaySearch</span>(text, pattern) {</div><div><span style="color: rgb(0, 0, 255);">var</span> textLen = text.length</div><div><span style="color: rgb(0, 0, 255);">var</span> patternLen = pattern.length</div><div><span style="color: rgb(0, 0, 255);">if</span> (textLen &lt; patternLen)</div><div><span style="color: rgb(0, 0, 255);">return</span> -1</div><div><span style="color: rgb(0, 0, 255);">var</span> shift = {} <span style="color: green;">//创建跳转表</span></div><div><span style="color: rgb(0, 0, 255);">for</span> (i = 0; i &lt; patternLen; i++) {</div><div>shift[pattern[i]] = patternLen - i</div><div>}</div><div><span style="color: rgb(0, 0, 255);">var</span> pos = 0</div><div><span style="color: rgb(0, 0, 255);">while</span> (pos &lt;= (textLen - patternLen)) { <span style="color: green;">//末端对齐</span></div><div><span style="color: rgb(0, 0, 255);">var</span> i = pos,</div><div>j</div><div><span style="color: rgb(0, 0, 255);">for</span> (j = 0; j &lt; patternLen; j++, i++) {</div><div><span style="color: rgb(0, 0, 255);">if</span> (text[i] !== pattern[j]) {</div><div><span style="color: rgb(0, 0, 255);">var</span> c = text[pos + patternLen]</div><div>pos += <span style="color: rgb(0, 0, 255);">typeof</span> shift[c] === <span style="color: rgb(163, 21, 21);">'number'</span> ? shift[c] : patternLen + 1</div><div><span style="color: rgb(0, 0, 255);">break</span></div><div>}</div><div>}</div><div><span style="color: rgb(0, 0, 255);">if</span> (j === patternLen) {</div><div><span style="color: rgb(0, 0, 255);">return</span> pos</div><div>}</div><div>}</div><div><span style="color: rgb(0, 0, 255);">return</span> -1</div><div><br/></div><div>}</div><div><br/></div><div><span style="color: rgb(0, 0, 255);">console</span>.log(sundaySearch(<span style="color: rgb(163, 21, 21);">'HERE IS ASIMPLE EXAMPLE'</span>, <span style="color: rgb(163, 21, 21);">'EXAMPLE'</span>))</div><div><span style="color: rgb(0, 0, 255);">console</span>.log(sundaySearch(<span style="color: rgb(163, 21, 21);">'missipipi'</span>, <span style="color: rgb(163, 21, 21);">'pip'</span>))</div></div></div><h2 style="margin: 15px 0px !important; font-size: 18px; font-weight: bold; line-height: 25px; background-color: rgb(0, 154, 97); text-shadow: gray 0px 1px 0px; padding: 10px; border-radius: 5px; color: white; box-shadow: gray 0px 0px 5px; font-family: 微软雅黑, 宋体, 黑体, Arial; height: 25px;"><span style="font-size: 18px; font-weight: bold; line-height: 25px; background-color: rgb(0, 154, 97); text-shadow: gray 0px 1px 0px; border-radius: 5px; color: white; box-shadow: gray 0px 0px 5px; font-family: 微软雅黑, 宋体, 黑体, Arial; height: 25px;">Shift-And和Shift-OR算法</span></h2><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">这个算法已经超出笔者的能力，只是简单给出链接</span></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><a href="http://www.iteye.com/topic/1130001" style="line-height: 1.5; text-indent: 2em; font-size: 14px; color: rgb(119, 0, 0);">http://www.iteye.com/topic/1130001</a></div><h1 style="margin: 10px 0px; font-size: 28px; font-weight: bold; line-height: 1.5;"><span style="font-size: 28px; font-weight: bold; line-height: 1.5;">bitmap算法思想</span></h1><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">这个在腾讯面试题考过，但这个算法优缺点也太明显，本文也简单给出链接，供学霸们研究</span></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><a href="http://www.tuicool.com/articles/aYfEvy" style="line-height: 1.5; text-indent: 2em; font-size: 14px; color: rgb(119, 0, 0);">http://www.tuicool.com/articles/aYfEvy</a></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">更多链接（里面有更多算法实现与复杂度介绍）</span></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><a href="http://blog.csdn.net/airfer/article/details/8951802/" style="line-height: 1.5; text-indent: 2em; font-size: 14px; color: rgb(119, 0, 0);">http://blog.csdn.net/airfer/article/details/8951802/</a></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><img src="https://images2015.cnblogs.com/blog/65123/201704/65123-20170410110840985-52441719.png" style="border: 0px; max-width: 900px;"></img></div><div style="margin: 10px auto; line-height: 1.5; text-indent: 2em; font-size: 14px;"><span style="line-height: 1.5; text-indent: 2em; font-size: 14px;">像我们这样的平常人怎么在项目用它们呢，可能在前端比较少用，但也不是没有，如富文本编辑器，日志处理，用了它们性能提升一大截。总之，不要天天做轻松的事，否则你没有进步。</span></div></div><div><br/></div><div><b><font style="font-size: 12pt; color: rgb(20, 113, 145);">原文地址：<a href="http://www.cnblogs.com/rubylouvre/p/6658625.html" style="color: rgb(20, 113, 145);">http://www.cnblogs.com/rubylouvre/p/6658625.html</a></font></b></div></div></span>
</div></body></html> 