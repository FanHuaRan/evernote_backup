<html>
<head>
  <title>listener监听器详解</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1441"/>
<h1>listener监听器详解</h1>

<div>
<span><div><h2 style="margin: 0px 0px 4px; font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="color: rgb(26, 144, 185); font-size: 18pt;">个人理解</font></h2><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 18pt; color: rgb(26, 144, 185);"><b>原文</b></font></div><div><font style="font-size: 12pt;">地址：<a href="http://www.cnblogs.com/chenweichu/articles/5644312.html">http://www.cnblogs.com/chenweichu/articles/5644312.html</a></font></div><div style="margin: 10px auto; text-indent: 0px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><div>关于Listener详解</div><div>ServletContextListener</div><div>ServletContextListener接口能够监听ServletContext对象的生命周期，实际上就是监听Web应用的生命周期。当Servlet容器启动或终止Web应用时，会触发ServletContextEvent事件，该事件由ServletContextListener来处理。在ServletContextListener接口中定义了处理ServletContextEvent事件的两个方法：</div><div>contextInitialized (ServletContextEvent  event)</div><div>当Servlet容器启动Web应用时调用该方法。在调用完该方法之后，容器再对Filter 初始化，并且对那些在Web 应用启动时就需要被初始化的Servlet 进行初始化。用途：Web服务器启动时加载数据到内存中…………..</div><div>contextDestroyed(ServletContextEvent  event) </div><div>当Servlet 容器终止Web 应用时调用该方法。在调用该方法之前，容器会先销毁所有的Servlet 和Filter 过滤器。</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">public ServletContext getServletContext();//ServletContextEvent事件：取得一个ServletContext（application）对象</span></div></div><div style="margin: 10px auto; text-indent: 0px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><div><br/></div><div>HttpSessionListener</div><div>Session创建事件发生在每次一个新的session创建的时候，类似地Session失效事件发生在每次一个Session失效的时候。对Session的整体状态的监听。对每一个正在访问的用户，J2EE应用服务器会为其建立一个对应的HttpSession对象。当一个浏览器第一次访问网站的时候，J2EE应用服务器会新建一个HttpSession对象，并触发 HttpSession创建事件，如果注册了HttpSessionListener事件监听器，则会调用HttpSessionListener事件监听器的sessionCreated方法。相反，当这个浏览器访问结束超时的时候，J2EE应用服务器会销毁相应的HttpSession对象，触发 HttpSession销毁事件，同时调用所注册HttpSessionListener事件监听器的sessionDestroyed方法。</div><div>在 HttpSessionListener接口中定义了处理HttpSessionEvent 事件的两个方法：</div><div>sessionCreated(HttpSessionEvent event);//session创建</div><div>sessionDestroyed(HttpSessionEvent event);//session销毁</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">HttpSession getSession();//取得当前 sessionHttpSessionEvent事件</span></div></div><div style="margin: 10px auto; text-indent: 0px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><div>session的销毁有两种情况：</div><div>1、session超时，web.xml配置：</div><div>&lt;session-config&gt;</div><div>&lt;session-timeout&gt;120&lt;/session-timeout&gt;&lt;!--120分钟后超时销毁--&gt;</div><div>&lt;/session-config&gt;</div><div>2、手工使session失效</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">public void invalidate();//使session失效方法。session.invalidate();</span></div></div><div style="margin: 10px auto; text-indent: 0px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><div><br/></div><div>ServletRequestListener</div><div>用于对Request请求进行监听（创建、销毁）。</div><div>void requestInitialized(ServletRequestEvent sre);//request初始化</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">void requestDestroyed(ServletRequestEvent sre);//request销毁</span></div></div><div style="margin: 10px auto; text-indent: 0px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><div>//ServletRequestEvent事件：</div><div>ServletRequest getServletRequest();//取得一个ServletRequest对象</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">ServletContext getServletContext();//得一个ServletContext（application）对象</span></div></div><div style="margin: 10px auto; text-indent: 0px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><div><br/></div><div>在web.xml中配置</div><div>Listener配置信息必须在Filter和Servlet配置之前，Listener的初始化（ServletContentListener初始化）比Servlet和Filter都优先，而销毁比Servlet和Filter都慢。</div><div>&lt;listener&gt;</div><div>&lt;listener-class&gt;com.listener.class&lt;/listener-class&gt;</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">&lt;/listener&gt;</span></div></div><div style="margin: 10px auto; text-indent: 0px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><div>Listener应用实例</div><div>　　1、利用HttpSessionListener统计最多在线用户人数</div><div>import java.text.DateFormat;</div><div>import java.text.SimpleDateFormat;</div><div>import java.util.Date;</div><div>import javax.servlet.ServletContext;</div><div>import javax.servlet.http.HttpSessionEvent;</div><div>import javax.servlet.http.HttpSessionListener;</div><div>public class HttpSessionListenerImpl implements HttpSessionListener {</div><div>public void sessionCreated(HttpSessionEvent event) {</div><div>ServletContext app = event.getSession().getServletContext();</div><div>int count = Integer.parseInt(app.getAttribute(&quot;onLineCount&quot;).toString());</div><div>count++;</div><div>app.setAttribute(&quot;onLineCount&quot;, count);</div><div>int maxOnLineCount = Integer.parseInt(app.getAttribute(&quot;maxOnLineCount&quot;).toString());</div><div>if (count &gt; maxOnLineCount) {</div><div>//记录最多人数是多少</div><div>app.setAttribute(&quot;maxOnLineCount&quot;, count);</div><div>DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);</div><div>//记录在那个时刻达到上限</div><div>app.setAttribute(&quot;date&quot;, df.format(new Date()));</div><div>}</div><div>}</div><div>//session注销、超时时候调用，停止tomcat不会调用</div><div>public void sessionDestroyed(HttpSessionEvent event) {</div><div>ServletContext app = event.getSession().getServletContext();</div><div>int count = Integer.parseInt(app.getAttribute(&quot;onLineCount&quot;).toString());</div><div>count--;</div><div>app.setAttribute(&quot;onLineCount&quot;, count); </div><div><br/></div><div>}</div><div>}</div><div>　　2、Spring使用ContextLoaderListener加载ApplicationContext配置信息</div><div>　　ContextLoaderListener的作用就是启动Web容器时，自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。</div><div>　　ContextLoaderListener如何查找ApplicationContext.xml的配置位置以及配置多个xml：如果在web.xml中不写任何参数配置信息，默认的路径是&quot;/WEB-INF/applicationContext.xml&quot;，在WEB-INF目录下创建的xml文件的名称必须是applicationContext.xml（在MyEclipse中把xml文件放置在src目录下）。如果是要自定义文件名可以在web.xml里加入contextConfigLocation这个context参数。</div><div>&lt;context-param&gt;</div><div>&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</div><div>&lt;param-value&gt;classpath:spring/applicationContext-*.xml&lt;/param-value&gt;</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">&lt;/context-param&gt;</span></div></div><div style="margin: 10px auto; text-indent: 0px; color: rgb(0, 0, 0); font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><div>&lt;listener&gt;</div><div>&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">&lt;/listener&gt;</span></div></div><div>　　3、Spring使用Log4jConfigListener配置Log4j日志</div><div>　　Spring使用Log4jConfigListener的好处：</div><div>动态的改变记录级别和策略，不需要重启Web应用。把log文件定在 /WEB-INF/logs/ 而不需要写绝对路径。因为系统把web目录的路径压入一个叫webapp.root的系统变量。这样写log文件路径时不用写绝对路径了。可以把log4j.properties和其他properties一起放在/WEB-INF/ ，而不是Class-Path。</div><div>设置log4jRefreshInterval时间，开一条watchdog线程每隔段时间扫描一下配置文件的变化。</div><div>&lt;context-param&gt;</div><div>&lt;param-name&gt;webAppRootKey&lt;/param-name&gt;</div><div>&lt;param-value&gt;webapp.root&lt;/param-value&gt;</div><div>&lt;!-- 用于定位log文件输出位置在web应用根目录下，log4j配置文件中写输出位置：log4j.appender.FILE.File=${project.root}/logs/project.log --&gt;</div><div>&lt;/context-param&gt;</div><div>&lt;context-param&gt;</div><div>&lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt;</div><div>&lt;param-value&gt;classpath:log4j.properties&lt;/param-value&gt;&lt;!-- 载入log4j配置文件 --&gt;</div><div>&lt;/context-param&gt;</div><div>&lt;context-param&gt;</div><div>&lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt;</div><div>&lt;param-value&gt;60000&lt;/param-value&gt;</div><div>&lt;!--Spring刷新Log4j配置文件的间隔60秒,单位为millisecond--&gt;</div><div>&lt;/context-param&gt;</div><div>&lt;listener&gt;</div><div>&lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt;</div><div>&lt;/listener&gt;</div><div>　　4、Spring使用IntrospectorCleanupListener清理缓存</div><div>　　这个监听器的作用是在web应用关闭时刷新JDK的JavaBeans的Introspector缓存，以确保Web应用程序的类加载器以及其加载的类正确的释放资源。如果JavaBeans的Introspector已被用来分析应用程序类，系统级的Introspector缓存将持有这些类的一个硬引用。因此，这些类和Web应用程序的类加载器在Web应用程序关闭时将不会被垃圾收集器回收！而IntrospectorCleanupListener则会对其进行适当的清理，已使其能够被垃圾收集器回收。唯一能够清理Introspector的方法是刷新整个Introspector缓存，没有其他办法来确切指定应用程序所引用的类。这将删除所有其他应用程序在服务器的缓存的Introspector结果。</div><div>　　在使用Spring内部的bean机制时，不需要使用此监听器，因为Spring自己的introspection results cache将会立即刷新被分析过的JavaBeans Introspector cache，而仅仅会在应用程序自己的ClassLoader里面持有一个cache。虽然Spring本身不产生泄漏，注意，即使在Spring框架的类本身驻留在一个“共同”类加载器（如系统的ClassLoader）的情况下，也仍然应该使用使用IntrospectorCleanupListener。在这种情况下，这个IntrospectorCleanupListener将会妥善清理Spring的introspection cache。</div><div>　　应用程序类，几乎不需要直接使用JavaBeans Introspector，所以，通常都不是Introspector resource造成内存泄露。相反，许多库和框架，不清理Introspector，例如： Struts和Quartz。</div><div>　　需要注意的是一个简单Introspector泄漏将会导致整个Web应用程序的类加载器不会被回收！这样做的结果，将会是在web应用程序关闭时，该应用程序所有的静态类资源（比如：单实例对象）都没有得到释放。而导致内存泄露的根本原因其实并不是这些未被回收的类！</div><div>　　注意：IntrospectorCleanupListener应该注册为web.xml中的第一个Listener，在任何其他Listener之前注册，比如在Spring's ContextLoaderListener注册之前，才能确保IntrospectorCleanupListener在Web应用的生命周期适当时机生效。</div><div>&lt;!-- memory clean --&gt;</div><div>&lt;listener&gt;</div><div>&lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt;</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">&lt;/listener&gt;</span></div><div><br/></div></div></span>
</div></body></html> 