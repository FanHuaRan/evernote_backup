<html>
<head>
  <title>第七章 虚拟机类加载机制</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1001"/>
<h1>第七章 虚拟机类加载机制</h1>

<div>
<span><div><div><span style="min-height: 15pt;"><font style="font-size: 18pt; color: rgb(26, 144, 185);"><b>一.概述</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  虚拟机类加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型叫做虚拟机的类加载。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  与那些在编译时需要进行链接工作的语言不同，在java语言里面，类型的加载、连接和初始化过程都是在运行期完成的，这虽然会让类加载增加性能开销，但是会为java应用程序提供高度的灵活性。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt;"><font style="color: rgb(26, 144, 185); font-size: 18pt;"><b>二.类加载的时机</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  类的整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载7个阶段。其中验证、准备、解析三个部分统称为连接。如下：</font></span></div><div style="min-height: 15pt;"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"> </span> <img src="第七章 虚拟机类加载机制_files/Image.png" type="image/png" data-filename="Image.png" width="549"/></font></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">加载、验证、准备、初始化和卸载这5个阶段的顺序一定，类加载过程必须按照这种顺序开始，而解析阶段不一定。注意这5个阶段可以交叉进行。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">前五个阶段属于虚拟机的类加载阶段，注意加载阶段包括在类加载阶段。</font></span></div><div style="min-height: 15pt;"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(255, 0, 0); font-weight: bold;">类加载的第一个阶段加载什么时候进行没有强制约束，虚拟机自由把握。但是初始化阶段，虚拟机严格规定有且只有以下五种情况必须立即对类进行初始化（加载、验证、准备、解析自然要在初始化前进行，一般是某个类的加载过程当中的解析过程当中就会触发其符号引用所关联的类的加载、验证、准备、解析阶段）</span><span style="min-height: 15pt; color: rgb(1, 1, 1);">：</span></font></div><ol style="margin-top: 0mm; margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;"><li style="margin-left: 15pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">使用new关键字实例化对象、读取或者设置一个类的静态字段、以及调用一个类的静态方法（被static final修饰的静态常量且已在编译期把结果放入常量池的静态字段除外）的时候。</span><br/></font></li><li style="margin-left: 15pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">使用反射调用类时</span><br/></font></li><li style="margin-left: 15pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">当初始化一个类时，若父类未加载，先触发父类的初始化</span><br/></font></li><li style="margin-left: 15pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">虚拟机启动时，用户指定的主类，虚拟机会先进行初始化</span><br/></font></li><li style="margin-left: 15pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">动态语言支持的情况</span><br/></font></li></ol><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">注意：</font></span></div><ol style="margin-top: 0mm; margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;"><li style="margin-left: 15pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">对于静态字段和方法，只有直接定义这个字段/方法的类才会被初始化，通过子类引用调用父类的静态字段/方法只会触发父类的初始化，可以通过-XX:+TraceClassLoading开开启触发子类加载。</span><br/></font></li><li style="margin-left: 15pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">创建引用类型数组，不会触发引用类的初始化，而是触发对应引用类型数组的初始化。</span><br/></font></li><li style="margin-left: 15pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">静态常量可能经过编译传播优化，可能不会引发所在类的初始化。</span><br/></font></li><li style="margin-left: 15pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">数组类本身并不由类加载器加载，而是虚拟机直接构成。</span><br/></font></li></ol><div style="min-height: 15pt;"><span style="min-height: 15pt;"><font style="color: rgb(26, 144, 185); font-size: 18pt;"><b>三.类加载的过程</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><b>1.加载</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">     加载是类加载过程的第一个阶段，完成以下三件事情：</font></span></div><ol style="margin-top: 0mm; margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;"><li style="margin-left: 41pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">通过一个类的全限定名来获取此类的二进制字节流</span><br/></font></li><li style="margin-left: 41pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</span><br/></font></li><li style="margin-left: 41pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">在内存中生成一个代表此类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</span><br/></font></li></ol><div style="margin-left: 9mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  注意：加载阶段和连接阶段是交叉进行的。</font></span></div><div style="margin-left: 9mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="color: rgb(1, 1, 1); font-size: 12pt; text-indent: 0mm;"><b>2.验证</b></span><br/></div><div style="margin-left: 9mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  验证是连接阶段的第一步，这一阶段的目的是为了确保class文件的字节流所包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的安全。</font></span></div><div style="margin-left: 9mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  包括以下4个阶段的校验动作：</font></span></div><ol style="margin-top: 0mm; margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;"><li style="margin-left: 47pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">文件格式验证</span><br/></font></li><li style="margin-left: 47pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">元数据验证</span><br/></font></li><li style="margin-left: 47pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">字节码验证</span><br/></font></li><li style="margin-left: 47pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">符号引用验证：符号引用验证实际上会在解析阶段发生，通常需要校验以下内容：</span><br/></font></li></ol><ol style="margin-top: 0mm; margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;"><li style="margin-left: 83pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">符号引用通过字符串描述的全限定名是否能找到对应的类</span><br/></font></li><li style="margin-left: 83pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段</span><br/></font></li><li style="margin-left: 83pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">符号引用中的类、字段、方法和类的可访问性是否可以被当前类访问</span><br/></font></li></ol><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><b>3.准备</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">       准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都需要在方法区分配，初始值基本是零值。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">       注意：对于static final类型，且字面量直接赋值，编译时虚拟机将会为value生成constantvalue属性，在准备阶段就会直接赋值！</font></span></div><div style="margin-left: 0mm; margin-right: 0mm; text-indent: 7mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 7mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><b>4.解析</b></font></span></div><div style="margin-left: 6mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">   解析阶段是虚拟机将常量池的符号引用替换为直接引用的过程（有些是解析不出来的，对于虚方法只能运行时确定）。</font></span></div><div style="margin-left: 6mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><div><span style="color: rgb(1, 1, 1);"><font style="font-size: 12pt;">   符号引用和直接引用的区别：符号引用就是一堆静态的字符串符号，直接引用是可以直接指向目标的指针、相对偏移量或是一个能够间接定位到目标的句柄。</font></span></div><div><span style="color: rgb(1, 1, 1);"><font style="font-size: 12pt;">   解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符（后三种是动态语言相关）。</font></span></div></div><ol style="margin-top: 0mm; margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;"><li style="margin-left: 44pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">类或接口的解析：可能会触发相应类或接口的加载、验证、准备和解析</span><br/></font></li><li style="margin-left: 44pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">字段解析：最终结果是找到该字段的直接引用或者抛出NoSuchFieldError，注意，注意：这儿的直接引用不一定是指针（实例字段要运行时才能真的拿到指针）</span><br/></font></li><li style="margin-left: 44pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">类方法解析：这儿所说的类方法是说属于类的方法</span><br/></font></li><li style="margin-left: 44pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">接口方法解析：这儿所说的接口方法时说属于接口的方法</span><br/></font></li></ol><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><b>5.初始化</b></font></span></div><div style="margin-left: 10mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"> 初始化时是类加载过程的最后一步，前面的过程完全由虚拟机主导控制，这个阶段可以代码自我控制。该阶段开始执行类中定义的初始化程序代码。</font></span></div><div style="margin-left: 10mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"> 初始化阶段实际上是执行类构造器“clinit()”方法的过程，clinit方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块而合并产生。编译器收集顺序是由源文件代码顺序决定，上面的只能为下面赋值，不能引用。</font></span></div><div style="margin-left: 10mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"> 实际上类中静态变量和块的顺序应该是：静态常量赋值（constant value在准备阶段）-&gt;静态变量和静态代码块的源文件顺序。</font></span></div><div style="margin-left: 10mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"> Clinit方法的执行是会加锁的，所以线程安全，Clinit方法只执行一次。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt;"><font style="font-size: 18pt; color: rgb(26, 144, 185);"><b>四.类加载器</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  <b>1.类与类加载器</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  类加载器虽然只用于实现类的加载，只有bootstrap和extclassloader和虚拟机绑定，其它都不和虚拟机绑定，这为java程序带来了巨大的灵活性和扩展性，一个类的唯一性由类本身和类加载器一同确定。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  <b>2.全盘负责</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  类的加载过程中遇到的类的加载都由该类加载器去加载“加载”。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  <b>3.双亲委托</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">   启动类加载器（bootstrapclassloader）：加载存放在&lt;JAVA_HOME&gt;\lib目录中的类</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">   扩展类加载器（ExtClassLoader）: 加载存放在&lt;JAVA_HOME&gt;\lib\ext目录中的类</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">   系统类加载器（AppClassLoader）: 程序默认的类加载器</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">   自定义类加载器</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">   优先父亲加载，父亲无法加载，再子类加载。</font></span></div><div style="min-height: 327pt;"><font style="font-size: 12pt;"><span style="min-height: 327pt; color: rgb(1, 1, 1);">  </span> <img src="第七章 虚拟机类加载机制_files/Image [1].png" type="image/png" data-filename="Image.png" width="350"/></font></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  <b>4.破坏双亲委托模型</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">   1.ClassLoader的loadclass方法遵守双亲委托，findclass方法不遵守</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">   2.SPI，线程上下文类加载器</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">   3.OSGI，网状加载器结构</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">   4.tomcat重写loadclass方法</font></span></div></div></span>
</div></body></html> 