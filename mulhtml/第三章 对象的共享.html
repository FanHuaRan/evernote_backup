<html>
<head>
  <title>第三章 对象的共享</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1066"/>
<h1>第三章 对象的共享</h1>

<div>
<span><div><font style="font-size: 18pt; color: rgb(26, 144, 185);"><b>可见性和重排序</b></font></div><div><font style="font-size: 12pt;"><b>什么是可见性？</b></font></div><div><font style="font-size: 12pt;">深入理解jvm中有详细讲解，主要就是一个工作内存和主内存，变量必须通过主内存来向其它线程更新。</font></div><div><font style="font-size: 12pt;">volatile变量，synchronized内的变量，显式锁内的变量可以保证可见性</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>什么是重排序？</b></font></div><div><span style="font-size: 16px;">在没有同步的情况下，编译器、处理器、以及运行时都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序当中，要想对内存操作的执行顺序进行判断，几乎无法得出正确结论。</span></div><div><span style="font-size: 16px;">这看上去是一种失败的设计，不过却能使得jvm充分地利用现代多核处理器的强大性能。例如：在缺少同步的情况下，java内存模型准许编译器对操作顺序进行重排序，并将数值存在寄存器当中，它还准许CPU对操作顺序进行重排序，并将数值缓存在<span style="font-size: 16px;">CPU高速缓存当中。</span></span></div><div><span style="font-size: 16px;">可以简单认为存在两种重排序</span></div><div><span style="font-size: 16px;">1.编译器级别的（解释执行不会）</span></div><div><span style="font-size: 16px;">2.CPU级别的</span></div><div><span style="font-size: 16px;">volatile变量，<span style="font-size: 12pt;">synchronized&amp;显式锁，final变量的特殊规则都可以保证不被重排序</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 16px;"><b>失效数据</b></span></div><div><span style="font-size: 16px;">过期数据，指已经在某个线程被更新，但其他线程却还是读到的是旧值</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;"><b>非原子的64位操作</b></span></div><div><span style="font-size: 16px;">long和double类型在32位虚拟机上准许读和写都可以分两次完成，所以读写不是原子操作，大部分商用虚拟机都保证了它是原子操作</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;"><b>加锁与可见性</b></span></div><div><span style="font-size: 12pt;">synchronized内的变量，显式锁内的变量可以保证可见性</span></div><div><span style="font-size: 16px;">加锁的含义不仅仅在于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作和写操作的线程都必须在同一个锁上同步。</span></div><div><img src="第三章 对象的共享_files/Image.png" type="image/png" data-filename="Image.png" style="font-size: 12pt;"/></div><div><b><font style="font-size: 12pt;">volatile变量的可见性</font></b></div><div><font style="font-size: 12pt;">volatile变量在内存可见性上的作用比锁略低（因为只有volatile变量才有可见性），大多数处理器上，读取volatile变量只比读取普通变量的开销略高一点。</font></div><div><font style="font-size: 12pt;">加锁机制既可以确保可见性，又可以确保原子性，而volatile变量只能确保可见性。</font></div><div><font style="font-size: 12pt;">当且仅当满足以下所有条件时才应该使用volatile变量</font></div><div><font style="font-size: 12pt;">1.对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量值</font></div><div><font style="font-size: 12pt;">2.该变量不会与其它状态变量一起纳入不变性条件当中</font></div><div><font style="font-size: 12pt;">3.在访问变量时不需要锁（锁本身已经有了可见性，再使用volatile就很多余）</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><b><font style="font-size: 12pt;">一个调试小提示</font></b></div><div><br/></div><div><font style="font-size: 18pt; color: rgb(26, 144, 185);"><b>发布与溢出</b></font></div><div><span style="font-size: 16px;"><b>核心</b></span></div><div><span style="font-size: 16px;">发布一个对象的意思是指使对象能够在当前作用域之外的代码中使用。</span></div><div><span style="font-size: 16px;">注意事项：</span></div><div><span style="font-size: 16px;">1.不要使内部的可变状态溢出（getter、setter，尽量对引用类型使用clone）</span></div><div><span style="font-size: 16px;">2.不要显示或者隐式的让this引用溢出<b><br/></b></span></div><div><span style="font-size: 16px;"><b>安全对象的构造过程</b></span></div><div><span style="font-size: 16px;">不要在构造过程当中使this引用溢出，特别是内部类对象。</span></div><div><span style="font-size: 16px;">构造方法应该只有简单逻辑，</span><span style="font-size: 16px;">对于含有复杂逻辑的构造过程，为了安全构造对象和代码清晰，应该使用工厂方法来初始化</span></div><div><b><font style="color: rgb(227, 0, 0);">注意：</font></b></div><div><b><font color="#E30000">还要担心重排序问题，构造方法和引用赋值不满足先行发生原则，因此可能发生构造方法还未结束，但引用已经被获取到的情况，可以使用volatile和final变量来禁止重排序。</font></b></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 18pt; color: rgb(26, 144, 185);"><b>线程封闭</b></font></div><div><span style="font-size: 16px;">如果对象被封闭在线程内部，那么就没有任何的线程问题</span></div><div><span style="font-size: 16px;"><b>1.Ad-hoc线程封闭</b></span></div><div><span style="font-size: 16px;">   感觉是废话，就是说维护线程封闭性的原则完全由程序实现，没有任何一种语言特性可以保证这个</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;"><b>2.栈封闭</b></span></div><div><span style="font-size: 16px;">   局部变量is ok</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;"><b>3.ThreadLocal类</b></span></div><div><font style="font-size: 12pt;">   不多说，但莫乱用</font></div><div><font style="font-size: 18pt;"><b><br/></b></font></div><div><font style="font-size: 18pt; color: rgb(26, 144, 185);"><b>不变性</b></font></div><div><font style="font-size: 12pt;"><b>不可变对象</b></font></div><div><font style="font-size: 12pt;"> 不可变对象一定是线程安全的</font></div><div><font style="font-size: 12pt;"> 不可变对象需要满足以下条件：</font></div><div><font style="font-size: 12pt;">  1.对象创建以后，状态就不能修改</font></div><div><font style="font-size: 12pt;">  2.对象的所有域都是final（可放宽）</font></div><div><font style="font-size: 12pt;">  3.对象是正确创建的（对象创建期间，this引用没有溢出）</font></div><div><font style="font-size: 12pt;">  注意：不可变对象与不可变的对象引用不是一回事！</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>Final域</b></font></div><div><font style="font-size: 12pt;">  关键字final可以视为C++中const机制的一种受限版本，用于构造不可变性对象，final类型的域是不可修改的。然而在java内存模型当中，final域还有着特殊的语义（禁止final域赋值重排序到构造方法之外），从而能确保初始化过程的安全性（参考：<a href="http://blog.csdn.net/lovesummerforever/article/details/78620585" style="font-size: 12pt;">http://blog.csdn.net/lovesummerforever/article/details/78620585</a> ）</font></div><div><font style="font-size: 12pt;">  <font> 对不可变的域都用final修饰是个好习惯</font></font></div><div><font style="font-size: 12pt;"><b><br/></b></font></div><div><font style="font-size: 12pt;"><b>不可变的对象的一种替代同步方案的做法</b></font></div><div>   <font style="font-size: 12pt;">使用包含多个状态变量的容器来维持不变性条件，并使用一个volatile引用来保证可见性。</font></div><div><br/></div><div><font style="font-size: 18pt; color: rgb(26, 144, 185);"><b>安全发布</b></font></div><div><span style="font-size: 16px;"><b>不可变对象与初始化安全性</b></span></div><div><span style="font-size: 16px;"> 主要还是构造方法内的代码和构造方法后的代码的重排序问题</span></div><div><span style="font-size: 16px;"> 不可变对象任何时候都是线程安全的（发布时和使用时）</span></div><div><span style="font-size: 16px;"> 不可变对象可以确保初始化安全性，其实volatile也可以！</span></div><div><span style="font-size: 16px;">  <span style="font-weight: bold; color: rgb(227, 0, 0); font-size: 12pt;">注意：</span></span><span style="color: rgb(227, 0, 0); font-size: 12pt; font-weight: bold;">重排序问题，构造方法和引用赋值不满足先行发生原则，因此可能发生构造方法还未结束，但引用已经被获取到的情况，可以使用volatile和final变量来禁止重排序</span></div><div><span style="font-size: 16px;"><b>安全发布的常用模式</b></span></div><div><font style="font-size: 12pt;">对于可变对象，可以使用以下方法来正确发布</font>：</div><div><br/></div><div><span style="font-size: 16px;"><b>事实不可变对象</b></span></div><div><span style="font-size: 16px;">事实不可变对象只要保证初始化安全（发布时），后面的使用就是安全的</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;"><b>可变对象</b></span></div><div><span style="font-size: 16px;">可变对象不只在对象发布时需要保证安全，使用时也需要保证安全</span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 16px;"><b>安全地共享对象</b></span></div><div><span style="font-size: 16px;">对象使用时的安全策略：</span></div><div><br/></div></span>
</div></body></html> 