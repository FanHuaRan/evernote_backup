<html>
<head>
  <title>第二章 java内存区域与内存溢出异常</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="473"/>
<h1>第二章 java内存区域与内存溢出异常</h1>

<div>
<span><div><span style="font-size: 24pt; color: rgb(26, 144, 185); font-weight: bold;">一.运行时数据区域</span></div><div><br/></div><div><span style="font-weight: bold;"><img src="第二章 java内存区域与内存溢出异常_files/Image.png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-size: 12pt; font-weight: bold;">1.程序计数器</span></div><div>   程序计数器是一块较小的的内存空间，可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅仅是概念模型），字节码解释器工作时就是通过改变这个计数器的值来取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖程序计数器。</div><div>  每个线程都有一个程序计数器，如果线程执行的是一个java方法，这个计数器记录的就是当前正在执行的虚拟机字节码指令的地址；如果执行的是native方法，这个计数器值则为空。该内存区域是唯一一个在java虚拟机规范当中没有规定任何OutOfMemoryError情况的区域。</div><div> 补充：并不是native方法就没有程序计数器，这儿所讲的程序计数器是jvm之上的程序区域，实际上操作系统线程还带有自己的程序计数器！！两个属于不同的层面。</div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">2.虚拟机栈</span></div><div>  虚拟机栈也是线程私有的，生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模型。</div><div>  每个方法在执行的同时都会创建一个栈帧（每个栈帧都是虚拟机栈的一个元素）用于存放局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。</div><div>  局部变量表包括了基本数据类型、对象引用和返回地址，局部变量表在编译期间完成完成分配，当进入一个方法时，这个方法需要在栈中分配多大的局部变量表空间是完全确定。</div><div>  在jvm虚拟机规范中，这个区域规定了两种异常状况：</div><div>  1.如果请求的栈深度大于虚拟机所准许的深度，抛出StackOverflowError这个往往是由于调用方法的深度太深造成，无限递归！</div><div>  2.如果虚拟机栈可以动态扩展（大部分虚拟机都可以，不过虚拟机规范中也准许固定长度的虚拟机栈-xss参数），如果栈在扩展时无法申请到内存，就会抛出OutOfMemoryError.</div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">3.本地方法栈</span></div><div>  本地方法栈与虚拟机栈的所用类似，只不过虚拟机栈是是为虚拟机执行java方法（字节码）服务，而本地方法栈则为虚拟机是用到的Native方法服务。</div><div>  虚拟机规范中没有对本地方法栈使用的语言、使用方式与数据结构有规定，有些虚拟机（hotspot）直接就把本地方法栈和虚拟机栈合二为一。</div><div>  本地方法栈也会抛出StackOverflowError和OutMemoryError.</div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">4.java堆</span></div><div><span style="font-size: 10pt;">  </span> <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">Java堆是被所有</span><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">线程共享</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">的一块内存区域，在虚拟机启动时创建，是虚拟机所管理的内存中最大的一块。此内存区域的唯一目的就是</span><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">【存放对象实例和数组】</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">，几乎所有的对象实例和数组都在这里分配内存。</span></div><div><font style="font-size: 10pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">   在java虚拟机规范当中描述的是：所有的对象实例以及数组都要在堆中分配。 但是随着JIT编译器和逃逸分析技术的逐渐成熟，栈上分配、标量分配等优化技术可能让对象并不一定在堆上分配。</span></font></div><div><font style="font-size: 10pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">   <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">Java堆是垃圾收集器管理的主要区域，也称为GC</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal; text-decoration: line-through;">垃圾</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">堆，</span></span></font></div><div><font style="font-size: 10pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">         从内存回收的角度看，由于现在的收集器基本都采用分代收集算法，所以java堆还可以细分为新生代和老年代；新生代再细致一点还有Eden空间，From Survivor空间、To Survivor空间等区域。</span></span></font></div><div><font style="font-size: 10pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">         从内存分配的角度看，线程共享的堆还可能划分出多个线程私有的分配缓冲区（TLAB）。</span></span></font></div><div><font style="font-size: 10pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">         无论如何划分，都与存放内容无关。无论哪个区域存储的都是对象实例，进一步划分的目的是为了更好的回收内存或者更快的分配内存。</span></span></font></div><div><span style="font-size: 10pt;">   </span><span style="font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun;">java堆可以处于物理上的连续或者不连续的内存空间当中，只要逻辑连续。实现可以固定大小，也可以扩展。主流虚拟机都是按照可扩展来实现的（-Xmx,-Xms）</span></div><div><span style="font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun;">   如果在堆中没有内存完成实例分配，并且堆也无法扩展时，就会抛出OOM.</span></div><div><span style="font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun;">   补充：字符串常量也是对象，不过字符串常量在方法区中，所以字符串常量对象不一定在堆当中。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">5.方法区</span></div><div>   方法区也是一块线程共享的区域，用于存储被虚拟机加载的类信息，常量(字面量和符号引用)，静态变量（静态变量是指基本数据类型，对象引用，所以静态变量指向的对象一般还是在堆上）、及时编译器编译后的代码、字符串常量池（字面量的载体）等数据。</div><div>   方法区是一个概念空间，虽然java虚拟机规范把方法区描述为堆的一个逻辑部分（ <img src="file:///C:/Users/HUARAN~1/AppData/Local/Temp/SGPicFaceTpBq/1312/0558EBE8.png"></img>搞笑的是还有一个名字“非堆”），但是事实上各个版本的虚拟机对其的实现是不同的：</div><div>          Hotspot虚拟机在java8之前是将堆中的一部分用来实现方法区，这个被称为永久代（可通过-XX:MaxPermSize来控制上限），hotspot在java7中已经把字符串常量池从永久代中移出到本地内存当中，在java8中直接取消了永久代，将方法区整个使用本地内存使用，这个被称为元空间。</div><div>          j9和JRockit根本就没有永久代的说法，方法区一直是用本地内存实现。</div><div>  基于堆中的永久代来实现方法区的实现比较简单，基本和堆中其它部分的设计差不多，垃圾回收也是直接使用已有算法，但很容易导致内存溢出。</div><div>  基于本地内存实现的方法区实现很复杂，需要单独的垃圾回收，不过不容易导致内存溢出，但是进程和操作系统的内存也是有极限的，还是可能会造成内存溢出。</div><div>  java虚拟机规范对方法区的描述中还说明方法区可以不实现垃圾收集，因为方法区的很多数据是不会被回收的 ，该区域的内存回收主要是对常量池的回收和类型的卸载，很多时候回收不到什么东西，但是这部分的垃圾回收是必要的！</div><div>  java虚拟机规范规定，当方法区无法满足内存分配需求时，将抛出OOM</div><div>        hotspot在java8之前通过设置永久代容量来控制方法区大小，java之后的元空间默认没有限制，容量极限就是进程内存极限。不过可以通过-XX:MetaspaceSize=N和-XX:MaxMetaspaceSize来控制！</div><div><span style="font-size: 12pt; font-weight: bold;">6.运行时常量池</span></div><div>      运行时常量池属于方法区的一部分！</div><div>      Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(Constant Pool Table)，用于存放编译期生成的字面量和符号引用，这部分内容（也可以称为 .Class文件中的静态常量池）将在类加载后进入方法区的运行时常量池中存放。当常量池无法再申请到内存时也会抛出OutofMemoryError异常。</div><div>      常量池主要是编译时产生的字面量和符号运用，当他们在class文件中存储时被称为静态常量池，当class被加载，字面量和符号引用便进入运行时常量池。</div><div>      很多字面量会被拿来当成字符串用，这种运行时常量池又称为字符串常量池，字符串可以通过String.intern()方法动态的进入字符串常量池， String.intern()是一个本地方法(java7之后，intern方法不会把字符串的对象放进方法区，只会在方法区当中放一个指向对象的引用)。</div><div>      当常量池无法再申请内存时也会抛出OOM。</div><div>      <span style="font-weight: bold;">补充</span>：</div><div>  <span style="color: rgb(188, 0, 88);">   1.java当中还存在一种被称为常量池技术的东西存在： </span></div><div><span style="color: rgb(188, 0, 88);">       Byte,Short,Integer,Long,Character默认创建了[-128，127]的相应类型的缓存数据。当通过字面量或者ValueOf方法得到的上述封装类型如果满足上面的范围条件，就会使用常量池中存储的对象。这个不是JVM来做的，是API。</span></div><div><span style="color: rgb(188, 0, 88);">        看看Integer.ValueOf方法的实现：</span></div><div><span style="color: rgb(188, 0, 88);">       public static Integer valueOf(int i) {</span></div><div><span style="color: rgb(188, 0, 88);">            if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span></div><div><span style="color: rgb(188, 0, 88);">                return IntegerCache.cache[i + (-IntegerCache.low)];</span></div><div><span style="color: rgb(188, 0, 88);">            return new Integer(i);</span></div><div><span style="color: rgb(188, 0, 88);">        }</span></div><div><span style="color: rgb(188, 0, 88);">      private static class IntegerCache {</span></div><div><span style="color: rgb(188, 0, 88);">            static final int low = -128;</span></div><div><span style="color: rgb(188, 0, 88);">            static final int high;</span></div><div><span style="color: rgb(188, 0, 88);">            static final Integer cache[];</span></div><div><span style="color: rgb(188, 0, 88);">      ....}</span></div><div><span style="color: rgb(188, 0, 88);">     但它们和运行时常量池不是一个概念。只是池化技术的一种API层面的实现，不属于JVM内存区域应该讨论的范畴。</span></div><div><span style="color: rgb(188, 0, 88);">     2.运行时常量池不只有一个，而是每个类一个，和他们的class对象一起放在方法区当中，不同类中的运行时常量池的结构都是一样的，只不过存放的东西是各个类中特有的字面量和符号引用。</span></div><div>    <span style="color: rgb(255, 0, 0);"> 3.字符串常量池自java7开始就不再将字符串对象存放在方法区中，将对象放在堆，方法区放引用来指向堆中的对象</span></div><div><span style="font-size: 12pt; font-weight: bold;">7.直接内存</span></div><div>   直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分区域也很常用，而且也可能导致OOM。</div><div>   在JDK1.4中新加入了NIO包，引入了一种基于通道与缓冲区的I/O方式。它可以使用Native函数库直接分配堆外内存，然后通过一个存储在堆中的DirectByteBuffer对象作为这块内存的引用来对这块内存进行操作。这样能在很多场景中显著提高性能，因为避免了在java堆和native内存中来回复制数据。</div><div>  直接内存的分配不会受到java堆大小的限制，但是还是会受到本机内存、内存寻址、操作系统的限制，且有参数控制，所以并不是无限的。直接内存的分配都是调用Unsafe类中的allocat方法来分配的内存（底层是c的malloc方法）。</div><div>  直接内存的垃圾回收工作很复杂，目前jdk中能够直接操作直接内存的方法主要是ByteBuffer.allocateDirect方法和Unsafe.allocateMemory方法，前者可以直接使用，且是依靠后者来进行内存分配，后者不可以在java程序中使用，也不推荐使用，因为需要手动垃圾回收，不安全。</div><div>  服务器管理员在对JVM调优时往往会忘记考虑直接内存，切记。</div><div>  DirectMemory容量可以通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与java堆最大值（-Xmx指定）一样。</div><div>  参考：<a href="http://www.importnew.com/26334.html">http://www.importnew.com/26334.html</a></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">8.内存溢出和内存泄漏</span></div><div><font style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(127, 184, 14); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun;">内存泄露</span><span style="font-size: 11pt; color: rgb(79, 79, 79); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun;"> </span><span style="font-size: 11pt; color: rgb(79, 79, 79); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun;">： 指程序中动态分配内存给一些临时对象，但是对象不会被GC所回收，它始终占用内存。即</span><span style="background-color: rgb(255, 255, 255); font-size: 11pt; color: rgb(245, 130, 32); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun;">被分配的对象可达但已无用，可用内存越来越少</span><span style="background-color: rgb(255, 255, 255); font-size: 11pt; color: rgb(79, 79, 79); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun;">。</span><span style="background-color: rgb(255, 255, 255); font-size: 11pt; color: rgb(79, 79, 79); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun;"> </span></font></div><div><font style="font-size: 11pt;"><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); font-size: 11pt; color: rgb(127, 184, 14); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">内存溢出</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); font-size: 11pt; color: rgb(79, 79, 79); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(79, 79, 79); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">： 指程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于老年代或永久代垃圾回收后，仍然无内存空间容纳新的Java对象的情况。</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(79, 79, 79); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;"> </span></font></div><div><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 11pt; color: rgb(245, 130, 32); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">内存泄露是内存溢出的一种诱因，不是唯一因素。</span></span></div><div><br/></div><div><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 16px; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">9.JVM运行时数据区和直接内存的思考</span></span></div><div><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;"> </span> <span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 11pt; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">JVM运行时数据区区可以理解为是基于JVM所分配和管理的内存，是可以被java相关参数调节的。这部分的内存并不是无中生有的，还是基于了直接内存。只能说是JVM去申请了直接内存，然后用这些内存来实现所谓的JVM运行时数据区。直接内存就是程序直接拿到的物理内存，这部分的内存和C拿到的内存一样，因为不受JVM控制，所以使用和调节要小心。（虽然JVM也提供了一些释放的方法）。</span></span></div><div><br/></div><div><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 16px; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">10.java程序的内存占用就是堆得内存占用吗？</span></span></div><div><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 16px; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">很多人错误的认为运行Java程序时使用-Xmx和-Xms参数指定的就是程序将会占用的内存，但是这实际上只是Java堆对象将会占用的内存。堆只是影响Java程序占用内存数量的一个因素。要更好的理解你的Java程序将会占用多大的内存需要先了解有哪些因素会影响到内存的占用。这些因素包括：</span></span></span></div><div style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><ul style="box-sizing: border-box; margin: 0px; padding: 0px 0px 0px 40px; list-style: disc;"><li style="box-sizing: border-box;"><span style="font-size: 10pt; font-family: &quot;PingFang SC&quot;; font-variant-caps: normal; font-variant-ligatures: normal;">对象(Objects)</span></li><li style="box-sizing: border-box;"><span style="font-size: 10pt; font-family: &quot;PingFang SC&quot;; font-variant-caps: normal; font-variant-ligatures: normal;">类(Classes)</span></li><li style="box-sizing: border-box;"><span style="font-size: 10pt; font-family: &quot;PingFang SC&quot;; font-variant-caps: normal; font-variant-ligatures: normal;">线程(Theads)</span></li><li style="box-sizing: border-box;"><span style="font-size: 10pt; font-family: &quot;PingFang SC&quot;; font-variant-caps: normal; font-variant-ligatures: normal;">本地数据结构(Native data structures)</span></li><li style="box-sizing: border-box;"><span style="font-size: 10pt; font-family: &quot;PingFang SC&quot;; font-variant-caps: normal; font-variant-ligatures: normal;">本地代码(Native code)</span></li></ul></div><div style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">每个因素对内存占用的影响又会随着应用程序、运行环境和系统平台的不同而变化，那怎样计算总的内存占用量？是的，想得到一个准确的数字不是那么容易，因为你很难控制本地(Native)部分。你能控制的部分只有堆大小：-Xmx，类占用的内存：-XX:MaxPermSize，还有线程栈：-Xss控制每个线程占用的内存。所以，计算公式为：</span></span></div><div style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">(-Xmx) + (-XX:MaxPermSize) + 线程数 * (-Xss) + 其它内存</span></span></div><div style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">其它内存部分取决于本地代码占用的内存，如NIO、socket缓冲区等。它一般大约是jvm内存的5%左右。所以假设我们有下面的JVM参数和100个线程：</span></span></div><div style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">-Xmx1024m -XX:MaxPermSize=256m -Xss512k </span></span></div><div style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">那么jvm进程至少会占用内存数量为：1024m + 256m + 100*512k + (0.05 * 1330m) = 1396.5m</span></span></div><div><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, Sathu, EucrosiaUPC, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">我一般使用(1.5 * 堆最大值)来作为一个近似值表示一个tomcat进程会需要的最小内存，如果你有需要增加MaxPermSize到256M以上的应用这个值可以更大些。如果你使用这个来衡量你的系统将会占用多少内存要记住你需要为系统和其它运行在系统上的程序留下足够的内存，否则会导致系统使用过多的虚拟内存，这样会降低性能。</span></span></div><div><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 10pt; font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">参考： </span><a href="http://www.oschina.net/question/100267_65544" style="font-size: 10pt; color: rgb(0, 0, 0); font-family: &quot;PingFang SC&quot;; font-variant-caps: normal; font-variant-ligatures: normal;">http://www.oschina.net/question/100267_65544</a></span></div><div><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(245, 130, 32); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, SimHei, Arial, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;"> </span></div><div><font color="#1A90B9" style="font-size: 24pt;"><span style="font-size: 24pt; color: rgb(26, 144, 185); font-weight: bold;">二.hotspot虚拟机对象探秘</span></font></div><div><br/></div><div>对象的创建、布局和访问在jvm虚拟机规范当中并没有定义，基于实用优先的原则，这儿讨论HotSpot虚拟机和它的内存区域堆中的对象。</div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1.对象的创建</span></font></div><div>   这儿以new指令来讨论对象的创建过程:</div><div>    （1）虚拟机遇到一条new指令，首先去检查这个指令的参数是否能在常量池中定位一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有加载，那必须先执行相应的类的类加载过程。</div><div>    （2）在类加载检查通过后，接下来虚拟机为新生对象分配内存。对象所需的内存大小在类加载完成后便可以确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</div><div>             存在两种分配情况：</div><div>             [1]如果java堆中的内存是绝对规整的（一块连续的内存空间，可以认为是数组），所有用过的内存放一边，没用过的内存放一边，用一个指针指向空闲内存的起始地址，内存分配就只需要把指针向空闲空间那边移动一段与对象大小相等的距离，这种被称为“指针碰撞”。</div><div>            [2]如果java堆中的内存并不规整，已使用的内存和空闲内存交错，虚拟机就必须维护一个队列，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象，并更新列表上的记录，这种被称为“空闲列表”。</div><div>            选择哪种分配方式由java堆是否规整决定，而java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定，因此在使用Serial、ParNew等Compact过程的收集器时（实际上可以认为是使用复制算法和标记压缩算法的收集器），系统采用的分配算法是指针碰撞，而使用CMS这种基于标记清理算法的收集器时通常采用空闲列表。因为堆中的老年代和新生代可以使用不同的收集器，因此java堆可以同时存在不同的对象内存分配方式。</div><div>            除了如何划分空间，还有一个问题就是对象创建在虚拟机中是非常频繁的行为，并发性很高，因此会遇到很多的线程问题。比如在只用指针碰撞时，当一个对象正在 分配内存，但是还没有来得及修改空闲内存指针，另外一个对象也在使用该指针分配内存就会出现问题。</div><div>           解决这种问题有三种方案：</div><div>                  一种是对分配内存空间的动作进行同步处理</div><div>                  采用CAS+失败重试（实际上是采用的这种方式）</div><div>                 最后一种是把内存分配的动作划分在不同的空间之中进行，每个线程都预先在java堆中分配一小块内存，称为本地线程分配缓存（TLAB）。哪个线程需要分配缓存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时才需要同步锁定。虚拟机是否采用TLAB，可以通过-XX:+/-UseTLAB参数来设定。这儿实际上是一种用提前分配的内存策略，TLAB并不是线程私有的，只是在分配的时候是私有的，访问还是线程共享的。</div><div>    （3）内存分配完成后，虚拟机将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一步也可以提前到TLAB分配时完成，这一步操作保证了对象的实例字段可以不赋初始值就可以使用，程序能访问到这些字段的数据类型所对应的零值（默认值）</div><div>    （4）接下来，虚拟机对对象进行必要的设置，比如这个类是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄。这些信息存放在对象头（Object Header）当中，根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象会有不同的设置方式。</div><div>    （5）上面的工作完成后，从虚拟机的角度看，一个新的对象已经产生，但从java程序的角度看，对象创建才刚刚开始——&lt;init&gt;方法还没有执行，所有的字段都还为零。所以一般来说执行完new指令后会接着执行&lt;init&gt;方法，把对象按照程序员的意图初始化。init方法包括给字段赋初始值、代码块、构造方法。顺序是前两者先。</div><div><br/></div><div>   补充：</div><div>       1.作者对克隆和反序列化的理解中使用到new指令并不是指调用构造方法，这两种情况不会经过构造方法。</div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">2.对象的内存布局</span></font></div><div>   对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</div><div><span style="font-weight: bold;">   对象头</span></div><div>   对象头又包括两部分信息：</div><div>          第一部分是存储对象自身的运行时数据，如哈希码、GC分代年龄、锁标志状态、线程持有的锁、偏向线程ID、偏向时间戳。这部分数据在32位和64位的虚拟机中（未开启压缩指针）中分别为32位和64位，官方称之为Mark Word。对象需要存储的运行时数据很多，实际上已经超出了记录限度，但是对象头信息是与对象自身数据无关的，虚拟机为了提升效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间存储更多的信息，它会根据对象状态复用自己的存储空间。见下图：</div><div>        <img src="第二章 java内存区域与内存溢出异常_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>         这儿的标志位就是指锁标志位，在各种锁定的情况下，Mark Word是不同的。</div><div>       对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上报留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身（句柄）。</div><div>       如果一个对象是数组，那么对象头中还有一块用于记录数组长度的指针（4个字节，所以java数组指针的大小只能用int指定）。</div><div><br/></div><div>   <span style="font-weight: bold;">实例数据</span></div><div>            <img src="第二章 java内存区域与内存溢出异常_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>   <span style="font-weight: bold;">对齐填充</span></div><div>      </div><div>         对象填充并不是必然的存在，也没有特别的含义，仅仅只是占位符，满足虚拟机内存管理系统对对象起始地址的标准化要求。</div><div><br/></div><div>   <img src="第二章 java内存区域与内存溢出异常_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">3.对象的访问定位</span></div><div>   java程序需要使用Reference来操作堆上的对象。由于reference类型在java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用通过何种方式去定位和访问堆中的内容，目前主流的方式主要是使用句柄和直接指针两种</div><div>       如果使用句柄访问，那么java堆中将会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，而对象句柄中包括了对象的实例数据和类型数据的各自的地址信息。</div><div>             <img src="第二章 java内存区域与内存溢出异常_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>       如果使用直接指针访问，那么对象头中就必须放置指向类型的指针（看上面）</div><div>           <img src="第二章 java内存区域与内存溢出异常_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>       两种访问方式各有优势：</div><div>       <img src="第二章 java内存区域与内存溢出异常_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><br/></div><div><font style="font-size: 24pt;"><span style="font-size: 24pt; color: rgb(26, 144, 185); font-weight: bold;">三.OutOfMemoryError异常</span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1.java堆溢出</span></font></div><div><span style="font-size: 12pt; font-weight: bold;">   </span><span style="font-size: 11pt; font-weight: bold;">调节和防止堆内存溢出的关键参数和手段是：</span></div><div><font style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">   <span style="min-height: 16pt; background: rgb(232, 242, 254); font-size: 11pt; font-weight: bold; color: rgb(127, 127, 159); font-family: Consolas;">-</span><span style="min-height: 16pt; background: rgb(232, 242, 254); font-size: 11pt; font-weight: bold; color: rgb(63, 95, 191); font-family: Consolas;">Xms20M：-Xms参数调节堆的初始大小，这儿设置20M</span></span></font></div><div><span style="min-height: 16pt; background: rgb(232, 242, 254); font-size: 11pt; color: rgb(127, 127, 159); font-family: Consolas; font-weight: bold;">  -</span><span style="background: rgb(232, 242, 254); min-height: 16pt; font-size: 11pt; color: rgb(63, 95, 191); font-family: Consolas; font-weight: bold;">Xmx20M：</span><span style="min-height: 16pt; background: rgb(232, 242, 254); font-size: 11pt; color: rgb(63, 95, 191); font-family: Consolas; font-weight: bold;">-Xmx参数调节堆的最大大小，这儿设置20M</span></div><div><font style="font-size: 11pt;"><span style="min-height: 16pt; background: rgb(232, 242, 254); font-size: 11pt; color: rgb(127, 127, 159); font-family: Consolas; font-weight: bold;">  -</span><span style="min-height: 16pt; background: rgb(232, 242, 254); font-size: 11pt; color: rgb(63, 95, 191); font-family: Consolas; font-weight: bold;">XX:+HeapDumpOnOutOfMemoryError：该参数为当发生内存溢出时，对堆内存区域dump出内存快照，以便日后分析</span></font></div><div><font style="font-size: 11pt;"><span style="min-height: 16pt; background: rgb(232, 242, 254); font-size: 11pt; color: rgb(63, 95, 191); font-family: Consolas; font-weight: bold;">  Eclipse Memory Analyzer:可以对上面对堆内存的快照进行分析</span></font></div><div><font style="font-size: 11pt;"><span style="min-height: 16pt; background: rgb(232, 242, 254); font-size: 11pt; color: rgb(63, 95, 191); font-family: Consolas; font-weight: bold;"> 实际使用时：首先使用分析工具检查堆内存快照，根据引用关系等检查是否有内存泄漏，如果无内存泄漏，就需要根据本机内存，适当修改堆大小，如果还是有溢出现象，需要修改程序代码，优化对象的使用时间等</span></font></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">2.虚拟机栈和本地方法栈溢出</span></font></div><div>  <span style="font-size: 11pt;"> 控制虚拟机栈大小的参数是-Xss，控制本地方法栈大小的参数-Xoss</span></div><div><span style="font-size: 11pt;">   由于hotspot的虚拟机栈和本地方法栈是一体的，因此-Xoss参数没有作用。</span></div><div><span style="font-size: 11pt;">   在java虚拟机规范中描述了两种异常情况：</span></div><div><span style="font-size: 11pt;">   1.如果线程请求的栈深度大于虚拟机所准许的最大深度，将抛出StackOverflowError</span></div><div><span style="font-size: 11pt;">   2.如果虚拟机在扩展栈时无法申请到足够的内存空间，将抛出OutOfMemoryError.</span></div><div><span style="font-size: 11pt;">  我认为虚拟机规范这样描述的目的是将递归造成的栈过于深的异常归为StackOverflowError，将栈申请内存无法满足的异常归为OOM。但是这两个存在很大的重叠，因为无法分配栈空间到底是剩余的内存太小，还是已申请的栈太深？本质上只是同一件事情的两种描述。</span></div><div><span style="font-size: 11pt;">  在单线程环境下，以无限递归来让栈溢出的两种情况：</span></div><div><span style="font-size: 11pt;">  1.使用-Xss参数减少栈的内存容量。结果：抛出SOE，异常出现时输出的堆栈深度随着-Xss参数的减少而减小。</span></div><div><span style="font-size: 11pt;">  2.定义了大量的本地变量，增大此方法栈中本地变量表的长度，结果：抛出SOE，异常时输出的堆栈深度随着本地变量的增大而减小。</span></div><div><span style="font-size: 11pt;">  实验结果表明：单线程环境下，无论是栈帧过大，还是虚拟机栈容量过小，当内存无法分配时都是抛出SOE。</span></div><div><span style="font-size: 11pt;">  几个数据：在我的i7,8G内存机器上，无限递归时，不设置-Xss的栈最大深度是3W-4W，设置-Xss128k时为100左右</span></div><div><span style="font-size: 11pt;">  通过多线程，不断建立新线程并且运行可以产生栈上的OOM，一般来说操作系统分配给每个进程的内存是有限制的，比如32位的windows限制为2GB。虚拟机提供了参数来控制java堆、方法区（java8不行）和直接内存的最大值，计数器的消耗可以忽略，假设  忽略虚拟机本身耗费的内存，那进程内存上限-堆最大值-方法区最大值-直接内存最大值就近似等于虚拟机栈和本地方法栈的值，所以还是有限的。每个线程分配的栈容量越大，可以建立的线程数自然就少，建立线程时就越容易耗尽内存。</span></div><div><span style="font-size: 11pt;">  一般情况下使用虚拟机的默认参数，栈深度达到两三千是没问题的，如果是线程过多而导致内存溢出，可以减少线程数、更换64位虚拟机（这个可能同时需要增加物理内存大小），减少最大堆容量和减少栈大小来换取更多的线程。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">3.方法区和运行时常量池溢出</span></div><div>   <span style="font-size: 11pt;">运行时常量池属于方法区。 </span></div><div><span style="font-size: 11pt;">   java7之前，只要一直往字符串常量池噻东西就能导致PermGen Space的OOM。</span></div><div><span style="font-size: 11pt;">   java7之后，往字符串常量池塞东西很难导致OOM。</span></div><div><span style="font-size: 11pt;">   java8之前可以使用-XX:PermSize -XX:MaxPermSize来限制永久代的大小，但是java8因为永久代已经不存在，方法区就在直接内存当中，而且没有提供参数来调节这个大小（可以估计）  </span></div><div><span style="font-size: 11pt;">   java7之后想要方法区溢出只能不停加载类。</span></div><div><span style="font-size: 11pt;">   方法区溢出是一种常见的内存溢出现象，一个类要被垃圾收集器收集，判定条件很苛刻。在经常动态生成大量class的应用中，需要注意类的回收状况。这类常见除了CGLIB外，还有充斥大量jsp或者动态产生jsp文件的应用（jsp会被编译为class,servlet），基于OSGI的应用。</span></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">4.本机直接内存溢出</span></div><div>    <span style="font-size: 11pt;">DirectMemory容量可以通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与java堆最大值（-Xmx指定）一样。</span></div><div><span style="font-size: 11pt;">    可以使用Unsafe.allocateMemory(Size)来分配直接内存</span></div><div><span style="font-size: 11pt;">    直接内存在溢出时，不会进入dump</span></div><div><span style="font-size: 11pt;">    如果程序发生了溢出，dump出的文件又偏小，程序又使用了NIO，那很可能问题就出现在直接内存上。</span></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 