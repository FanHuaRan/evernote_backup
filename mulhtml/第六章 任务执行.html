<html>
<head>
  <title>第六章 任务执行</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1291"/>
<h1>第六章 任务执行</h1>

<div>
<span><div><font style="font-size: 12pt;"><span style="color: rgb(26, 144, 185); font-weight: bold;">一.在线程中执行任务</span></font></div><div><span style="font-size: 16px;">任务执行的两个关键</span></div><div><ul><li><font style="font-size: 12pt;">清晰的任务边界</font><br/></li><li><font style="font-size: 12pt;">明确的任务执行策略</font></li></ul></div><div><font style="font-size: 12pt;"><b>1.串行地执行任务</b></font></div><div><font style="font-size: 12pt;">   在服务器应用程序中，穿行处理机制通常都无法提供高吞吐率和快速响应性（除非任务数量很少；只为单用户提供服务）</font></div><div><font style="font-size: 12pt;">   但是串行处理方式能够带来简单些或安全性，因此在客户端很实用，大多数GUI框架都通过单一的线程来串行的处理任务。</font></div><div><font style="font-size: 12pt;"><b>2.显示的为任务创建线程</b></font></div><div><font style="font-size: 12pt;">   在正常负载的情况下，“ 为每个任务”分配一个线程的方法能提升串行执行的性能。只要请求速率不超出服务器的请求处理能力，那么这种方法就可以同时带来更快的响应性和更高的吞吐率。</font></div><div><font style="font-size: 12pt;"><b>3.无限制创建线程的不足</b></font></div><div><font style="font-size: 12pt;">  缺点如下：</font></div><div><font style="font-size: 12pt;">  （1）线程生命周期的开销非常高。（创建和销毁开销）</font></div><div><font style="font-size: 12pt;">  （2）资源消耗（内存、cpu、上下文切换）</font></div><div><font style="font-size: 12pt;">  （3）稳定性（jvm和操作系统平台对可创建线程数量有限制,当然对于那些使用用户线程的语言，则没有限制）</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"> 服务器应用绝对不要直接创建和使用线程！</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-weight: bold; color: rgb(26, 144, 185);"><font style="font-size: 12pt;">二.Executor框架</font></span></div><div><font style="font-size: 12pt;">串行执行的问题在于其槽糕的响应性和吞吐量，而为每个任务分配一个问题在于资源管理的复杂性。</font></div><div><font style="font-size: 12pt;">在java类库当中，任务执行的主要抽象不是Thread,而是Executor.</font></div><div><font style="font-size: 12pt;">Executor基于生产者-消费者模式，提交任务的操作相当于生产者（生成待完成的工作单元），执行任务的线程相当于消费者（执行完这些工作单元）。如果要在应用程序中实现一个生产者-消费者的设计，那最简单的方式就是通过Executor.</font></div><div><font style="font-size: 12pt;"><b>1.示例 基于Executor的web服务器</b></font></div><div><font style="font-size: 12pt;">  Exector框架解耦了三个东西：任务-任务提交-任务执行策略</font></div><div><font style="font-size: 12pt;"><b>2.执行策略</b></font></div><div><font style="font-size: 12pt;"><img src="第六章 任务执行_files/Image.png" type="image/png" data-filename="Image.png"/></font></div><div><font style="font-size: 12pt;"><b>3.线程池</b></font></div><div><font style="font-size: 12pt;">线程池是指管理一组同构工作线程的资源池。线程池是与工作队列密切相关的，其中在工作队列中保存了所有等待执行的任务，工作者线程从工作队列中获取任务，执行任务，然后返回线程池并等待下一个任务。</font></div><div><font style="font-size: 12pt;">客户端线程是生产者，工作者线程是消费者，工作队列是纽带。</font></div><div><font style="font-size: 12pt;">在线程池中执行任务和一个任务一个线程相比的优势：</font></div><div><font style="font-size: 12pt;">（1）通过重用现有的线程，而不是创建新的线程，可以处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销。</font></div><div><font style="font-size: 12pt;">（2）当任务请求到达时，工作者线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。</font></div><div><font style="font-size: 12pt;">（3）适当的调节线程池的大小，可以创建出足够多的线程以便使处理器保持忙碌状态，同时还可以防止多线程相互竞争资源而使应用程序耗尽资源或失败。</font></div><div><font style="font-size: 12pt;"><span style="color: rgb(227, 0, 0);">推荐直接使用</span><span style="color: rgb(227, 0, 0);">ThreadPoolExecutor来使用线程池。</span></font></div><div><font style="font-size: 12pt;"><img src="第六章 任务执行_files/Image [1].png" type="image/png" data-filename="Image.png"/></font></div><div><font style="font-size: 12pt;">注意：单线程Executor提供了大量的内部同步机制，从而确保了任务执行的内存写入操作的可见性。</font></div><div><font style="font-size: 12pt;"><b>4.Executor的生命周期</b></font></div><div><span style="font-size: 16px;">为了解决执行服务的生命周期的问题，ExecutorService扩展了Executor接口，添加了一些用于生命周期管理的方法（同时还有一些用于任务提交的便利方法）。</span></div><div><img src="第六章 任务执行_files/Image [2].png" type="image/png" data-filename="Image.png" style="font-size: 12pt;"/></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">ExecutorService的生命周期有三种状态：运行、关闭和已终止。</font></div><div><span style="font-size: 16px;">任务处于三种状态：未提交、在任务队列中等待执行、正在运行和已完成。更官方的说法是创建、提交、开始、完成。</span></div><div><img src="第六章 任务执行_files/Image [3].png" type="image/png" data-filename="Image.png" style="font-size: 12pt;"/></div><div><img src="第六章 任务执行_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><font style="font-size: 12pt;">这儿翻译有问题，应该是先shutdown，然后awaitTermination</font></div><div><font style="font-size: 12pt;"><b>5.延迟任务与周期任务</b></font></div><div><font style="font-size: 12pt;">Timer的缺陷：</font></div><div><ul><li><font style="font-size: 12pt;">Timer基于绝对时间，而不是相对时间</font></li><li><font style="font-size: 12pt;">Timer是单线程模型，因此可能存在丢失任务或者连续执行任务的情况</font></li><li><font style="font-size: 12pt;">Timer内部的逻辑一旦抛出异常，将彻底终止线程，新的任务也不会被调度</font></li></ul><font style="font-size: 12pt;">在java1.5之后应该考虑使用<span style="font-size: 12pt;">ScheduledExecutorService替代Timer.</span><br/><img src="第六章 任务执行_files/Image [5].png" type="image/png" data-filename="Image.png"/></font><br/></div><div><font style="font-size: 12pt;"><br/></font></div><div><b><font color="#1A90B9" style="font-size: 18pt;">三.找出可利用的并行性</font></b></div><div><span style="font-size: 16px;">核心和难点在于找出任务边界！只有当大量相互独立且同构的任务可以并发处理时，才能体现出将程序的工作负载分配到多个任务中带来的真正性能提升。</span></div><div><img src="第六章 任务执行_files/Image [6].png" type="image/png" data-filename="Image.png" style="font-size: 12pt;"/></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><img src="第六章 任务执行_files/Image [7].png" type="image/png" data-filename="Image.png" style="font-size: 12pt;"/></div><div><span style="font-size: 16px;">Future超时控制</span></div><div><span style="font-size: 16px;">ExecutorService.invokeAll&amp;invokeAny方法</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  </font></div></span>
</div></body></html> 