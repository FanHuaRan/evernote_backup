<html>
<head>
  <title>InnoDB原理之事务实现机制</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1649"/>
<h1>InnoDB原理之事务实现机制</h1>

<div>
<span><div><span style="font-size: 16px;">关于InnoDB的事务实现机制，其实本人现在也还没总结好，暂且为了应对面试，总结如下几点：</span></div><div><font style="font-size: 18pt;"><span style="font-size: 18pt; color: rgb(20, 113, 145); font-weight: bold;">事务的四个特性</span></font></div><div><span style="font-size: 12pt;">原子性：要么成功，要么失败，不会存在执行一半的情况。</span></div><div><span style="font-size: 12pt;">一致性：事务只能够让数据库从一种一致的状态到另外一种一致的状态（其实我认为这只是说物理数据的一致性，只是说保证数据不会发生物理性的损坏，说并发安全也可以，但是和隔离性有冲突）</span></div><div><span style="font-size: 12pt;">隔离性：多个事务并发执行下的安全问题，事务之间需要有合适的隔离机制。</span></div><div><span style="font-size: 12pt;">持久性：事务一旦提交成功，哪怕数据库奔溃，断电，事务的改动都应该持久化下来（实例重启时恢复）</span></div><div><font color="#147191" style="font-size: 18pt;"><span style="font-size: 18pt; color: rgb(20, 113, 145); font-weight: bold;">关于InnoDB的四个事务隔离等级</span></font></div><div><span style="font-size: 12pt;">读未提交：最低隔离级别，无法避免不可重复读、脏读、 幻读和丢失更新。</span></div><div><span style="font-size: 12pt;">读已提交：可以避免脏读，无法避免、不可重复读、脏读、 和丢失更新。</span></div><div><span style="font-size: 12pt;">可重复读：可以避免脏读、不可重复读，幻读（InnoDB特殊规则保证），无法避免丢失更新</span></div><div><span style="font-size: 12pt;">串行化：可以避免一切并发问题。</span></div><div><span style="font-size: 18pt; color: rgb(20, 113, 145); font-weight: bold;">InnoDB的事务实现</span></div><div><span style="font-size: 12pt;">事务的实现无非就是围绕着事务的原子性、一致性、隔离线和持久性进行设计！可以有不同的设计策略，但是大体上是相同的，几个核心点如下：</span></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">1.如何保证原子性、一致性和持久性</span></font></div><div><font style="font-size: 12pt;">首先明确几个概念</font></div><div><ul><li><font style="font-size: 12pt;">关系型数据库为什么读写速度比不上缓存服务器 —— 因为缓冲服务器的数据读写是在内存！内存读写速度是磁盘的很多个数量级别。</font></li><li><font style="font-size: 12pt;">页是InnoDB磁盘管理的最小单位，可参见 <font><a href="InnoDB原理之页的概念.html"><font style="color: rgb(77, 206, 29);">InnoDB原理之页的概念</font></a></font>，在更新记录时，必须以页为单位来更新。</font></li><li><font style="font-size: 12pt;">InnoDB为了降低磁盘速度和内存速度的差距，也使用了缓存，在InnoDB引擎当中有日志缓冲、缓冲池（缓冲池中有数据页的缓冲、索引页的缓冲、插入缓冲、锁信息、数据字典信息和自适应哈希），缓冲池中的索引页缓冲和数据页缓冲基于LRU算法。</font></li><li><font style="font-size: 12pt;"><font>数据库的任何数据修改，必须首先在内存当中对数据页的缓冲或者索引页的缓冲进行修改，在之后才能同步回磁盘文件（好处是可以减少写盘次数，增大效率） ，这个时候缓冲池中的数据和硬盘数据不一致，我们称它们为脏页。</font><br/></font></li><li><font style="font-size: 12pt;">对于非聚集&amp;非唯一值索引，当我们在插入数据或者修改时，如果内存当中没有对应的索引页，插入或者修改操作将首先记录到插入缓冲当中，在之后可能合并着一起更新到索引页的缓冲。</font></li><li><font style="font-size: 12pt;">InnoDB通过日志预写和两次写来保证数据库事务的原子性、一致性和持久性。</font></li></ul><span style="font-size: 16px;"> 具体操作如下：</span></div><div><span style="font-size: 16px;">        当事务执行时，所有写操作都会提前生成redo log和undo log并且持久化到磁盘，前者是为了支持重做，后者是为了支持撤销。</span></div><div><span style="font-size: 16px;">        随后写操作会写到缓冲池中的数据页或者索引页，或者插入缓冲当中，定期会被进行合并。</span></div><div><span style="font-size: 16px;">        当缓冲池中的数据要写入磁盘时，先写入磁盘共享区，再写入数据文件（从而可以保证物理文件即使被破坏，也能够从磁盘共享区恢复）</span></div><div><span style="font-size: 16px;">        当数据库实例崩溃重启时，就可以根据上面的机制进行恢复，精妙。</span></div><div><span style="font-size: 16px;">        可以参见：</span></div><div>         <a href="InnoDB三大特性之两次写.html" style="color: #69aa35; font-size: 12pt;">InnoDB三大特性之两次写</a></div><div>         <a href="InnoDB三大特性之插入缓冲.html" style="color: #69aa35; font-size: 12pt;">InnoDB三大特性之插入缓冲</a></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;"><br/></span></font></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">2.如何保证隔离性</span></font></div><div>      <font style="font-size: 12pt;">之前一直认为数据库隔离级别是通过共享锁和独占锁的封锁策略实现的，这个虽然能够完成，但是实际上性能损失很大，所以现在的数据库引擎的实现都很复杂。</font></div><div><font style="font-size: 12pt;">      简单的说InnoDB引擎的隔离性是通过MVCC(多版本并发控制)和一定的封锁策略实现的。</font></div><div><font style="font-size: 12pt;">      可以认为InnoDB的隔离性是通过以下策略实现的（不完善）：</font></div><div><ul><li><font style="font-size: 12pt;">依靠MVCC(多版本并发控制)解决脏读和不可重复读，从而实现了一致读。<br/></font></li><li><font style="font-size: 12pt;">依靠Gap Lock和next-key lock解决了幻读问题。</font></li><li><span style="font-size: 16px;">依靠表锁实现了串行化隔离级别</span></li><li><span style="font-size: 16px;">行锁、独占锁、共享锁还有大量应用。</span></li></ul></div><div><font style="font-size: 12pt;">      可参考：</font></div><div><font><span style="font-size: 12pt;">      </span> <a href="InnoDB原理之事务隔离级别的实现原理.html" style="color: rgb(105, 170, 53);"><font style="font-size: 12pt;">InnoDB原理之事务隔离级别的实现原理</font></a></font></div><div><font style="font-size: 12pt;">       <a href="MySQL中的表锁、行锁、页锁、排它锁、共享锁、读锁和写锁.html" style="color: #69aa35;">MySQL中的表锁、行锁、页锁、排它锁、共享锁、读锁和写锁</a></font></div><div><font style="font-size: 12pt;">       <a href="依靠封锁策略实现事务隔离级别的原理.html" style="color: #69aa35;">依靠封锁策略实现事务隔离级别的原理</a></font></div><div><font style="color: rgb(105, 170, 53); font-size: 12pt;">       <a href="InnoDB原理之Next-Key Lock浅谈.html" style="color: #69aa35;">InnoDB原理之Next-Key Lock浅谈</a></font></div><div><br/></div></span>
</div></body></html> 