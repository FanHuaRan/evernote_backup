<html>
<head>
  <title>第五章 基础构建模块</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1102"/>
<h1>第五章 基础构建模块</h1>

<div>
<span><div><font style="font-size: 18pt;"><span style="color: rgb(26, 144, 185); font-size: 18pt; font-weight: bold;">一.同步容器类</span></font></div><div><span style="font-size: 12pt;">    同步容器类包括vector、hashtable、</span><span style="font-size: 12pt;">Collections.synchronizedXXX工厂方法装饰的容器</span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;">    <span style="font-size: 12pt; font-weight: bold;">1.同步容器类的问题</span></span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;">      同步容器类都是相对线程安全的，但在某些情况下可能需要额外的客户端加锁（或者派生和组合）来保护复合操作。</span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;">      常见的同步容器类的复合操作：迭代、跳转、条件运算</span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;">    <span style="font-size: 12pt; font-weight: bold;">2.迭代器与</span><span style="font-size: 12pt; font-weight: bold;">ConcurrentModificationException</span></span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;">     除了copyonwriteXXX，其它的容器基本都是fail-fast,迭代期间有另外线程修改容器，或者自身迭代时修改容器，就会抛出</span><span style="font-size: 12pt;">ConcurrentModificationException</span> </span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;">     这种策略叫做“fail-fast”,及时失败策略</span></span></span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;">    <span style="font-size: 12pt; font-weight: bold;">3.隐藏迭代器</span></span></span></span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;">     正如封装对象的状态有助于维持不变性条件一样，封装对象的同步机制同样有助于确保实施同步策略。</span></span></span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;">     容器的toString、hashcode、toString、containsAll、removeAll、retainAll以及把容器作为参数的构造方法，大部分都会对容器进行迭代。</span></span></span></font></div><div><br/></div><div><span style="font-weight: bold; color: rgb(26, 144, 185); font-size: 18pt;">二.并发容器</span></div><div><span style="font-size: 16px;">            java5.0提供了多种并发容器来改进同步容器的性能。同步容器将所有对容器状态的访问都串行化来实现线程安全性。这种方法的代价是严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重降低。</span></div><div><span style="font-size: 16px;">    另一方面，并发容器是针对多个线程并发访问设计的。</span></div><div><span style="font-size: 16px;">           通过并发容器来替代同步容器，可以极大的提高伸缩性并降低风险。</span></div><div><span style="font-size: 16px;">           并发容器包括：</span></div><div><span style="font-size: 16px;">           1.ConcurrentHashMap(还有ConcurrentHastSet)用来替代同步且基于散列的HashTable，<span style="font-size: 16px;">新的CurrentMap接口中增加了对一些常见复合操作的支持，例如“若没有则添加”、“替换以及有条件删除”等。</span></span></div><div><span style="font-size: 16px;">           2.CopyOnWriteArrayList用于在遍历操作为主要操作的情况下替换vector</span></div><div><span style="font-size: 16px;">           3.增加了队列接口queue和并发实现<span style="font-size: 12pt;">ConcurrentLinkedQueue</span></span></div><div><span style="font-size: 16px;"><span style="font-size: 12pt;">           4.增加了双端队列接口<span style="font-size: 12pt;">Deque和并发实现<span style="font-size: 12pt;">ConcurrentLinkedDeque</span></span></span></span></div><div><span style="font-size: 16px;">           5.</span><span style="font-size: 16px;">java6</span><span style="font-size: 12pt;"> 还</span><span style="font-size: 16px;">增加了阻塞队列接口</span><span style="font-size: 12pt;">BlockingQueue（扩展了queue）和其的相关实现：<span style="font-size: 12pt;">LinkedBlockingQueue，<span style="font-size: 12pt;">ArrayBlockingQueue</span></span></span></div><div><span style="font-size: 16px;">           6.</span><span style="font-size: 16px;">java6</span><span style="font-size: 12pt;"> 还</span><span style="font-size: 16px;">增加了双端阻塞队列接口</span><span style="font-size: 12pt;">BlockingDeque（扩展了</span><span style="font-size: 12pt;">BlockingQueue</span> <span style="font-size: 12pt;">）和其的相关实现：</span><span style="font-size: 12pt;">LinkedBlockingDeque</span></div><div><span style="font-size: 16px;"><span style="font-size: 12pt;"><span style="font-size: 12pt;">           7.增加了优先级阻塞队列<span style="font-size: 12pt;">PriorityBlockingQueue</span></span></span></span></div><div><span style="font-size: 16px;">           8.java6还提供了ConcurrentSkipListMap和ConcurrentSkipListSet（基于跳表）分别作为替换SortedMap和SortedSet的并发替代品</span></div><div><span style="font-size: 16px;">         </span></div><div><span style="font-size: 16px;">       <span style="font-size: 16px; font-weight: bold;">1.ConcurrentHashMap</span></span></div><div><span style="font-size: 16px;">          java7及之前使用分段锁，java8使用node锁</span></div><div><span style="font-size: 16px;">          迭代器不会抛出ConcurrentModifyException，是fail-safe，提供的是弱一致性。</span></div><div><span style="font-size: 16px;">          更高的伸缩性！优先使用</span></div><div><span style="font-size: 16px;">       <span style="font-size: 16px; font-weight: bold;">2.额外的原子Map操作</span></span></div><div><span style="font-size: 16px;">         由于并发容器的内部实现都不是简单的加锁来保护，含有比较复杂的逻辑，因此对于一些并发容器没有的复合操作，不能通过外部加锁来保证安全。</span></div><div><span style="font-size: 16px;">         所以并发容器提供了一些普通容器没有的复合操作。</span></div><div><span style="font-size: 16px;">       <span style="font-size: 16px; font-weight: bold;">3.</span><span style="font-size: 12pt; font-weight: bold;">CopyOnWriteArrayList</span></span></div><div><span style="font-size: 16px;"><span style="font-size: 12pt;">        用于替代同步list,在某些情况下它提供了更好的并发性能，并且在迭代期间不需要对容器进行加锁或者复制。</span></span></div><div><span style="font-size: 16px;"><span style="font-size: 12pt;">        写入时复制容器的线程安全性在于：只要正确发布一个事实不可变的对象，那么在访问该对象时都不需要进一步的同步，在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变现。</span></span></div><div><span style="font-size: 16px;"><span style="font-size: 12pt;">        写与写还是互斥的，使用的是显式锁，很经典的设计！空间换时间。</span></span></div><div><span style="font-size: 16px;"><span style="font-size: 12pt;">         仅当读远多于写时，才能使用这种容器。</span></span></div><div><span style="font-weight: bold; color: rgb(26, 144, 185); font-size: 18pt;">三.阻塞队列和生产者-消费者模式</span></div><div><span style="font-size: 16px;">      阻塞队列提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。</span></div><div><span style="font-size: 16px;">      阻塞队列支持生产者-消费者这种设计模式，生产者-消费者模式能简化开发过程，因为它消除了生产者代码和消费者代码之间的代码依赖，此外还将生产数据的过程与使用数据的过程解耦开来以简化工作之间负载的管理，因为往往这两个过程在处理数据的速率有所不同。</span></div><div><span style="font-size: 16px;">      Executor实际上就有生产者-消费者的思想。</span></div><div><span style="font-size: 16px;">     无界阻塞队列的缺陷：如果生产者生产速度远大于消费者的消费速度，那么工作项就会在队列累积并最终耗尽内存，使用有界队列可以避免这个问题，这是个用时间换空间的策略。</span></div><div><span style="font-size: 16px;">     阻塞队列还提供了一个offer方法，如果数据项不能添加到队列当中，那么将返回false，这样就能创建更多灵活的策略来处理负荷过载的情况，比如减轻负载、将多余工作序列化到磁盘，减少生产者数量或者抑制生产者线程等。</span></div><div><span style="font-size: 16px;">     在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具：它们能移植并防止产生过多的工作项，使应用程序在负荷过载的情况下更加健壮。</span></div><div><span style="font-size: 16px;">     一定要提前考虑生产者速率比消费者速率快的问题！</span></div><div><span style="font-size: 16px;">    <span style="font-size: 12pt;">SynchronousQueue提供了一个没有存储功能的阻塞队列，put和take会持续阻塞，直到有生产者生产数据&amp;消费者消费数据才会运行下去（类似于go中的通道），只有在有很多消费者，并且每次都有消费者准备处理数据才适合这种。</span></span></div><div><span style="font-size: 16px;">    <span style="font-size: 16px; font-weight: bold;">1.示例 桌面搜索</span></span></div><div><span style="font-size: 16px;">       生产者-消费者模式当中，阻塞队列可以负责控制流，生产者和消费者完全解耦，代码逻辑清晰！</span></div><div><span style="font-size: 16px;">       生产者-消费者模式的性能优势：生产者和消费者可以并发执行，</span><span style="font-size: 16px;">如果一个是I/0密集型，一个是CPU密集型，那么并发执行的吞吐率要高于串行执行的吞吐率，cpu密集型：I/O密集型=n : m</span></div><div><span style="font-size: 16px;">                                                       如果生产者和消费者的速率不同，那么它们将紧密耦合在一起，从而把整体的并行度降低为二者中更小的并行度。</span></div><div><span style="font-size: 16px;">    <span style="font-size: 16px; font-weight: bold;">2.串行线程封闭</span></span></div><div><span style="font-size: 16px;">       </span><span style="font-size: 16px;">线程封闭对象只能单个线程拥有，但可以通过安全地发布该对象来转移所有权，并且发布对象的线程不会再访问它。</span></div><div><span style="font-size: 16px;">       阻塞队列内部都包括了足够的同步机制，可以安全地将对象从生产者线程发布到消费者线程</span></div><div><span style="font-size: 16px;">       对于可变对象，生产者-消费者这种设计与阻塞队列一起，促进了串行线程封闭，从而将对象所有权从生产者交互给消费者。这种安全的发布确保了对象状态对于新的所有者来说是可见的，并且由于最初的所有者不会再拥有它，因此对象被封闭在新的线程中。新的所有者线程可以对该对象做任意修改，因为它具有独占的访问权。</span></div><div><span style="font-size: 16px;">      对象池（连接池、资源池）充分利用了串行线程封闭（这儿不是使用的阻塞队列来做的）</span></div><div><span style="font-size: 16px;">      也可以使用其它发布机制来传递对象的所有权，但必须确保只有一个线程能接受被转移的对象。阻塞队列简化了这项工作。除此之外，还可以通过ConcurrentMap的原子方法remove或者AtomicReference的原子方法compareAndSet来完成这项工作。</span></div><div><span style="font-size: 16px;">    <span style="font-size: 16px; font-weight: bold;">3.双端队列与工作窃取</span></span></div><div><span style="font-size: 16px;">       双端队列适用于工作窃取模式，</span></div><div><span style="font-size: 16px;">      工具窃取设计当中，如果一个消费者完成了自己双端队列中的全部工作，那么它可以从其他消费者双端队列末尾秘密地获取工作。工作窃取模式比生产者-消费者模式具有更高的伸缩性和性能，因为工作者线程不会在单个共享的任务队列上发生竞争并且可以充分利用线程资源。</span></div><div><span style="font-size: 16px;">      工作窃取适用于既是消费者，又是生产者的问题——执行某个工作，可能产生更多的工作。比如：网页爬虫、垃圾回收标记。</span></div><div><span style="font-weight: bold; color: rgb(26, 144, 185); font-size: 18pt;">四.阻塞方法和中断方法</span></div><div><span style="font-size: 16px;">    当线程被阻塞时，它通常被挂起，并处于某种阻塞状态（BLOCKED、WAITING或TIMED_WATING）,被阻塞的线程必须等待某个不受它控制的事件发生后才能继续运行。</span></div><div><span style="font-size: 16px;">    Thread提供了interrupt方法用于中断线程，interrupted方法用于查询线程是否中断（如果处于中断会抹掉中断标志）。每个线程都有一个布尔类型的属性，表示线程的中断状态，当中断线程时将设置这个状态。</span></div><div><span style="font-size: 16px;">    中断是一种协作机制。一个线程不能强制要求其它线程停止正在执行的操作而去执行其它的操作。当线程A中断线程B时，A仅仅是要求B在执行到某个可以暂停的地方停止正在执行的操作（但不会停止线程）——前提是线程B愿意停下来。</span></div><div><span style="font-size: 16px;">    当代码中调用了一个会抛出InterrupedException的方法时，必须要处理处理中断响应，不能只catch而不做处理。对于库代码，主要有以下几种选择：</span></div><div><span style="font-size: 16px;">   1.传递InterrupedException</span></div><div><span style="font-size: 16px;">   2.恢复中断（调用interrupt方法）</span></div><div><span style="font-size: 16px;">    对于用户代码还可以直接处理中断！但绝对不能捕获它而不做响应。</span></div><div><span style="font-weight: bold; color: rgb(26, 144, 185); font-size: 18pt;">五.同步工具类</span></div><div><span style="font-size: 16px;">    同步工具类可以是任何一个对象，只要它根据自身的状态来协调线程的控制流。阻塞队列可以作为线程工具类，其它类型的同步工具还包括信号量（Semaphore）、栅栏(Barrier&amp;Exchanger)以及闭锁(Latch)等。所有同步工具类都包含一些特定的结构化属性：它们封装了一些状态，这些状态将决定执行同步工具类的线程是继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另外一些高效方法用于高效地等待同步工具进入到预期状态。</span></div><div><span style="font-size: 16px;">    <span style="font-size: 16px; font-weight: bold;">1.闭锁（CountDownLatch）</span></span></div><div><span style="font-size: 16px;"><img src="第五章 基础构建模块_files/Image.png" type="image/png" data-filename="Image.png" style="font-size: 12pt;"/></span></div><div><span style="font-size: 16px;">      闭锁的作用：</span></div><div><span style="font-size: 16px;">      （1）确保某个计算在其所有需要资源都被初始化才进行。</span></div><div><span style="font-size: 16px;">      （2）确保服务在其依赖的所有服务都已经启动后才启动。</span></div><div><span style="font-size: 16px;">      （3）等待直到某个操作所有的参与者都就绪再执行。</span></div><div><span style="font-size: 16px;">    <span style="font-size: 16px; font-weight: bold;">2.FutureTask</span></span></div><div><span style="font-size: 16px;">       FutureTask也可以用作闭锁。</span></div><div><span style="font-size: 16px;">       </span></div><div><span style="font-size: 16px;">   <span style="font-size: 16px; font-weight: bold;">3.信号量（Semphore）</span></span></div><div><span style="font-size: 16px;"><img src="第五章 基础构建模块_files/Image [1].png" type="image/png" data-filename="Image.png" style="font-size: 12pt;"/></span></div><div><span style="font-size: 16px;">   信号量可以用于实现资源池或者将任一容器变为有界阻塞容器。</span></div><div><br/></div><div><span style="font-size: 16px;">  <span style="font-size: 16px; font-weight: bold;">4.栅栏（CyclicBarrier&amp;Exchanger）</span></span></div><div><span style="font-size: 16px;">   <img src="第五章 基础构建模块_files/Image [2].png" type="image/png" data-filename="Image.png" style="font-size: 12pt;"/></span></div><div><span style="font-weight: bold; color: rgb(26, 144, 185); font-size: 18pt;">六.构建高效且可伸缩的结果缓存</span></div><div><span style="font-size: 16px;">    四个代码，逐渐加深优化，好好体会</span></div><div><br/></div><div><span style="font-weight: bold; color: rgb(26, 144, 185); font-size: 18pt;">第一部分（基础知识）小结</span></div><div><span style="font-size: 16px;">1.可变状态是至关重要的。所有并发问题都可以归结为如何协调对并发状态的访问。可变状态越少，就越容易确保线程安全性。</span></div><div><span style="font-size: 16px;">2.尽量将域声明为final类型，除非需要它们是可变的。</span></div><div><span style="font-size: 16px;">3.不可变对象一定线程安全。</span></div><div><span style="font-size: 16px;">4.封装有助于管理复杂性：在编写线程安全的类时，虽然可以将所有数据都保存在全局变量中，但为什么要这样做？将数据封装在对象中，更易于维持不变性条件，将同步机制封装在类中，更易于遵守同步策略。</span></div><div><span style="font-size: 16px;">5.用锁来保护每个可变变量。</span></div><div><span style="font-size: 16px;">6.当保护一个不变性条件中的所有变量时，使用同一个锁。</span></div><div><span style="font-size: 16px;">7.在执行复合操作期间，要持有锁。</span></div><div><span style="font-size: 16px;">8.如果多个线程访问一个可变变量时没有同步机制，那么程序会有问题。</span></div><div><span style="font-size: 16px;">9.不要故作聪明不使用同步。</span></div><div><span style="font-size: 16px;">10.在设计过程中考虑线程安全，或者在文档中明确指出它不是线程安全的。</span></div><div><span style="font-size: 16px;">11.将同步策略文档化。</span></div><div><span style="font-size: 16px;"> </span></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 