<html>
<head>
  <title>TCP三次握手和四次挥手</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1455"/>
<h1>TCP三次握手和四次挥手</h1>

<div>
<span><div><table style="margin: 0px; padding: 0px; border-collapse: collapse; border-spacing: 0px; color: rgb(68, 68, 68); font-family: punctuation, 微软雅黑, Tohoma; font-size: 12px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); table-layout: fixed; width: 880px; position: relative;"><colgroup><col style="width: 880px;"></col></colgroup><tbody style="margin: 0px; padding: 0px;"><tr style="margin: 0px; padding: 0px;"><td style="margin: 0px; padding: 0px; word-wrap: break-word;" valign="top"><div style="margin: 0px; padding: 0px 16px; position: relative; overflow: hidden; height: 13186px;"><div style="margin: 0px; padding: 0px; min-height: 380px;"><div style="margin: 0px; padding: 0px;"><div style="margin: 0px; padding: 0px;"><font style="font-size: 18pt; color: rgb(20, 113, 145);"><span style="font-weight: bold;">个人理解</span></font></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">1.tcp和窗口</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"> TCP是面向连接的可靠传输协议，因此需要确保连接的可靠性与数据传输的有序性和可靠性，因此TCP使用窗口机制进行流量控制</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"> 窗口就是：连接建立时，各端分配一块缓冲区用来存储接收的数据，并将缓冲区的尺寸发送给另一端，接收方发送的确认信息中包含了自己剩余的缓冲区尺寸，剩余缓冲区空间的数量叫做窗口。注意：窗口是可以变化的，会随着发送数据而减小，后面又可以继续分配，简单理解就是&quot;我这次暂时还能接受你发送的多少数据&quot;。</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">1.tcp标志位,有6种标识，每个标识都占一位，该位为1表示有效，为0表示无效:</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">   SYN(synchronous建立联机):在建立连接时应用，SYN=1而ACK=0表示客户端向服务端请求连接，SYN=1而ACK=1表示服务端接受到客户端的连接请求包后向客户端发送的同意连接的包，所以SYN只有在建立连接,且是三次握手中的前两次才会用到。</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">   ACK(acknowledgement确认)：当ACK=1时，确认序号字段才有意义，表示希望对方接下来发送的包的序号（其实一般只有在第一次请求时连接时不是ACK包，因为并不知道对方的序列号起始位）</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">   FIN(finish结束)：当FIN=1时，表示欲发送的字节串已经发完，并请求开始断开传输连接，所以只有在端口连接时才会使用</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">   PSH(push传送)：当PSH=1时，表示恳求远地TCP将本报文段立即传送给其应用层，而不要比及全部缓存都填满了之后再向上交付。</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">   RST(reset重置):当RST=1时，表示呈现严重错误，必须断开连接，然后再重建传输连接。复位比特还用来拒绝一个不法的报文段或拒绝打开一个连接；</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">   URG(urgent紧急)：当URG=1时，表示此报文应尽快传送，而不要按本来的列队次序来传送。与“紧急指针”字段共同应用，紧急指针指出在本报文段中的紧急数据的最后一个字节的序号，使接管方可以知道紧急数据共有多长；</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">2.两个号码：</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">SequenceNumber(顺序号码)；占4个字节，是本报文段所发送的数据项目组第一个字节的序号。在TCP传送的数据流中，每一个字节都有一个序号。例如，一报文段的序号为300，而数据共100字节，则下一个报文段的序号就是400；和收到的对方的上一个包的AcknowledgeNumber(确认序号)相同，SequenceNumber在建立连接时会初始化</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">AcknowledgeNumber（确认号码):占4字节，是期望收到对方下次发送的数据的第一个字节的序号，也就是期望收到的下一个报文段的首部中的序号。</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">注意：这两个是动态增长变化的号码，和上面的SYN,ACK不是一回事，不过只有ACK==1时。AcknowledgeNumber才有意义</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">3.三次握手的过程</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">（1）第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">（2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RCVD状态。</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">（3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"> 完成三次握手，客户端与服务器开始传送数据。</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"> 注意：此时j是客户端A初始化的SequenceNumber，k是服务端B初始化的SequenceNumber，握手建立完成后也就是依赖着这些序列号进行发送和接收数据了。</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">4.四次挥手的过程</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"> TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 客户端A进入FIN_WAIT_1阶段</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">（2）服务器B收到这个FIN，服务端进入CLOSE_WAIT阶段，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。客户端收到后进入FIN_WAIT_2阶段</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。服务端进入LAST_ACK阶段，客户端收到后进入TIME_WAIT阶段。 </div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。 此时tcp连接正式关闭</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"> 简单说来是 “先关读，后关写”，一共需要四个阶段。以客户机发起关闭连接为例：</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">1.服务器读通道关闭</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">2.客户机写通道关闭</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">3.客户机读通道关闭</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">4.服务器写通道关闭</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">5.以客户端发起连接和关闭连接为例的状态迁移 </div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">客户端TCP状态迁移：</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">CLOSED-&gt;SYN_SENT-&gt;ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT-&gt;CLOSED</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">服务器TCP状态迁移：</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">CLOSED-&gt;LISTEN-&gt;SYN收到-&gt;ESTABLISHED-&gt;CLOSE_WAIT-&gt;LAST_ACK-&gt;CLOSED</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">6.以一个http请求为例,使用wareshark抓包，客户端ip192.168.43.194,服务端IP59.110.159.142,注意http协议是又客户端发起连接，服务端主动关闭连接</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"> </div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">   编号 发送时间    发送方IP        接收方IP    协议类型 数据大小 重要信息参数</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"> 1.3609 64.504580 192.168.43.194 59.110.159.142 TCP 66 51858→8080 [SYN] Seq=0 Win=8192 Len=0 MSS=1460 WS=4 SACK_PERM=1</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">   tcp第一次握手，客户端主动向服务端发送SYN包，seq初始化为0(可以为其它数字，看情况)</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"> 2.3618 64.571665 59.110.159.142 192.168.43.194 TCP 66 8080→51858 [SYN, ACK] Seq=0 Ack=1 Win=29200 Len=0 MSS=1400 SACK_PERM=1 WS=128</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">   tcp第二次握手，服务端收到客户端的SYN包后，向客户端回发SYN+ACK包，服务端的seq初始化为0（可以为其它数字，看情况），ack等于客户端的seq+1(一般只有在建立和断开连接时才会呈现1增长，因为建立和端口连接的数据包正文应该是空的)</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"> 3.3619 64.571823 192.168.43.194 59.110.159.142 TCP 54 51858→8080 [ACK] Seq=1 Ack=1 Win=65800 Len=0</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">   tcp第三次握手，客户端收到服务端的SYN+ACK包后，向服务端发送ACK包，最后的确认操作，此时自身的Seq已经+1，ack等于服务端的seq+1，此时连接成功</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"> 4.3620 64.574438 192.168.43.194 59.110.159.142 HTTP 558 GET / HTTP/1.1 </div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">   连接成功后，客户端才会向服务端发送应用层的http协议请求，http协议是包裹在tcp协议的数据正文里，通过tcp协议进行发送，这儿所使用的抓包工具封装了http正文向服务端传递的细节，我们可以不用去深究这个过程。</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"> 5.3629 64.643283 59.110.159.142 192.168.43.194 TCP 54 8080→51858 [ACK] Seq=1 Ack=505 Win=30336 Len=0</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">   服务端收到应用层的http协议请求后，web服务器进行了相关的处理之后，会先向客户端发送一个tcp数据包，告诉客户端如果你收到了我接下来返回给你的http响应，请向我发送你的505序号的数据，证明你已经成功收到了请求。注意这儿Ack已经增加到了505，证明之前的http协议请求已经发送了504个字节的数据</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"> 6.3630 64.650490 59.110.159.142 192.168.43.194 HTTP 675 HTTP/1.1 200   (text/html)</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">   服务端正式通过http协议向客户端返回http请求，也是包装在tcp当中的。</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"> 7.3647 64.849862 192.168.43.194 59.110.159.142 TCP 54 51858→8080 [ACK] Seq=505 Ack=622 Win=65176 Len=0</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">   客户端成功接收到http请求会向服务端发送序号为505的ACK包，向服务端说明我已经成功接收到数据，服务端不用重传。注意这儿Ack已经增加到了622，证明之前的http协议返回已经发送了621个字节。</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">///////对于Http1.1协议而言，客户端与服务端建立的tcp连接是长连接，Keep-Alive,这可以保证客户端的其它需要的静态文件可以重用该连接而继续向服务端进行请求，不用再建立连接。当长连接时间过去之后，我们就可以抓取到四次挥手断开连接的数据包</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"> 8.4139 84.687218 59.110.159.142 192.168.43.194 TCP 54 8080→51858 [FIN, ACK] Seq=622 Ack=505 Win=30336 Len=0</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">    服务端主动向客户端发送一个FIN+ACK的数据包，所以说http协议之下的tcp连接是由服务端主动关闭的。</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"> 9.4140 84.687320 192.168.43.194 59.110.159.142 TCP 54 51858→8080 [ACK] Seq=505 Ack=623 Win=65176 Len=0</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">    客户端收到服务端的FIN+ACK数据包后，会关闭客户端的读通道，然后向服务端发送ACK包</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">10.4324 94.186985 192.168.43.194 59.110.159.142 TCP 54 51858→8080 [FIN, ACK] Seq=505 Ack=623 Win=65176 Len=0</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">    等待一段时间后，客户端会向服务端发送FIN+ACK包。</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">11.4326 94.246964 59.110.159.142 192.168.43.194 TCP 54 8080→51858 [ACK] Seq=623 Ack=506 Win=30336 Len=0</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">    服务端接受到该数据包，会立即关闭读通道，等待2个MSL后，服务端会向客户端发送ACK包，</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">    最后客户端收到最后的ACK包，关闭写通道，tcp连接已关闭。</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">    精致！</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">7.为什么主动关闭连接的一方在收到对方的FIN+ACK包之后不直接关闭连接？为什么还要进入TIME_WAIT阶段并等待2MSL的时间（Maximum Segment Lifetime的两倍时间）？答案如下：</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">1、保证TCP协议的全双工连接能够可靠关闭</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">2、保证这次连接的重复数据段从网络中消失</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;">先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><br/></div><div style="margin: 0px; padding: 0px;"><div style="font-size: 14px; color: rgb(0, 0, 0);">再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。<span style="font-size: 14px; font-weight: bold; color: rgb(0, 0, 0);"> </span></div><div style="color: rgb(0, 0, 0);"><span style="font-weight: bold; color: rgb(0, 0, 0);"><font style="font-size: 18pt;"><br/></font></span></div><div><span style="font-weight: bold;"><font style="color: rgb(20, 113, 145); font-size: 18pt;">原文</font></span></div><div style="font-size: 14px; color: rgb(0, 0, 0);"><span style="font-weight: bold; font-size: 12px;">地址：</span><a href="http://www.cnblogs.com/Jessy/p/3535612.html" style="font-weight: bold; font-size: 12px; color: rgb(38, 112, 154);">http://www.cnblogs.com/Jessy/p/3535612.html</a></div><div style="font-size: 14px; color: rgb(0, 0, 0);"><span style="font-weight: bold; font-size: 18px; color: rgb(192, 0, 0);">建立连接：</span> </div></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><div><span style="font-weight: bold;">理解：窗口和滑动窗口</span></div><div><span style="font-weight: bold;">TCP的流量控制</span></div><div style="margin: 0px; padding: 0px;">TCP使用窗口机制进行流量控制</div><div style="margin: 0px; padding: 0px;">什么是窗口？</div><div style="margin: 10px auto; padding: 0px;">连接建立时，各端分配一块缓冲区用来存储接收的数据，并将缓冲区的尺寸发送给另一端</div><div style="margin: 10px auto; padding: 0px;">接收方发送的确认信息中包含了自己剩余的缓冲区尺寸</div><div style="margin: 10px auto; padding: 0px;"><span style="font-weight: bold;">剩余缓冲区空间的数量叫做窗口</span></div><div style="margin: 10px auto; padding: 0px;"><span style="font-weight: bold;">2. TCP的流控过程（滑动窗口）</span></div><div style="margin: 10px auto; padding: 0px;"><div><img src="http://a4.qpic.cn/psb?/V13NpUZg0ne6zL/PRliNzRfOBTmR1RoWPoGLqslMg.XIn2eMaaJ1hEuFW8!/b/dHMAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=dAIkA3QCJAMDEDU!&amp;su=0202232225&amp;tm=1520071200&amp;sce=0-12-12&amp;rf=2-9" style="margin: 0px; padding: 0px; border-width: 0px; border-style: none; vertical-align: top; width: 500px; height: 642px;"></img></div></div><div style="margin: 10px auto; padding: 0px;"><span style="font-weight: bold;">TCP(Transmission Control Protocol)　传输控制协议</span></div><div style="margin: 10px auto; padding: 0px;"><span style="font-weight: bold;">三次握手</span></div><div style="margin: 10px auto; padding: 0px;">TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:</div><div style="margin: 10px auto; padding: 0px;">位码即tcp标志位,有6种标示:</div><div style="margin: 10px auto; padding: 0px;">SYN(synchronous建立联机)</div><div style="margin: 10px auto; padding: 0px;">ACK(acknowledgement 确认)</div><div style="margin: 10px auto; padding: 0px;">PSH(push传送)</div><div style="margin: 10px auto; padding: 0px;">FIN(finish结束)</div><div style="margin: 10px auto; padding: 0px;">RST(reset重置)</div><div style="margin: 10px auto; padding: 0px;">URG(urgent紧急)</div><div style="margin: 10px auto; padding: 0px;">Sequence number(顺序号码)</div><div style="margin: 10px auto; padding: 0px;">Acknowledge number(确认号码)</div><div style="margin: 10px auto; padding: 0px;"><div><span style="font-weight: bold;">客户端TCP状态迁移：</span></div><div>CLOSED-&gt;SYN_SENT-&gt;ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT-&gt;CLOSED</div><div>服务器TCP状态迁移：</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">CLOSED-&gt;LISTEN-&gt;SYN收到-&gt;ESTABLISHED-&gt;CLOSE_WAIT-&gt;LAST_ACK-&gt;CLOSED</span></div></div><div style="margin: 10px auto; padding: 0px;"> </div><div style="margin: 10px auto; padding: 0px;"><div><img src="http://a3.qpic.cn/psb?/V13NpUZg0ne6zL/NxtaH3p0bjOyiIU8xousW01ZSlwOmWgluR42Uc7k*t4!/b/dD4BAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=6gOAAvQEKgMDEIc!&amp;su=0239537121&amp;tm=1520071200&amp;sce=0-12-12&amp;rf=2-9" style="margin: 0px; padding: 0px; border-width: 0px; border-style: none; vertical-align: top; width: 500px; height: 319px;"></img></div></div><div style="margin: 10px auto; padding: 0px;"><div><span style="font-weight: bold;">各个状态的意义如下：</span> </div><div>LISTEN - 侦听来自远方TCP端口的连接请求； </div><div>SYN-SENT -在发送连接请求后等待匹配的连接请求； </div><div>SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认； </div><div>ESTABLISHED- 代表一个打开的连接，数据可以传送给用户； </div><div>FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</div><div>FIN-WAIT-2 - 从远程TCP等待连接中断请求； </div><div>CLOSE-WAIT - 等待从本地用户发来的连接中断请求； </div><div>CLOSING -等待远程TCP对连接中断的确认； </div><div>LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认； </div><div>TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认； </div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">CLOSED - 没有任何连接状态；</span></div></div><div style="margin: 10px auto; padding: 0px;"> </div><div style="margin: 10px auto; padding: 0px;">TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接，如图1所示。</div><div style="margin: 10px auto; padding: 0px;">（1）第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。</div><div style="margin: 10px auto; padding: 0px;">（2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。</div><div style="margin: 10px auto; padding: 0px;">（3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。</div><div style="margin: 10px auto; padding: 0px;">完成三次握手，客户端与服务器开始传送数据。</div><div style="margin: 10px auto; padding: 0px;"><span style="font-weight: bold;">确认号：其数值等于发送方的</span>发送序号 +1<span style="font-weight: bold;">(即接收方期望接收的下一个序列号)。</span></div><div align="center" style="margin: 10px auto; padding: 0px;"><div><img src="http://a4.qpic.cn/psb?/V13NpUZg0ne6zL/uU20LizAtFULOLOJW2E1*RfRz7XekljhYjC0NrkIWPw!/b/dD8BAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=zwEMAQAAAAABEPQ!&amp;t=5&amp;su=0241892001&amp;tm=1520071200&amp;sce=0-12-12&amp;rf=2-9" style="margin: 0px; padding: 0px; border-width: 0px; border-style: none; vertical-align: top; width: 463px; height: 268px;"></img></div></div><div align="center" style="margin: 10px auto; padding: 0px;"><div>图1 TCP三次握手建立连接  </div><div style="margin-top: 1em; margin-bottom: 1em;"><img src="http://a2.qpic.cn/psb?/V13NpUZg0ne6zL/Z5uwNmB1KJaQcvn6t7wKCgt5anx3Z9fDYIUMvZMJ4YA!/b/dGkBAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=6gOAAvQEKgMDEIc!&amp;su=0154220769&amp;tm=1520071200&amp;sce=0-12-12&amp;rf=2-9" style="margin: 0px; padding: 0px; border-width: 0px; border-style: none; vertical-align: top; width: 500px; height: 319px;"></img><span style="-en-paragraph:true;"> </span></div></div><div style="margin: 10px auto; padding: 0px;"><div><span style="font-weight: bold;">TCP</span><span style="font-weight: bold;">的包头结构：</span></div><div>源端口 16位</div><div>目标端口 16位</div><div>序列号 32位</div><div>回应序号 32位</div><div>TCP头长度 4位</div><div>reserved 6位</div><div>控制代码 6位</div><div>窗口大小 16位</div><div>偏移量 16位</div><div>校验和 16位</div><div>选项  32位(可选)</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">这样我们得出了TCP包头的最小长度，为20字节</span></div></div><div style="margin: 0px 0px 0px 40px; padding: 0px; list-style: disc;"><div>第一次握手:</div><div>客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。</div></div><div><br/></div><div style="margin: 0px 0px 0px 40px; padding: 0px; list-style: disc;"><div>第二次握手:</div><div>服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。</div></div><div style="margin: 10px auto; padding: 0px;"> </div><div align="center" style="margin: 10px auto; padding: 0px;"></div><div style="margin: 0px 0px 0px 40px; padding: 0px; list-style: disc;"><div>第三次握手.</div><div>客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1</div></div><div><br/></div><div style="margin: 0px; padding: 0px;"><span style="font-weight: bold;">下面是具体的例子截图</span><span style="font-weight: bold;">：</span></div><div style="margin: 0px; padding: 0px;">1.此图包含两部分信息：TCP的三次握手(方框中的内容） （SYN, (SYN+ACK), ACK)</div><div style="margin: 0px; padding: 0px;">2. TCP的数据传输 （[TCP segment of a reassembled PUD])可以看出，server是将数据TCP层对消息包进行分片传输</div><div align="center" style="margin: 0px; padding: 0px;"><div>(1)Server端收到HTTP请求如GET之后，构造响应消息，其中携带网页内容，在server端的HTTP层发送消息200 OK-&gt;server端的TCP层； </div><div>(2)server端的TCP层对消息包进行分片传输； </div><div>(3)client端的TCP层对接收到的各个消息包分片回送响应； </div><div>(4)client端的TCP层每次收到一部分都会用ACK确认，之后server继续传输，client继续确认，直到完成响应消息的所有分片之后，Server<span style="font-weight: bold;">发送组合HTTP响应包 200 O</span>K，此时在client端的消息跟踪中才可以显示<span style="font-weight: bold;">HTTP 200 OK</span>的消息包</div></div><div style="margin: 10px auto; padding: 0px;"><img src="http://a4.qpic.cn/psb?/V13NpUZg0ne6zL/vyOMyAeEc.A.lDsd5Cl3tD3JoU*SYhqryIS4PM.wsD8!/b/dD8BAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=LAPkAAAAAAAREOw!&amp;t=5&amp;su=067921233&amp;tm=1520071200&amp;sce=0-12-12&amp;rf=2-9" style="margin: 0px; padding: 0px; border-width: 0px; border-style: none; vertical-align: top; width: 812px; height: 228px;"></img> </div><div style="margin: 10px auto; padding: 0px;"><span style="color: rgb(255, 0, 0); font-family: 宋体; font-size: 18pt; font-weight: bold;">关闭连接：</span></div><div style="margin: 10px auto; padding: 0px;"> </div><div style="margin: 10px auto; padding: 0px;">由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</div><div style="margin: 10px auto; padding: 0px;"> CP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</div><div style="margin: 10px auto; padding: 0px;">（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 </div><div style="margin: 10px auto; padding: 0px;">（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 </div><div style="margin: 10px auto; padding: 0px;">（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 </div><div style="margin: 10px auto; padding: 0px;">（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。 </div><div style="margin: 10px auto; padding: 0px;">TCP采用四次挥手关闭连接如图2所示。</div><div align="left" style="margin: 10px auto; padding: 0px;"><div><img src="http://a3.qpic.cn/psb?/V13NpUZg0ne6zL/*sTaxi2tP11w0tncAI*YOGxOW2hwmV.Q7hhcjIVUYS8!/b/dD4BAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=6gOAAvQEKgMDEIc!&amp;su=0178827905&amp;tm=1520071200&amp;sce=0-12-12&amp;rf=2-9" style="margin: 0px; padding: 0px; border-width: 0px; border-style: none; vertical-align: top; width: 500px; height: 319px;"></img></div></div><div style="margin: 10px auto; padding: 0px;"> 图2  TCP四次挥手关闭连接</div><div style="margin: 10px auto; padding: 0px;"> </div><div style="margin: 10px auto; padding: 0px;">参见wireshark抓包，实测的抓包结果并没有严格按挥手时序。我估计是时间间隔太短造成。</div><div><br/></div><div style="margin: 0px; padding: 0px;"> </div><div style="margin: 10px auto; padding: 0px;"><span style="font-weight: bold;">深入理解TCP</span><span style="font-weight: bold;">连接的</span><span style="font-weight: bold;">释放：</span> </div><div style="margin: 10px auto; padding: 0px;"> </div><div style="margin: 10px auto; padding: 0px;"><div><span style="font-weight: bold;">由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</span></div><div><span style="font-weight: bold;">TCP协议的连接是全双工连接，一个TCP连接存在双向的读写通道。 </span></div><div><span style="font-weight: bold;">简单说来是 “先关读，后关写”，一共需要四个阶段。以客户机发起关闭连接为例：</span></div><div><span style="font-weight: bold;">1.服务器读通道关闭</span></div><div><span style="font-weight: bold;">2.客户机写通道关闭</span></div><div><span style="font-weight: bold;">3.客户机读通道关闭</span></div><div><span style="font-weight: bold;">4.服务器写通道关闭</span></div><div><span style="font-weight: bold;">关闭行为是在发起方数据发送完毕之后，给对方发出一个FIN（finish）数据段。直到接收到对方发送的FIN，且对方收到了接收确认ACK之后，双方的数据通信完全结束，过程中每次接收都需要返回确认数据段ACK。</span></div><div><span style="font-weight: bold;">详细过程：</span></div><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">第一阶段</span><span style="font-weight: bold;">   客户机发送完数据之后，向服务器发送一个</span><span style="font-weight: bold;">FIN</span><span style="font-weight: bold;">数据段，序列号为</span><span style="font-weight: bold;">i</span><span style="font-weight: bold;">；</span></div><div><span style="font-weight: bold;">    1.服务器收到</span><span style="font-weight: bold;">FIN(i)</span><span style="font-weight: bold;">后，返回确认段</span><span style="font-weight: bold;">ACK</span><span style="font-weight: bold;">，序列号为</span><span style="font-weight: bold;">i+1</span><span style="font-weight: bold;">，</span><span style="font-weight: bold;">关闭服务器读通道</span><span style="font-weight: bold;">；</span></div><div><span style="font-weight: bold;">    2.客户机收到</span><span style="font-weight: bold;">ACK(i+1)</span><span style="font-weight: bold;">后，</span><span style="font-weight: bold;">关闭客户机写通道</span><span style="font-weight: bold;">；</span></div><div><span style="font-weight: bold;">   （此时，客户机仍能通过读通道读取服务器的数据，服务器仍能通过写通道写数据）</span></div><div><span style="font-weight: bold;">    </span><span style="font-weight: bold;">第二阶段 </span><span style="font-weight: bold;">服务器发送完数据之后，向客户机发送一个FIN数据段，序列号为j；</span></div><div><span style="font-weight: bold;">    3.客户机收到</span><span style="font-weight: bold;">FIN(j)</span><span style="font-weight: bold;">后，返回确认段</span><span style="font-weight: bold;">ACK</span><span style="font-weight: bold;">，序列号为</span><span style="font-weight: bold;">j+1</span><span style="font-weight: bold;">，</span><span style="font-weight: bold;">关闭客户机读通道</span><span style="font-weight: bold;">；</span></div><div><span style="font-weight: bold;">    4.服务器收到</span><span style="font-weight: bold;">ACK(j+1)</span><span style="font-weight: bold;">后，</span><span style="font-weight: bold;">关闭服务器写通道</span><span style="font-weight: bold;">。</span></div><div><span style="font-weight: bold;">这是标准的TCP关闭两个阶段，服务器和客户机都可以发起关闭，完全对称。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="font-weight: bold;-en-paragraph:true;">FIN标识是通过发送最后一块数据时设置的，标准的例子中，服务器还在发送数据，所以要等到发送完的时候，设置FIN（此时可称为TCP连接处于</span><span style="font-weight: bold;-en-paragraph:true;">半关闭状态，</span><span style="font-weight: bold;-en-paragraph:true;">因为数据仍可从被动关闭一方向主动关闭方传送）。如果在服务器收到FIN(i)时，已经没有数据需要发送，可以在返回ACK(i+1)的时候就设置FIN(j)标识，这样就相当于可以合并第二步和第三步。</span><span style="font-weight: bold;-en-paragraph:true;">读《Linux网络编程》关闭TCP连接章节，作以下笔记：</span></div></div><h1 style="margin: 10px 0px; padding: 0px; font-size: 28px;"><span style="font-size: 28px;">TCP的TIME_WAIT和Close_Wait状态</span></h1><div style="margin: 10px auto; padding: 0px;"> </div><div style="margin: 10px auto; padding: 0px;">面试时看到应聘者简历中写精通网络，TCP编程，我常问一个问题，TCP建立连接需要几次握手？95%以上的应聘者都能答对是3次。问TCP断开连接需要几次握手，70%的应聘者能答对是4次通讯。再问CLOSE_WAIT，TIME_WAIT是什么状态，怎么产生的，对服务有什么影响，如何消除？有一部分同学就回答不上来。不是我扣细节，而是在通讯为主的前端服务器上，必须有能力处理各种TCP状态。比如统计在本厂的一台前端机上高峰时间TCP连接的情况，统计命令：</div><div style="margin: 10px auto; padding: 0px;"> </div><div style="margin: 10px auto; padding: 0px;"> </div><div style="margin: 18px 0px !important; padding: 0px; font-size: 12px; word-break: break-word;"><ol start="1" style="margin: 0px 0px 1px 45px !important; padding-top: 0px !important; padding-right: 0px !important; padding-bottom: 0px !important; padding-left: 40px; border: none; list-style-position: initial; list-style-image: initial; color: rgb(92, 92, 92);"><li style="margin: 0px !important; padding: 0px 3px 0px 10px !important; list-style-type: decimal; list-style-position: outside !important; list-style-image: initial; border-top: none; border-right: none; border-bottom: none; border-left: 3px solid rgb(108, 226, 108); border-image: initial;"><span style="border: none; color: rgb(0, 0, 0);">netstat -n | awk </span><span style="border: none; color: blue;">'/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'</span><span style="border: none; color: rgb(0, 0, 0);">  </span></li></ol></div><div style="margin: 10px auto; padding: 0px;"> </div><div style="margin: 10px auto; padding: 0px;"> </div><div style="margin: 10px auto; padding: 0px;">结果：</div><div style="margin: 10px auto; padding: 0px;"></div><div style="margin: 10px auto; padding: 0px;"> <img src="http://a3.qpic.cn/psb?/V13NpUZg0ne6zL/Bnxh3BJ6ZMdam0h9ykCwzQyIKtwo7ieVOrkWxA8920M!/b/dGoBAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=ugDZAAAAAAABEFQ!&amp;t=5&amp;su=0257439969&amp;tm=1520071200&amp;sce=0-12-12&amp;rf=2-9" style="margin: 0px; padding: 0px; border-width: 0px; border-style: none; vertical-align: top; width: 186px; height: 217px;"></img></div><div style="margin: 10px auto; padding: 0px;">除了ESTABLISHED，可以看到连接数比较多的几个状态是：FIN_WAIT1, TIME_WAIT, CLOSE_WAIT, SYN_RECV和LAST_ACK；下面的文章就这几个状态的产生条件、对系统的影响以及处理方式进行简单描述。</div><div style="margin: 10px auto; padding: 0px;"> </div><h2 style="margin: 10px 0px; padding: 0px; font-size: 21px;"><span style="font-size: 21px;">TCP状态</span></h2><div style="margin: 10px auto; padding: 0px;"><div>TCP状态如下图所示：</div><div><img src="http://a4.qpic.cn/psb?/V13NpUZg0ne6zL/tSLXL9*9l7H02uVFN.WkHl.PB9lenkPPRiMj48PmFj4!/b/dD8BAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=gALBAvQDWwQDENw!&amp;su=067412113&amp;tm=1520071200&amp;sce=0-12-12&amp;rf=2-9" style="margin: 0px; padding: 0px; border-width: 0px; border-style: none; vertical-align: top; width: 640px; height: 705px;"></img></div></div><div style="margin: 10px auto; padding: 0px;">可能有点眼花缭乱？再看看这个时序图</div><div style="margin: 10px auto; padding: 0px;"><div><img src="http://a3.qpic.cn/psb?/V13NpUZg0ne6zL/rwQOwb*2hmUIZ8Pw97x0M6xxWXyEerxnn08Ep33DYAk!/b/dD4BAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=hQJdAoUCXQIDIAU!&amp;su=038023313&amp;tm=1520071200&amp;sce=0-12-12&amp;rf=2-9" style="margin: 0px; padding: 0px; border-width: 0px; border-style: none; vertical-align: top; width: 645px; height: 605px;"></img></div></div><div style="margin: 10px auto; padding: 0px;"> </div><div style="margin: 10px auto; padding: 0px;">下面看下大家一般比较关心的三种TCP状态</div><h2 style="margin: 10px 0px; padding: 0px; font-size: 21px;"><span style="font-size: 21px;">SYN_RECV </span></h2><div style="margin: 10px auto; padding: 0px;">服务端收到建立连接的SYN没有收到ACK包的时候处在SYN_RECV状态。有两个相关系统配置：</div><div style="margin: 10px auto; padding: 0px;"> </div><h3 style="margin: 10px 0px; padding: 0px; font-size: 16px;"><span style="font-size: 16px;">1，net.ipv4.tcp_synack_retries ：INTEGER</span></h3><div style="margin: 10px auto; padding: 0px;">默认值是5</div><div style="margin: 10px auto; padding: 0px;">对于远端的连接请求SYN，内核会发送SYN ＋ ACK数据报，以确认收到上一个 SYN连接请求包。这是所谓的三次握手( threeway handshake)机制的第二个步骤。这里决定内核在放弃连接之前所送出的 SYN+ACK 数目。不应该大于255，默认值是5，对应于180秒左右时间。通常我们不对这个值进行修改，因为我们希望TCP连接不要因为偶尔的丢包而无法建立。</div><h3 style="margin: 10px 0px; padding: 0px; font-size: 16px;"><span style="font-size: 16px;">2，net.ipv4.tcp_syncookies</span></h3><div style="margin: 10px auto; padding: 0px;">一般服务器都会设置net.ipv4.tcp_syncookies=1来防止SYN Flood攻击。假设一个用户向服务器发送了SYN报文后突然死机或掉线，那么服务器在发出SYN+ACK应答报文后是无法收到客户端的ACK报文的（第三次握手无法完成），这种情况下服务器端一般会重试（再次发送SYN+ACK给客户端）并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为SYN Timeout，一般来说这个时间是分钟的数量级（大约为30秒-2分钟）。</div><div style="margin: 10px auto; padding: 0px;"> </div><div style="margin: 10px auto; padding: 0px;">这些处在SYNC_RECV的TCP连接称为半连接，并存储在内核的半连接队列中，在内核收到对端发送的ack包时会查找半连接队列，并将符合的requst_sock信息存储到完成三次握手的连接的队列中，然后删除此半连接。大量SYNC_RECV的TCP连接会导致半连接队列溢出，这样后续的连接建立请求会被内核直接丢弃，这就是SYN Flood攻击。</div><div style="margin: 10px auto; padding: 0px;"> </div><div style="margin: 10px auto; padding: 0px;">能够有效防范SYN Flood攻击的手段之一，就是SYN Cookie。SYN Cookie原理由D. J. Bernstain和 Eric Schenk发明。SYN Cookie是对TCP服务器端的三次握手协议作一些修改，专门用来防范SYN Flood攻击的一种手段。它的原理是，在TCP服务器收到TCP SYN包并返回TCP SYN+ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。在收到TCP ACK包时，TCP服务器在根据那个cookie值检查这个TCP ACK包的合法性。如果合法，再分配专门的数据区进行处理未来的TCP连接。</div><div style="margin: 10px auto; padding: 0px;"> </div><div style="margin: 0px; padding: 0px;"><div>观测服务上SYN_RECV连接个数为：7314，对于一个高并发连接的通讯服务器，这个数字比较正常。</div><h2 style="margin: 10px 0px; padding: 0px; font-size: 21px;"><span style="font-size: 21px;">CLOSE_WAIT</span></h2><div style="margin: 10px auto; padding: 0px;">发起TCP连接关闭的一方称为client，被动关闭的一方称为server。被动关闭的server收到FIN后，但未发出ACK的TCP状态是CLOSE_WAIT。出现这种状况一般都是由于server端代码的问题，如果你的服务器上出现大量CLOSE_WAIT，应该要考虑检查代码。</div><h2 style="margin: 10px 0px; padding: 0px; font-size: 21px;"><span style="font-size: 21px;">TIME_WAIT</span></h2><div style="margin: 10px auto; padding: 0px;">根据TCP协议定义的3次握手断开连接规定,发起socket主动关闭的一方 socket将进入TIME_WAIT状态。TIME_WAIT状态将持续2个MSL(Max Segment Lifetime),在Windows下默认为4分钟，即240秒。TIME_WAIT状态下的socket不能被回收使用. 具体现象是对于一个处理大量短连接的服务器,如果是由服务器主动关闭客户端的连接，将导致服务器端存在大量的处于TIME_WAIT状态的socket， 甚至比处于Established状态下的socket多的多,严重影响服务器的处理能力，甚至耗尽可用的socket，停止服务。</div><div style="margin: 10px auto; padding: 0px;"> </div><div style="margin: 10px auto; padding: 0px;">为什么需要TIME_WAIT？TIME_WAIT是TCP协议用以保证被重新分配的socket不会受到之前残留的延迟重发报文影响的机制,是必要的逻辑保证。</div><div style="margin: 10px auto; padding: 0px;"> </div><div style="margin: 10px auto; padding: 0px;">和TIME_WAIT状态有关的系统参数有一般由3个，本厂设置如下：</div><div style="margin: 10px auto; padding: 0px;">net.ipv4.tcp_tw_recycle = 1</div><div style="margin: 10px auto; padding: 0px;">net.ipv4.tcp_tw_reuse = 1</div><div style="margin: 10px auto; padding: 0px;">net.ipv4.tcp_fin_timeout = 30</div><div style="margin: 10px auto; padding: 0px;"> </div><div style="margin: 10px auto; padding: 0px;">net.ipv4.tcp_fin_timeout，默认60s，减小fin_timeout，减少TIME_WAIT连接数量。</div><div style="margin: 10px auto; padding: 0px;"> </div><div style="margin: 10px auto; padding: 0px;">net.ipv4.tcp_tw_reuse = 1表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</div><div style="margin: 10px auto; padding: 0px;">net.ipv4.tcp_tw_recycle = 1表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</div></div><div style="margin: 10px auto; padding: 0px;"><div><br/></div><div><br/></div></div><div style="margin: 10px auto; padding: 0px;">为了方便描述，我给这个TCP连接的一端起名为Client，给另外一端起名为Server。上图描述的是Client主动关闭的过程，FTP协议中就这样的。如果要描述Server主动关闭的过程，只要交换描述过程中的Server和Client就可以了，HTTP协议就是这样的。</div><div style="margin: 10px auto; padding: 0px;"><div>描述过程：</div><div>Client调用close()函数，给Server发送FIN，请求关闭连接；Server收到FIN之后给Client返回确认ACK，同时关闭读通道（不清楚就去看一下shutdown和close的差别），也就是说现在不能再从这个连接上读取东西，现在read返回0。此时Server的TCP状态转化为CLOSE_WAIT状态。</div><div>Client收到对自己的FIN确认后，关闭 写通道，不再向连接中写入任何数据。</div><div>接下来Server调用close()来关闭连接，给Client发送FIN，Client收到后给Server回复ACK确认，同时Client关闭读通道，进入TIME_WAIT状态。</div><div>Server接收到Client对自己的FIN的确认ACK，关闭写通道，TCP连接转化为CLOSED，也就是关闭连接。</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">Client在TIME_WAIT状态下要等待最大数据段生存期的两倍，然后才进入CLOSED状态，TCP协议关闭连接过程彻底结束。</span></div></div><div style="margin: 10px auto; padding: 0px;"><div>以上就是TCP协议关闭连接的过程，现在说一下TIME_WAIT状态。</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">从上面可以看到，主动发起关闭连接的操作的一方将达到TIME_WAIT状态，而且这个状态要保持Maximum Segment Lifetime的两倍时间。为什么要这样做而不是直接进入CLOSED状态？</span></div></div><div style="margin: 10px auto; padding: 0px;"><div>原因有二：</div><div>一、保证TCP协议的全双工连接能够可靠关闭</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">二、保证这次连接的重复数据段从网络中消失</span></div></div><div style="margin: 10px auto; padding: 0px;">先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</div><div style="margin: 10px auto; padding: 0px;">再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</div><div style="margin: 10px auto; padding: 0px;">各种协议都是前人千锤百炼后得到的标准，规范。从细节中都能感受到精巧和严谨。每次深入都有同一个感觉，精妙。</div></div><div style="color: rgb(0, 0, 0); font-size: 14px; margin: 0px; padding: 0px;"><div>做个快乐的自己。<span style="font-size: 12px; font-weight: bold; color: rgb(0, 0, 0);"> </span></div><div><br/></div><div><span style="font-size: 18px; font-weight: bold; color: rgb(31, 73, 125);">参考文章</span></div><div style="margin: 0px; padding: 0px;">1.TCP的三次握手(建立连接）和四次挥手(关闭连接） <a href="http://www.cnblogs.com/Jessy/p/3535612.html" style="color: rgb(38, 112, 154);">http://www.cnblogs.com/Jessy/p/3535612.html</a></div><div style="margin: 0px; padding: 0px;">2.TCP协议中的三次握手和四次挥手(图解) <a href="http://blog.csdn.net/whuslei/article/details/6667471%A0" style="color: rgb(38, 112, 154);">http://blog.csdn.net/whuslei/article/details/6667471 </a>;</div></div></div></div></div></td></tr></tbody></table><div><br/></div></div></span>
</div></body></html> 