<html>
<head>
  <title>任务执行和线程池框架概览</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1230"/>
<h1>任务执行和线程池框架概览</h1>

<div>
<span><div><b><font style="font-size: 12pt;">一.任务执行框架顶层接口Executor</font></b></div><div><font style="font-size: 12pt;">   源码如下：</font></div><div><font style="font-size: 12pt;">   public interface Executor {</font></div><div><font style="font-size: 12pt;">     //执行任务，一个任务就是一个Runnable</font></div><div><font style="font-size: 12pt;">     void execute(Runnable command);</font></div><div><font style="font-size: 12pt;">   }</font></div><div><font style="font-size: 12pt;">   Executor提供了一个任务执行的基本接口，从最上层引入了关于任务执行策略的抽象，常常被用来替代显式的自实例化线程执行任务，具有更强的伸缩性、扩展性和可控性。</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>二.任务执行服务接口ExecutorService</b></font></div><div><font style="font-size: 12pt;">   该接口继承自Executor接口，源码如下：</font></div><div><font style="font-size: 12pt;">   public interface ExecutorService extends Executor {</font></div><div><font style="font-size: 12pt;">    //关闭任务执行服务，新任务将不会被接受，但已经提交的任务将会被全部执行</font></div><div><font style="font-size: 12pt;">    void shutdown();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //立即关闭任务执行服务，新任务将不会被接受，已经提交的任务将不会执行，正在执行的服务将会被打断。</font></div><div><font style="font-size: 12pt;">    //返回已经被提交的，但是还没有执行的任务</font></div><div><font style="font-size: 12pt;">    List&lt;Runnable&gt; shutdownNow();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //判断执行服务是否被关闭</font></div><div><font style="font-size: 12pt;">    boolean isShutdown();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //判断当前所有任务是否都已经在shutdown之后完成，包括被中断的任务，但不包括尚未执行的任务</font></div><div><font style="font-size: 12pt;">    boolean isTerminated();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //这个方法在shutdown之后可以调用</font></div><div><font style="font-size: 12pt;">    //目的是阻塞当前线程直到所有任务都已经完成或者时间超时</font></div><div><font style="font-size: 12pt;">    boolean awaitTermination(long timeout, TimeUnit unit)</font></div><div><font style="font-size: 12pt;">        throws InterruptedException;</font></div><div><font style="font-size: 12pt;">    </font></div><div><font style="font-size: 12pt;">    //提交一个带返回值的任务，返回future类型的对象，该对象封装了运行结果、运行异常且支持取消执行等操作</font></div><div><font style="font-size: 12pt;">    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //提交一个不带返回值的任务，不过会将第二个参数作为该任务的返回值</font></div><div><font style="font-size: 12pt;">    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //提交一个不带返回值的任务，不过会返回一个future对象，用于实现任务执行的控制</font></div><div><font style="font-size: 12pt;">    Future&lt;?&gt; submit(Runnable task);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //批量执行带返回值任务，阻塞直到全部任务完成</font></div><div><font style="font-size: 12pt;">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</font></div><div><font style="font-size: 12pt;">        throws InterruptedException;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //批量执行带返回值任务，阻塞直到全部任务完成或者超时</font></div><div><font style="font-size: 12pt;">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</font></div><div><font style="font-size: 12pt;">                                  long timeout, TimeUnit unit)</font></div><div><font style="font-size: 12pt;">        throws InterruptedException;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //批量执行带返回值的任务，直到一个任务运行完成则返回该任务的运行结果</font></div><div><font style="font-size: 12pt;">    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</font></div><div><font style="font-size: 12pt;">        throws InterruptedException, ExecutionException;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    // 批量执行带返回值，不过只返回一个成功执行的任务的结果,带超时</font></div><div><font style="font-size: 12pt;">    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</font></div><div><font style="font-size: 12pt;">                    long timeout, TimeUnit unit)</font></div><div><font style="font-size: 12pt;">        throws InterruptedException, ExecutionException, TimeoutException;</font></div><div><font style="font-size: 12pt;">   }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">   Executor接口只提供了一个基本的任务执行接口，ExecutorService继承自Executor,提供了一系列的服务周期控制方法和对任务执行的扩展接口。</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>三.任务执行接口Runable(不属于并发包)</b></font></div><div><font style="font-size: 12pt;">   源码如下：</font></div><div><font style="font-size: 12pt;">   @FunctionalInterface</font></div><div><font style="font-size: 12pt;">   public interface Runnable {</font></div><div><font style="font-size: 12pt;">      public abstract void run();</font></div><div><font style="font-size: 12pt;">   }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>四.带返回值和可抛出异常的任务执行接口Callable</b></font></div><div><font style="font-size: 12pt;">   源码如下：</font></div><div><font style="font-size: 12pt;">  @FunctionalInterface</font></div><div><font style="font-size: 12pt;">  public interface Callable&lt;V&gt; {</font></div><div><font style="font-size: 12pt;">    V call() throws Exception;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  Runable接口可以直接给线程使用，Callable接口只能依托FutureTask而运行，因为它带返回值的魔法需要FutureTask的包装</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>五.封装任务执行结果和任务控制的接口Future</b></font></div><div><font style="font-size: 12pt;">   源码如下：</font></div><div><font style="font-size: 12pt;">   public interface Future&lt;V&gt; {</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">       //尝试取消任务的执行，在以下场景将会失败：</font></div><div><font style="font-size: 12pt;">       //1.任务已经完成</font></div><div><font style="font-size: 12pt;">       //2.任务已经被取消</font></div><div><font style="font-size: 12pt;">       //3.一些其他的原因</font></div><div><font style="font-size: 12pt;">       //对于没有开始运行的任务，这些任务后面将不会运行，如果任务已经开始运行，那么mayInterruptIfRunning参数将决定是否打断该线</font></div><div><font style="font-size: 12pt;">       //程，从而让该任务自己在合适的时候检测中断。从而自己停止任务</font></div><div><font style="font-size: 12pt;">    boolean cancel(boolean mayInterruptIfRunning);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //判断任务是否已经被取消</font></div><div><font style="font-size: 12pt;">    boolean isCancelled();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //判断任务是否已经完成</font></div><div><font style="font-size: 12pt;">    boolean isDone();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //获取运行结果，</font></div><div><font style="font-size: 12pt;">    //如果尚未运行完毕，将会阻塞直到运行完毕或者爆出异常</font></div><div><font style="font-size: 12pt;">    //get方法将会获取运行结果或者抛出运行时遇到的异常（被封装在ExecutionException中）</font></div><div><font style="font-size: 12pt;">    V get() throws InterruptedException, ExecutionException;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //获取运行结果，带超时机制</font></div><div><font style="font-size: 12pt;">    V get(long timeout, TimeUnit unit)</font></div><div><font style="font-size: 12pt;">        throws InterruptedException, ExecutionException, TimeoutException;</font></div><div><font style="font-size: 12pt;">   }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>六.封装任务执行结果和任务控制的运行任务Runnable接口</b></font></div><div><font style="font-size: 12pt;">   该接口继承自Runable和Future,是任务执行框架当中每个任务执行时的抽象</font></div><div><font style="font-size: 12pt;">    源码如下：</font></div><div><font style="font-size: 12pt;">    public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {</font></div><div><font style="font-size: 12pt;">        //再一次申明run方法，表示在运行结束后将会设置运行结果，除非被取消</font></div><div><font style="font-size: 12pt;">        void run();</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>七.任务运行的封装实现FutureTask</b></font></div><div><font style="font-size: 12pt;">   该类实现RunnableFuture,源码如下：</font></div><div><font style="font-size: 12pt;">   public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {</font></div><div><font style="font-size: 12pt;">    //任务运行状态</font></div><div><font style="font-size: 12pt;">    private volatile int state;</font></div><div><font style="font-size: 12pt;">    //几个状态常量</font></div><div><font style="font-size: 12pt;">    private static final int NEW          = 0;</font></div><div><font style="font-size: 12pt;">    private static final int COMPLETING   = 1;</font></div><div><font style="font-size: 12pt;">    private static final int NORMAL       = 2;</font></div><div><font style="font-size: 12pt;">    private static final int EXCEPTIONAL  = 3;</font></div><div><font style="font-size: 12pt;">    private static final int CANCELLED    = 4;</font></div><div><font style="font-size: 12pt;">    private static final int INTERRUPTING = 5;</font></div><div><font style="font-size: 12pt;">    private static final int INTERRUPTED  = 6;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //被封装的callable，我们写的逻辑会在这里面</font></div><div><font style="font-size: 12pt;">    private Callable&lt;V&gt; callable;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //返回值或者运行异常</font></div><div><font style="font-size: 12pt;">    private Object outcome; // non-volatile, protected by state reads/writes</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //当前任务所运行的线程，通过cas进行保护</font></div><div><font style="font-size: 12pt;">    private volatile Thread runner;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //等待当前线程运行结果的节点</font></div><div><font style="font-size: 12pt;">    private volatile WaitNode waiters;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //获取运行结果获抛出取消异常获抛出运行异常</font></div><div><font style="font-size: 12pt;">    private V report(int s) throws ExecutionException {</font></div><div><font style="font-size: 12pt;">        Object x = outcome;</font></div><div><font style="font-size: 12pt;">        if (s == NORMAL)</font></div><div><font style="font-size: 12pt;">            return (V)x;</font></div><div><font style="font-size: 12pt;">        if (s &gt;= CANCELLED)</font></div><div><font style="font-size: 12pt;">            throw new CancellationException();</font></div><div><font style="font-size: 12pt;">        throw new ExecutionException((Throwable)x);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //使用callable的构造方法</font></div><div><font style="font-size: 12pt;">    public FutureTask(Callable&lt;V&gt; callable) {</font></div><div><font style="font-size: 12pt;">        if (callable == null)</font></div><div><font style="font-size: 12pt;">            throw new NullPointerException();</font></div><div><font style="font-size: 12pt;">        this.callable = callable;</font></div><div><font style="font-size: 12pt;">        this.state = NEW;       // ensure visibility of callable</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //使用Runnable的构造方法</font></div><div><font style="font-size: 12pt;">    public FutureTask(Runnable runnable, V result) {</font></div><div><font style="font-size: 12pt;">        //这儿会将runnable封装为callable</font></div><div><font style="font-size: 12pt;">        this.callable = Executors.callable(runnable, result);</font></div><div><font style="font-size: 12pt;">        this.state = NEW;       // ensure visibility of callable</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //判断任务是否已经取消 中断中或者已经中断都会认为是已经取消</font></div><div><font style="font-size: 12pt;">    public boolean isCancelled() {</font></div><div><font style="font-size: 12pt;">        return state &gt;= CANCELLED;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    </font></div><div><font style="font-size: 12pt;">    //判断任务是否已经在执行或者执行完成，只要不处于new状态都返回true</font></div><div><font style="font-size: 12pt;">    public boolean isDone() {</font></div><div><font style="font-size: 12pt;">        return state != NEW;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //中断任务</font></div><div><font style="font-size: 12pt;">    public boolean cancel(boolean mayInterruptIfRunning) {</font></div><div><font style="font-size: 12pt;">        //如果任务已经尚处于new状态，先尝试使用CAS将任务状态设置为取消或者中断中</font></div><div><font style="font-size: 12pt;">        if (!(state == NEW &amp;&amp;</font></div><div><font style="font-size: 12pt;"><a href="http://unsafe.compareandswapint(this/">UNSAFE.compareAndSwapInt(this</a>, stateOffset, NEW,</font></div><div><font style="font-size: 12pt;">                  mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</font></div><div><font style="font-size: 12pt;">            return false;</font></div><div><font style="font-size: 12pt;">        //如果要中断则进行中断</font></div><div><font style="font-size: 12pt;">        try {    // in case call to interrupt throws exception</font></div><div><font style="font-size: 12pt;">            if (mayInterruptIfRunning) {</font></div><div><font style="font-size: 12pt;">                try {</font></div><div><font style="font-size: 12pt;">                    Thread t = runner;</font></div><div><font style="font-size: 12pt;">                    if (t != null)</font></div><div><font style="font-size: 12pt;">                        t.interrupt();</font></div><div><font style="font-size: 12pt;">                } finally { // final state</font></div><div><font style="font-size: 12pt;">                    UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);</font></div><div><font style="font-size: 12pt;">                }</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">        } finally {</font></div><div><font style="font-size: 12pt;">            //进行收尾工作</font></div><div><font style="font-size: 12pt;">            finishCompletion();</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">        return true;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //获取运行结果</font></div><div><font style="font-size: 12pt;">    public V get() throws InterruptedException, ExecutionException {</font></div><div><font style="font-size: 12pt;">        int s = state;</font></div><div><font style="font-size: 12pt;">        //如果尚未完成则等待完成，不带超时</font></div><div><font style="font-size: 12pt;">        if (s &lt;= COMPLETING)</font></div><div><font style="font-size: 12pt;">            s = awaitDone(false, 0L);</font></div><div><font style="font-size: 12pt;">        return report(s);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //获取运行结果，带超时</font></div><div><font style="font-size: 12pt;">    public V get(long timeout, TimeUnit unit)</font></div><div><font style="font-size: 12pt;">        throws InterruptedException, ExecutionException, TimeoutException {</font></div><div><font style="font-size: 12pt;">        if (unit == null)</font></div><div><font style="font-size: 12pt;">            throw new NullPointerException();</font></div><div><font style="font-size: 12pt;">        int s = state;</font></div><div><font style="font-size: 12pt;">        if (s &lt;= COMPLETING &amp;&amp;</font></div><div><font style="font-size: 12pt;">            (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING)</font></div><div><font style="font-size: 12pt;">            throw new TimeoutException();</font></div><div><font style="font-size: 12pt;">        return report(s);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //当任务完成的回调方法</font></div><div><font style="font-size: 12pt;">    protected void done() { }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //设置运行结果和运行状态，这是正确运行的情况</font></div><div><font style="font-size: 12pt;">    protected void set(V v) {</font></div><div><font style="font-size: 12pt;">        if (<a href="http://unsafe.compareandswapint(this/">UNSAFE.compareAndSwapInt(this</a>, stateOffset, NEW, COMPLETING)) {</font></div><div><font style="font-size: 12pt;">            outcome = v;</font></div><div><font style="font-size: 12pt;">            UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state</font></div><div><font style="font-size: 12pt;">            finishCompletion();</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //设置运行结果和运行状态，这是抛出异常的情况</font></div><div><font style="font-size: 12pt;">    protected void setException(Throwable t) {</font></div><div><font style="font-size: 12pt;">        if (<a href="http://unsafe.compareandswapint(this/">UNSAFE.compareAndSwapInt(this</a>, stateOffset, NEW, COMPLETING)) {</font></div><div><font style="font-size: 12pt;">            outcome = t;</font></div><div><font style="font-size: 12pt;">            UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state</font></div><div><font style="font-size: 12pt;">            finishCompletion();</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //运行任务 核心</font></div><div><font style="font-size: 12pt;">    public void run() {</font></div><div><font style="font-size: 12pt;">        if (state != NEW ||</font></div><div><font style="font-size: 12pt;">            !<a href="http://unsafe.compareandswapobject(this/">UNSAFE.compareAndSwapObject(this</a>, runnerOffset,</font></div><div><font style="font-size: 12pt;">                                         null, Thread.currentThread()))</font></div><div><font style="font-size: 12pt;">            return;</font></div><div><font style="font-size: 12pt;">        try {</font></div><div><font style="font-size: 12pt;">            Callable&lt;V&gt; c = callable;</font></div><div><font style="font-size: 12pt;">            if (c != null &amp;&amp; state == NEW) {</font></div><div><font style="font-size: 12pt;">                V result;</font></div><div><font style="font-size: 12pt;">                boolean ran;</font></div><div><font style="font-size: 12pt;">                try {</font></div><div><font style="font-size: 12pt;">                    result = c.call();</font></div><div><font style="font-size: 12pt;">                    ran = true;</font></div><div><font style="font-size: 12pt;">                } catch (Throwable ex) {</font></div><div><font style="font-size: 12pt;">                    result = null;</font></div><div><font style="font-size: 12pt;">                    ran = false;</font></div><div><font style="font-size: 12pt;">                    setException(ex);</font></div><div><font style="font-size: 12pt;">                }</font></div><div><font style="font-size: 12pt;">                if (ran)</font></div><div><font style="font-size: 12pt;">                    set(result);</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">        } finally {</font></div><div><font style="font-size: 12pt;">            // runner must be non-null until state is settled to</font></div><div><font style="font-size: 12pt;">            // prevent concurrent calls to run()</font></div><div><font style="font-size: 12pt;">            runner = null;</font></div><div><font style="font-size: 12pt;">            // state must be re-read after nulling runner to prevent</font></div><div><font style="font-size: 12pt;">            // leaked interrupts</font></div><div><font style="font-size: 12pt;">            int s = state;</font></div><div><font style="font-size: 12pt;">            if (s &gt;= INTERRUPTING)</font></div><div><font style="font-size: 12pt;">                handlePossibleCancellationInterrupt(s);</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //运行，不设置结果，然后进行状态重置</font></div><div><font style="font-size: 12pt;">    protected boolean runAndReset() {</font></div><div><font style="font-size: 12pt;">        if (state != NEW ||</font></div><div><font style="font-size: 12pt;">            !<a href="http://unsafe.compareandswapobject(this/">UNSAFE.compareAndSwapObject(this</a>, runnerOffset,</font></div><div><font style="font-size: 12pt;">                                         null, Thread.currentThread()))</font></div><div><font style="font-size: 12pt;">            return false;</font></div><div><font style="font-size: 12pt;">        boolean ran = false;</font></div><div><font style="font-size: 12pt;">        int s = state;</font></div><div><font style="font-size: 12pt;">        try {</font></div><div><font style="font-size: 12pt;">            Callable&lt;V&gt; c = callable;</font></div><div><font style="font-size: 12pt;">            if (c != null &amp;&amp; s == NEW) {</font></div><div><font style="font-size: 12pt;">                try {</font></div><div><font style="font-size: 12pt;">                    c.call(); // don't set result</font></div><div><font style="font-size: 12pt;">                    ran = true;</font></div><div><font style="font-size: 12pt;">                } catch (Throwable ex) {</font></div><div><font style="font-size: 12pt;">                    setException(ex);</font></div><div><font style="font-size: 12pt;">                }</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">        } finally {</font></div><div><font style="font-size: 12pt;">            // runner must be non-null until state is settled to</font></div><div><font style="font-size: 12pt;">            // prevent concurrent calls to run()</font></div><div><font style="font-size: 12pt;">            runner = null;</font></div><div><font style="font-size: 12pt;">            // state must be re-read after nulling runner to prevent</font></div><div><font style="font-size: 12pt;">            // leaked interrupts</font></div><div><font style="font-size: 12pt;">            s = state;</font></div><div><font style="font-size: 12pt;">            if (s &gt;= INTERRUPTING)</font></div><div><font style="font-size: 12pt;">                handlePossibleCancellationInterrupt(s);</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">        return ran &amp;&amp; s == NEW;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //检测可能的中断</font></div><div><font style="font-size: 12pt;">    private void handlePossibleCancellationInterrupt(int s) {</font></div><div><font style="font-size: 12pt;">        // It is possible for our interrupter to stall before getting a</font></div><div><font style="font-size: 12pt;">        // chance to interrupt us.  Let's spin-wait patiently.</font></div><div><font style="font-size: 12pt;">        if (s == INTERRUPTING)</font></div><div><font style="font-size: 12pt;">            while (state == INTERRUPTING)</font></div><div><font style="font-size: 12pt;">                Thread.yield(); // wait out pending interrupt</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">        // assert state == INTERRUPTED;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">        // We want to clear any interrupt we may have received from</font></div><div><font style="font-size: 12pt;">        // cancel(true).  However, it is permissible to use interrupts</font></div><div><font style="font-size: 12pt;">        // as an independent mechanism for a task to communicate with</font></div><div><font style="font-size: 12pt;">        // its caller, and there is no way to clear only the</font></div><div><font style="font-size: 12pt;">        // cancellation interrupt.</font></div><div><font style="font-size: 12pt;">        //</font></div><div><font style="font-size: 12pt;">        // Thread.interrupted();</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //任务结果等待节点</font></div><div><font style="font-size: 12pt;">    static final class WaitNode {</font></div><div><font style="font-size: 12pt;">        volatile Thread thread;</font></div><div><font style="font-size: 12pt;">        volatile WaitNode next;</font></div><div><font style="font-size: 12pt;">        WaitNode() { thread = Thread.currentThread(); }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //结束运行 依次唤醒等待get结果的节点</font></div><div><font style="font-size: 12pt;">    private void finishCompletion() {</font></div><div><font style="font-size: 12pt;">        // assert state &gt; COMPLETING;</font></div><div><font style="font-size: 12pt;">        for (WaitNode q; (q = waiters) != null;) {</font></div><div><font style="font-size: 12pt;">            if (<a href="http://unsafe.compareandswapobject(this/">UNSAFE.compareAndSwapObject(this</a>, waitersOffset, q, null)) {</font></div><div><font style="font-size: 12pt;">                for (;;) {</font></div><div><font style="font-size: 12pt;">                    Thread t = q.thread;</font></div><div><font style="font-size: 12pt;">                    if (t != null) {</font></div><div><font style="font-size: 12pt;">                        q.thread = null;</font></div><div><font style="font-size: 12pt;">                        LockSupport.unpark(t);</font></div><div><font style="font-size: 12pt;">                    }</font></div><div><font style="font-size: 12pt;">                    WaitNode next = q.next;</font></div><div><font style="font-size: 12pt;">                    if (next == null)</font></div><div><font style="font-size: 12pt;">                        break;</font></div><div><font style="font-size: 12pt;">                    q.next = null; // unlink to help gc</font></div><div><font style="font-size: 12pt;">                    q = next;</font></div><div><font style="font-size: 12pt;">                }</font></div><div><font style="font-size: 12pt;">                break;</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">        done();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">        callable = null;        // to reduce footprint</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    // 结束运行 依次唤醒等待get结果的节点 带超时机制</font></div><div><font style="font-size: 12pt;">    private int awaitDone(boolean timed, long nanos)</font></div><div><font style="font-size: 12pt;">        throws InterruptedException {</font></div><div><font style="font-size: 12pt;">        final long deadline = timed ? System.nanoTime() + nanos : 0L;</font></div><div><font style="font-size: 12pt;">        WaitNode q = null;</font></div><div><font style="font-size: 12pt;">        boolean queued = false;</font></div><div><font style="font-size: 12pt;">        for (;;) {</font></div><div><font style="font-size: 12pt;">            if (Thread.interrupted()) {</font></div><div><font style="font-size: 12pt;">                removeWaiter(q);</font></div><div><font style="font-size: 12pt;">                throw new InterruptedException();</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">            int s = state;</font></div><div><font style="font-size: 12pt;">            if (s &gt; COMPLETING) {</font></div><div><font style="font-size: 12pt;">                if (q != null)</font></div><div><font style="font-size: 12pt;">                    q.thread = null;</font></div><div><font style="font-size: 12pt;">                return s;</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">            else if (s == COMPLETING) // cannot time out yet</font></div><div><font style="font-size: 12pt;">                Thread.yield();</font></div><div><font style="font-size: 12pt;">            else if (q == null)</font></div><div><font style="font-size: 12pt;">                q = new WaitNode();</font></div><div><font style="font-size: 12pt;">            else if (!queued)</font></div><div><font style="font-size: 12pt;">                queued = <a href="http://unsafe.compareandswapobject(this/">UNSAFE.compareAndSwapObject(this</a>, waitersOffset,</font></div><div><font style="font-size: 12pt;">                                                     q.next = waiters, q);</font></div><div><font style="font-size: 12pt;">            else if (timed) {</font></div><div><font style="font-size: 12pt;">                nanos = deadline - System.nanoTime();</font></div><div><font style="font-size: 12pt;">                if (nanos &lt;= 0L) {</font></div><div><font style="font-size: 12pt;">                    removeWaiter(q);</font></div><div><font style="font-size: 12pt;">                    return state;</font></div><div><font style="font-size: 12pt;">                }</font></div><div><font style="font-size: 12pt;">                LockSupport.parkNanos(this, nanos);</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">            else</font></div><div><font style="font-size: 12pt;">                LockSupport.park(this);</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //移除等待节点</font></div><div><font style="font-size: 12pt;">    private void removeWaiter(WaitNode node) {</font></div><div><font style="font-size: 12pt;">        if (node != null) {</font></div><div><font style="font-size: 12pt;">            node.thread = null;</font></div><div><font style="font-size: 12pt;">            retry:</font></div><div><font style="font-size: 12pt;">            for (;;) {          // restart on removeWaiter race</font></div><div><font style="font-size: 12pt;">                for (WaitNode pred = null, q = waiters, s; q != null; q = s) {</font></div><div><font style="font-size: 12pt;">                    s = q.next;</font></div><div><font style="font-size: 12pt;">                    if (q.thread != null)</font></div><div><font style="font-size: 12pt;">                        pred = q;</font></div><div><font style="font-size: 12pt;">                    else if (pred != null) {</font></div><div><font style="font-size: 12pt;">                        pred.next = s;</font></div><div><font style="font-size: 12pt;">                        if (pred.thread == null) // check for race</font></div><div><font style="font-size: 12pt;">                            continue retry;</font></div><div><font style="font-size: 12pt;">                    }</font></div><div><font style="font-size: 12pt;">                    else if (!<a href="http://unsafe.compareandswapobject(this/">UNSAFE.compareAndSwapObject(this</a>, waitersOffset,</font></div><div><font style="font-size: 12pt;">                                                          q, s))</font></div><div><font style="font-size: 12pt;">                        continue retry;</font></div><div><font style="font-size: 12pt;">                }</font></div><div><font style="font-size: 12pt;">                break;</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    // Unsafe 调用逻辑和本类相关字段的偏移位 cas和内存屏障需要</font></div><div><font style="font-size: 12pt;">    private static final sun.misc.Unsafe UNSAFE;</font></div><div><font style="font-size: 12pt;">    private static final long stateOffset;</font></div><div><font style="font-size: 12pt;">    private static final long runnerOffset;</font></div><div><font style="font-size: 12pt;">    private static final long waitersOffset;</font></div><div><font style="font-size: 12pt;">    static {</font></div><div><font style="font-size: 12pt;">        try {</font></div><div><font style="font-size: 12pt;">            UNSAFE = sun.misc.Unsafe.getUnsafe();</font></div><div><font style="font-size: 12pt;">            Class&lt;?&gt; k = FutureTask.class;</font></div><div><font style="font-size: 12pt;">            stateOffset = UNSAFE.objectFieldOffset</font></div><div><font style="font-size: 12pt;">                (k.getDeclaredField(&quot;state&quot;));</font></div><div><font style="font-size: 12pt;">            runnerOffset = UNSAFE.objectFieldOffset</font></div><div><font style="font-size: 12pt;">                (k.getDeclaredField(&quot;runner&quot;));</font></div><div><font style="font-size: 12pt;">            waitersOffset = UNSAFE.objectFieldOffset</font></div><div><font style="font-size: 12pt;">                (k.getDeclaredField(&quot;waiters&quot;));</font></div><div><font style="font-size: 12pt;">        } catch (Exception e) {</font></div><div><font style="font-size: 12pt;">            throw new Error(e);</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>八.执行服务的抽象实现AbstractExecutorService</b></font></div><div><font style="font-size: 12pt;">   该类实现自ExecutorService的大部分方法，但未实现核心的几个execute,shutdown等方法，源码如下：</font></div><div><font style="font-size: 12pt;">   public abstract class AbstractExecutorService implements ExecutorService {</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //包装runnable形成一个具体的执行任务</font></div><div><font style="font-size: 12pt;">    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {</font></div><div><font style="font-size: 12pt;">        return new FutureTask&lt;T&gt;(runnable, value);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //包装callable 形成一个具体的执行任务</font></div><div><font style="font-size: 12pt;">    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {</font></div><div><font style="font-size: 12pt;">        return new FutureTask&lt;T&gt;(callable);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //提交Runnable任务</font></div><div><font style="font-size: 12pt;">    public Future&lt;?&gt; submit(Runnable task) {</font></div><div><font style="font-size: 12pt;">        if (task == null) throw new NullPointerException();</font></div><div><font style="font-size: 12pt;">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);</font></div><div><font style="font-size: 12pt;">        execute(ftask);</font></div><div><font style="font-size: 12pt;">        return ftask;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //提交runable任务</font></div><div><font style="font-size: 12pt;">    public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {</font></div><div><font style="font-size: 12pt;">        if (task == null) throw new NullPointerException();</font></div><div><font style="font-size: 12pt;">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</font></div><div><font style="font-size: 12pt;">        execute(ftask);</font></div><div><font style="font-size: 12pt;">        return ftask;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //提交callable任务</font></div><div><font style="font-size: 12pt;">    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {</font></div><div><font style="font-size: 12pt;">        if (task == null) throw new NullPointerException();</font></div><div><font style="font-size: 12pt;">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</font></div><div><font style="font-size: 12pt;">        execute(ftask);</font></div><div><font style="font-size: 12pt;">        return ftask;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //invokeany的核心</font></div><div><font style="font-size: 12pt;">    private &lt;T&gt; T doInvokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</font></div><div><font style="font-size: 12pt;">                              boolean timed, long nanos)</font></div><div><font style="font-size: 12pt;">        throws InterruptedException, ExecutionException, TimeoutException {</font></div><div><font style="font-size: 12pt;">       .....使用ExecutorCompletionService实现直到一个任务执行完成就返回的逻辑</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">      //批量执行任务，直到一个任务执行完成</font></div><div><font style="font-size: 12pt;">    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</font></div><div><font style="font-size: 12pt;">        throws InterruptedException, ExecutionException {</font></div><div><font style="font-size: 12pt;">        try {</font></div><div><font style="font-size: 12pt;">            return doInvokeAny(tasks, false, 0);</font></div><div><font style="font-size: 12pt;">        } catch (TimeoutException cannotHappen) {</font></div><div><font style="font-size: 12pt;">            assert false;</font></div><div><font style="font-size: 12pt;">            return null;</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //批量执行任务，直到一个任务执行完成 带超时</font></div><div><font style="font-size: 12pt;">    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</font></div><div><font style="font-size: 12pt;">                           long timeout, TimeUnit unit)</font></div><div><font style="font-size: 12pt;">        throws InterruptedException, ExecutionException, TimeoutException {</font></div><div><font style="font-size: 12pt;">        return doInvokeAny(tasks, true, unit.toNanos(timeout));</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //批量执行任务，直到全部运行完成</font></div><div><font style="font-size: 12pt;">    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</font></div><div><font style="font-size: 12pt;">        throws InterruptedException {</font></div><div><font style="font-size: 12pt;">      ......</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //批量执行任务，直到全部运行完成，带超时机制</font></div><div><font style="font-size: 12pt;">    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</font></div><div><font style="font-size: 12pt;">                                         long timeout, TimeUnit unit)</font></div><div><font style="font-size: 12pt;">        throws InterruptedException {</font></div><div><font style="font-size: 12pt;">      ......</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>九.线程池核心ThreadPoolExecutor</b></font></div><div><font style="font-size: 12pt;">   该类继承自AbstractExecutorService,实现了所有的抽象方法，是线程池核心中的核心</font></div><div><font style="font-size: 12pt;">   public class ThreadPoolExecutor extends AbstractExecutorService {</font></div><div><font style="font-size: 12pt;">     .......</font></div><div><font style="font-size: 12pt;">   }</font></div><div><font style="font-size: 12pt;">   源码解析：<a href="https://user.qzone.qq.com/834171100/blog/1503996829">https://user.qzone.qq.com/834171100/blog/1503996829</a></font></div><div><font style="font-size: 12pt;">   几个重要参数：</font></div><div><font style="font-size: 12pt;">   1.corePoolSize：线程池核心线程数，默认情况下，核心线程会在线程池中一直存活，即使它们处于闲置状态。如果ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true,那么闲置的核心线程在等待新任务到来时会有超时策略，这个时间间隔由keepAliveTime所指定的时长后，核心线程就会被终止。</font></div><div><font style="font-size: 12pt;">   2.maximumPoolSize：线程池所能容纳的最大线程数，当活动线程达到这个数值后，后续的新任务将被阻塞。</font></div><div><font style="font-size: 12pt;">   3.keepAliveTime：非核心线程闲置时的超时时长，超过这个时长，非核心线程就会被回收。当ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true时，keepAliveTime同样会作用于核心线程。</font></div><div><font style="font-size: 12pt;">   4.unit：keepAliveTime 参数的时间单位。</font></div><div><font style="font-size: 12pt;">   5.workQueue：执行前用于保持任务的队列。此队列仅保持由 execute 方法提交的 Runnable 任务。</font></div><div><font style="font-size: 12pt;">   6.threadFactory：执行程序创建新线程时使用的工厂。</font></div><div><font style="font-size: 12pt;">   7.handler：由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">十.任务执行服务的工程和辅助方法类Executors</font></div><div><font style="font-size: 12pt;">   暂时只看几个工厂方法：</font></div><div><font style="font-size: 12pt;">   public class Executors {</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //固定线程数量的执行服务</font></div><div><font style="font-size: 12pt;">    public static ExecutorService newFixedThreadPool(int nThreads) {</font></div><div><font style="font-size: 12pt;">        return new ThreadPoolExecutor(nThreads, nThreads,</font></div><div><font style="font-size: 12pt;">                                      0L, TimeUnit.MILLISECONDS,</font></div><div><font style="font-size: 12pt;">                                      new LinkedBlockingQueue&lt;Runnable&gt;());</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //基于工作窃取原理的任务执行服务（fork-join） parallelism是线程数量</font></div><div><font style="font-size: 12pt;">    public static ExecutorService newWorkStealingPool(int parallelism) {</font></div><div><font style="font-size: 12pt;">        return new ForkJoinPool</font></div><div><font style="font-size: 12pt;">            (parallelism,</font></div><div><font style="font-size: 12pt;">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</font></div><div><font style="font-size: 12pt;">             null, true);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //基于工作窃取原理的任务执行服务（fork-join） 线程数量等于cpu核数</font></div><div><font style="font-size: 12pt;">    public static ExecutorService newWorkStealingPool() {</font></div><div><font style="font-size: 12pt;">        return new ForkJoinPool</font></div><div><font style="font-size: 12pt;">            (Runtime.getRuntime().availableProcessors(),</font></div><div><font style="font-size: 12pt;">             ForkJoinPool.defaultForkJoinWorkerThreadFactory,</font></div><div><font style="font-size: 12pt;">             null, true);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //固定线程数量的执行服务</font></div><div><font style="font-size: 12pt;">    public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {</font></div><div><font style="font-size: 12pt;">        return new ThreadPoolExecutor(nThreads, nThreads,</font></div><div><font style="font-size: 12pt;">                                      0L, TimeUnit.MILLISECONDS,</font></div><div><font style="font-size: 12pt;">                                      new LinkedBlockingQueue&lt;Runnable&gt;(),</font></div><div><font style="font-size: 12pt;">                                      threadFactory);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //单线程的任务执行服务</font></div><div><font style="font-size: 12pt;">    public static ExecutorService newSingleThreadExecutor() {</font></div><div><font style="font-size: 12pt;">        return new FinalizableDelegatedExecutorService</font></div><div><font style="font-size: 12pt;">            (new ThreadPoolExecutor(1, 1,</font></div><div><font style="font-size: 12pt;">                                    0L, TimeUnit.MILLISECONDS,</font></div><div><font style="font-size: 12pt;">                                    new LinkedBlockingQueue&lt;Runnable&gt;()));</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //单线程的执行服务</font></div><div><font style="font-size: 12pt;">    public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {</font></div><div><font style="font-size: 12pt;">        return new FinalizableDelegatedExecutorService</font></div><div><font style="font-size: 12pt;">            (new ThreadPoolExecutor(1, 1,</font></div><div><font style="font-size: 12pt;">                                    0L, TimeUnit.MILLISECONDS,</font></div><div><font style="font-size: 12pt;">                                    new LinkedBlockingQueue&lt;Runnable&gt;(),</font></div><div><font style="font-size: 12pt;">                                    threadFactory));</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">   //工作线程带缓存的任务执行服务 只是最大数量设置为了Integer.MAX_VALUE，以及过期时间设置长了而已</font></div><div><font style="font-size: 12pt;">    public static ExecutorService newCachedThreadPool() {</font></div><div><font style="font-size: 12pt;">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</font></div><div><font style="font-size: 12pt;">                                      60L, TimeUnit.SECONDS,</font></div><div><font style="font-size: 12pt;">                                      new SynchronousQueue&lt;Runnable&gt;());</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">     //工作线程带缓存的任务执行服务 只是最大数量设置为了Integer.MAX_VALUE，以及过期时间设置长了而已</font></div><div><font style="font-size: 12pt;">    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {</font></div><div><font style="font-size: 12pt;">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</font></div><div><font style="font-size: 12pt;">                                      60L, TimeUnit.SECONDS,</font></div><div><font style="font-size: 12pt;">                                      new SynchronousQueue&lt;Runnable&gt;(),</font></div><div><font style="font-size: 12pt;">                                      threadFactory);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //单线程的定时任务执行服务</font></div><div><font style="font-size: 12pt;">    public static ScheduledExecutorService newSingleThreadScheduledExecutor() {</font></div><div><font style="font-size: 12pt;">        return new DelegatedScheduledExecutorService</font></div><div><font style="font-size: 12pt;">            (new ScheduledThreadPoolExecutor(1));</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //单线程的定时任务执行服务</font></div><div><font style="font-size: 12pt;">    public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory) {</font></div><div><font style="font-size: 12pt;">        return new DelegatedScheduledExecutorService</font></div><div><font style="font-size: 12pt;">            (new ScheduledThreadPoolExecutor(1, threadFactory));</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //定时任务执行服务</font></div><div><font style="font-size: 12pt;">    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {</font></div><div><font style="font-size: 12pt;">        return new ScheduledThreadPoolExecutor(corePoolSize);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    //定时任务执行服务</font></div><div><font style="font-size: 12pt;">    public static ScheduledExecutorService newScheduledThreadPool(</font></div><div><font style="font-size: 12pt;">            int corePoolSize, ThreadFactory threadFactory) {</font></div><div><font style="font-size: 12pt;">        return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    ......</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>十一.用于批量任务执行管理的CompletionService和ExecutorCompletionService</b></font></div><div><font style="font-size: 12pt;">    CompletionService接口定义了一组带相同返回值的任务的管理接口,可以最快的获取这些批量任务的执行结果，ExecutorService.invokeAny就使用了这个技术！</font></div><div><font style="font-size: 12pt;">    源码如下：</font></div><div><font style="font-size: 12pt;">    public interface CompletionService&lt;V&gt; {</font></div><div><font style="font-size: 12pt;">        //提交任务</font></div><div><font style="font-size: 12pt;">        Future&lt;V&gt; submit(Callable&lt;V&gt; task);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">        //提交任务</font></div><div><font style="font-size: 12pt;">        Future&lt;V&gt; submit(Runnable task, V result);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">        //获取一个执行结果（并移除） 阻塞</font></div><div><font style="font-size: 12pt;">        Future&lt;V&gt; take() throws InterruptedException;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">        //获取一个执行结果（并移除） 不阻塞</font></div><div><font style="font-size: 12pt;">        Future&lt;V&gt; poll();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">        //获取一个执行结果（并移除） 带超时</font></div><div><font style="font-size: 12pt;">        Future&lt;V&gt; poll(long timeout, TimeUnit unit) throws InterruptedException;</font></div><div><font style="font-size: 12pt;">     }</font></div><div><font style="font-size: 12pt;">    ExecutorCompletionService类是CompletionService接口的实现</font></div><div><font style="font-size: 12pt;">    ExecutorCompletionService内部管理者一个已完成任务的阻塞队列，其引用了一个Executor用来执行任务，submit()方法最终会委托给内部的executor去执行任务，take/poll方法的工作都委托给内部的已完成任务阻塞队列</font></div><div><font style="font-size: 12pt;">    如果阻塞队列中有已完成的任务, take方法就返回任务的结果, 否则阻塞等待任务完成</font></div><div><font style="font-size: 12pt;">    源码如下：</font></div><div><font style="font-size: 12pt;">    public class ExecutorCompletionService&lt;V&gt; implements CompletionService&lt;V&gt; {</font></div><div><font style="font-size: 12pt;">            //被包装Executor</font></div><div><font style="font-size: 12pt;">            private final Executor executor;</font></div><div><font style="font-size: 12pt;">            //如果executor是AbstractExecutorService就为它</font></div><div><font style="font-size: 12pt;">            private final AbstractExecutorService aes;</font></div><div><font style="font-size: 12pt;">            //完成任务的阻塞队列</font></div><div><font style="font-size: 12pt;">            private final BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">            /**</font></div><div><font style="font-size: 12pt;">             * 扩展FutureTask，重写了其done方法用于将完成任务放置在阻塞队列！！！</font></div><div><font style="font-size: 12pt;">             */</font></div><div><font style="font-size: 12pt;">            private class QueueingFuture extends FutureTask&lt;Void&gt; {</font></div><div><font style="font-size: 12pt;">                QueueingFuture(RunnableFuture&lt;V&gt; task) {</font></div><div><font style="font-size: 12pt;">                    super(task, null);</font></div><div><font style="font-size: 12pt;">                    this.task = task;</font></div><div><font style="font-size: 12pt;">                }</font></div><div><font style="font-size: 12pt;">                protected void done() { completionQueue.add(task); }</font></div><div><font style="font-size: 12pt;">                private final Future&lt;V&gt; task;</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">            //包装callable</font></div><div><font style="font-size: 12pt;">            private RunnableFuture&lt;V&gt; newTaskFor(Callable&lt;V&gt; task) {</font></div><div><font style="font-size: 12pt;">                if (aes == null)</font></div><div><font style="font-size: 12pt;">                    return new FutureTask&lt;V&gt;(task);</font></div><div><font style="font-size: 12pt;">                else</font></div><div><font style="font-size: 12pt;">                    return aes.newTaskFor(task);</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">            //包装Runnable</font></div><div><font style="font-size: 12pt;">            private RunnableFuture&lt;V&gt; newTaskFor(Runnable task, V result) {</font></div><div><font style="font-size: 12pt;">                if (aes == null)</font></div><div><font style="font-size: 12pt;">                    return new FutureTask&lt;V&gt;(task, result);</font></div><div><font style="font-size: 12pt;">                else</font></div><div><font style="font-size: 12pt;">                    return aes.newTaskFor(task, result);</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">            </font></div><div><font style="font-size: 12pt;">            public ExecutorCompletionService(Executor executor) {</font></div><div><font style="font-size: 12pt;">                if (executor == null)</font></div><div><font style="font-size: 12pt;">                    throw new NullPointerException();</font></div><div><font style="font-size: 12pt;">                this.executor = executor;</font></div><div><font style="font-size: 12pt;">                this.aes = (executor instanceof AbstractExecutorService) ?</font></div><div><font style="font-size: 12pt;">                    (AbstractExecutorService) executor : null;</font></div><div><font style="font-size: 12pt;"><a href="http://this.completionqueue/">this.completionQueue</a> = new LinkedBlockingQueue&lt;Future&lt;V&gt;&gt;();</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">           </font></div><div><font style="font-size: 12pt;">            public ExecutorCompletionService(Executor executor,</font></div><div><font style="font-size: 12pt;">                                             BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue) {</font></div><div><font style="font-size: 12pt;">                if (executor == null || completionQueue == null)</font></div><div><font style="font-size: 12pt;">                    throw new NullPointerException();</font></div><div><font style="font-size: 12pt;">                this.executor = executor;</font></div><div><font style="font-size: 12pt;">                this.aes = (executor instanceof AbstractExecutorService) ?</font></div><div><font style="font-size: 12pt;">                    (AbstractExecutorService) executor : null;</font></div><div><font style="font-size: 12pt;"><a href="http://this.completionqueue/">this.completionQueue</a> = completionQueue;</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">            //提交任务</font></div><div><font style="font-size: 12pt;">            public Future&lt;V&gt; submit(Callable&lt;V&gt; task) {</font></div><div><font style="font-size: 12pt;">                if (task == null) throw new NullPointerException();</font></div><div><font style="font-size: 12pt;">                RunnableFuture&lt;V&gt; f = newTaskFor(task);</font></div><div><font style="font-size: 12pt;">                executor.execute(new QueueingFuture(f));</font></div><div><font style="font-size: 12pt;">                return f;</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">            //提交任务</font></div><div><font style="font-size: 12pt;">            public Future&lt;V&gt; submit(Runnable task, V result) {</font></div><div><font style="font-size: 12pt;">                if (task == null) throw new NullPointerException();</font></div><div><font style="font-size: 12pt;">                RunnableFuture&lt;V&gt; f = newTaskFor(task, result);</font></div><div><font style="font-size: 12pt;">                executor.execute(new QueueingFuture(f));</font></div><div><font style="font-size: 12pt;">                return f;</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">            //获取结果带阻塞</font></div><div><font style="font-size: 12pt;">            public Future&lt;V&gt; take() throws InterruptedException {</font></div><div><font style="font-size: 12pt;">                return completionQueue.take();</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">             //获取结果</font></div><div><font style="font-size: 12pt;">            public Future&lt;V&gt; poll() {</font></div><div><font style="font-size: 12pt;">                return completionQueue.poll();</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">            //获取结果 带超时</font></div><div><font style="font-size: 12pt;">            public Future&lt;V&gt; poll(long timeout, TimeUnit unit)</font></div><div><font style="font-size: 12pt;">                    throws InterruptedException {</font></div><div><font style="font-size: 12pt;">                return completionQueue.poll(timeout, unit);</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">       ExecutorCompletionService主要用与管理一组带相同返回结果类型的异步任务 (有结果的任务, 任务完成后要处理结果)</font></div><div><font style="font-size: 12pt;">       more:<a href="https://user.qzone.qq.com/834171100/blog/1516002218">https://user.qzone.qq.com/834171100/blog/1516002218</a></font></div><div><br/></div></span>
</div></body></html> 