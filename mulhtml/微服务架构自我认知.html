<html>
<head>
  <title>微服务架构自我认知</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1658"/>
<h1>微服务架构自我认知</h1>

<div>
<span><div><h1 style="box-sizing: border-box; margin: 0px 0px 15px; text-rendering: optimizeLegibility;"><font style="font-size: 18pt; color: rgb(20, 113, 145);">微服务架构介绍</font><br/></h1><div style="box-sizing: border-box; margin: 0px 0px 25px; word-break: break-word !important;"><font style="font-size: 12pt;"><span style="box-sizing: border-box; word-break: break-word !important;">微服务架构（Microservice Architecture）是一种架构概念，</span>旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦，将功能分解到离散的各个服务当中，从而降低系统的耦合性，并提供更加灵活的服务支持。</font></div><h1 style="box-sizing: border-box; margin: 0px 0px 15px; text-rendering: optimizeLegibility;"><span style="box-sizing: border-box; text-rendering: optimizeLegibility;"><span style="font-weight: bold; line-height: 1.7;"><font style="font-size: 14pt;">传统开发模式和微服务的区别</font></span></span></h1><h2 style="box-sizing: border-box; margin: 0px 0px 15px; text-rendering: optimizeLegibility;"><span style="box-sizing: border-box; text-rendering: optimizeLegibility;"><span style="line-height: 1.7;"><font style="font-size: 12pt;">优点</font></span></span></h2><ul style="box-sizing: border-box; margin: -5px 0px 20px 20px; padding: 0px; word-break: break-word !important;"><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">开发简单，集中式管理</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">基本不会重复开发</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">功能都在本地，没有分布式的管理和调用消耗</font></span></li></ul><h2 style="box-sizing: border-box; margin: 0px 0px 15px; text-rendering: optimizeLegibility;"><span style="box-sizing: border-box; text-rendering: optimizeLegibility;"><span style="font-weight: bold; line-height: 1.7;"><font style="font-size: 12pt;">缺点</font></span></span></h2><ol style="box-sizing: border-box; margin: -5px 0px 20px 20px; word-break: break-word !important; padding: 0px;"><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">效率低：开发都在同一个项目改代码，相互等待，冲突不断</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">维护难：代码功功能耦合在一起，新人不知道何从下手</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">不灵活：构建时间长，任何小修改都要重构整个项目，耗时</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">稳定性差：一个微小的问题，都可能导致整个应用挂掉</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">扩展性不够：无法满足高并发下的业务需求</font></span></li></ol><h1 style="box-sizing: border-box; margin: 0px 0px 15px; text-rendering: optimizeLegibility;"><span style="box-sizing: border-box; text-rendering: optimizeLegibility;"><span style="font-weight: bold; line-height: 1.7;"><font style="font-size: 14pt;">微服务架构特征</font></span></span></h1><h2 style="box-sizing: border-box; margin: 0px 0px 15px; text-rendering: optimizeLegibility;"><span style="box-sizing: border-box; text-rendering: optimizeLegibility;"><span style="font-weight: bold; line-height: 1.7;"><font style="font-size: 12pt;">官方的定义</font></span></span></h2><ol style="box-sizing: border-box; margin: -5px 0px 20px 20px; word-break: break-word !important; padding: 0px;"><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">一系列的独立的服务共同组成系统</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">单独部署，跑在自己的进程中</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">每个服务为独立的业务开发</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">分布式管理</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">非常强调隔离性</font></span></li></ol><h2 style="box-sizing: border-box; margin: 0px 0px 15px; text-rendering: optimizeLegibility;"><span style="box-sizing: border-box; text-rendering: optimizeLegibility;"><span style="font-weight: bold; line-height: 1.7;"><font style="font-size: 12pt;">大概的标准</font></span></span></h2><ol style="box-sizing: border-box; margin: -5px 0px 20px 20px; word-break: break-word !important; padding: 0px;"><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">分布式服务组成的系统</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">按照业务，而不是技术来划分组织</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">做有生命的产品而不是项目</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">强服务个体和弱通信（ Smart endpoints and dumb pipes ）</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">自动化运维（ DevOps ）</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">高度容错性</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">快速演化和迭代</font></span></li></ol><h1 style="box-sizing: border-box; margin: 0px 0px 15px; text-rendering: optimizeLegibility;"><span style="box-sizing: border-box; text-rendering: optimizeLegibility;"><span style="font-weight: bold; line-height: 1.7;"><font style="font-size: 12pt;">SOA和微服务的区别</font></span></span></h1><ul style="box-sizing: border-box; margin: -5px 0px 20px 20px; padding: 0px; word-break: break-word !important;"><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">SOA喜欢重用，微服务喜欢重写</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">SOA喜欢水平服务，微服务喜欢垂直服务</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">SOA喜欢自上而下，微服务喜欢自下而上</font></span></li></ul><h1 style="box-sizing: border-box; margin: 0px 0px 15px; text-rendering: optimizeLegibility;"></h1><h1><font style="font-size: 18pt; color: rgb(20, 113, 145);">微服务架构当中的多个要素</font></h1><div><font style="font-size: 12pt;">1.服务注册、服务发现和变更下发(Eureka、ZooKeeper等)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">2.服务与服务之间的调用方式（同步、异步、REST、RPC、Dubbo、消息队列......）</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">3.客户端对服务的访问方式(包括直接访问和API Gateway，API Gateway可以实现权限控制、负载均衡和错误转移)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">4.数据的去中心化管理（完全隔离的业务数据库+中心数据库的架构）</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">5.权限的中心化管理（Redis+spring-security oauth、SSO）</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">6.使用分布式事务、分布式锁或TICKET幂等保证并发安全</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">7.中间件（消息队列、RPC、读写分离中间件、分库分表中间件、缓存中间件、权限认证中间件、分布式session......）</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">8.高效缓存（一致性哈希）</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">9.负载均衡、故障转移和服务熔断机制（Ribbion&amp;Feign、Hytrix）</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">10.服务监控和服务管理（dubbo和spring cloud两套体系都提供了自己的服务监控和管理平台）</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">11.日志监控和日志管理（Logstash + kibana+ElasticSearch）</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">12.devops(自动化运维）</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">13.持续集成部署（K8S &amp; Docker）</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">.......</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">注意：java界当中，微服务架构的两大典型框架是dubbo和spring cloud。可以通过学习这两个框架，从而掌握微服务-分布式架构中的多个点</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">在这儿挑几个重要的讲讲</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12pt;">1.服务注册、服务发现和变更下发</font></span></div><div><font style="font-size: 12pt;">  <font>服务注册、服务发现和服务的变更下发是服务治理的基本功能。</font></font></div><div><font style="font-size: 12pt;">  要想实现这种功能，必须进行服务配置信息的存储、协同等工作。</font></div><div><font style="font-size: 12pt;">  好在已经有两款著名的分布式协作框架可以帮助我们构建，那就是ZooKeeper和Eureka。</font></div><div><font style="font-size: 12pt;">  更一般的情况，我们直接使用Dubbo或者spring cloud，通过简单配置，我们就能够直接享受这种功能。</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12pt;">2.服务与服务之间的调用方式</font></span></div><div><font style="font-size: 12pt;">   服务于服务之间的调用方式按照等待方式可以分为两种：</font></div><div><font style="font-size: 12pt;">  同步：REST API和大部分的RPC框架，前者以spring cloud为典型，后者以dubbo为典型。</font></div><div><font style="font-size: 12pt;">  异步：消息队列（RabbitMQ）或者CRON(Elastic-Job），spring cloud对这两者都有很好的框架性支持，dubbo只能手动集成第三方。</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  严格的说，按照Marting Flower对微服务的描述，服务与服务之间、服务和客户端之间同步调用都应该采用REST API通讯。</font></div><div><font style="font-size: 12pt;">  </font></div><div><font style="font-size: 12pt;"><span style="font-weight: bold;">3.客户端对服务</span><span style="font-weight: bold;">的</span><span style="font-weight: bold;">访问方式</span></font></div><div><font style="font-size: 12pt;">  <font>第一种方式是客户端直接调用服务，现在已经不常用了，如下：</font></font></div><div><font style="font-size: 12pt;"><img src="微服务架构自我认知_files/Image.png" type="image/png" data-filename="Image.png"/></font></div><div><font style="font-size: 12pt;">  第二种方式是<span style="box-sizing: border-box; word-break: break-word !important;">在后台N个服务和UI之间一般会有一个代理或者叫API Gateway，如下图所示：</span></font></div><div><font style="font-size: 12pt;"><img src="微服务架构自我认知_files/Image [1].png" type="image/png" data-filename="Image.png"/></font></div><div><font style="font-size: 12pt;"><span style="box-sizing: border-box; word-break: break-word !important;"><span style="box-sizing: border-box; word-break: break-word !important;">  API Gateway的作用：</span></span></font></div><ul style="box-sizing: border-box; margin: -5px 0px 20px 20px; padding: 0px; word-break: break-word !important;"><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">提供统一服务入口，让微服务对前台透明</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">聚合后台的服务，节省流量，提升性能</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">提供中心化的安全认证，请求过滤，流控等API管理功能</font></span></li><li style="box-sizing: border-box;"><font style="font-size: 12pt;">在Gateway处可以很方便的实现负载均衡和故障转移。</font></li></ul><font style="font-size: 12pt;">  spring cloud直接集成了Netflix的Zuul来实现API网关，dubbo一般是需要通过框架集成RPC，再对外转换为REST接口，然后才能使用相关网关技术。</font></div><div><font style="font-size: 12pt;"><br/></font><div><span style="font-weight: bold;"><font style="font-size: 12pt;">4.数据的去中心化管理</font></span></div><div style="margin: 0px; padding: 0px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); font-family: Arial, sans-serif;"><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-family: Arial, sans-serif;"><font style="font-size: 12pt;">单体架构中，不同功能的服务模块都把数据存储在某个中心数据库中,如下：</font></span></div><div style="margin: 0px; padding: 0px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-family: Arial, sans-serif;"><a href="https://blogcdn.maxleap.cn/wp-content/uploads/2016/03/1-7.png"><font color="#000000" style="font-size: 12pt;"><img src="微服务架构自我认知_files/Image [2].png" type="image/png" data-filename="Image.png" style="margin: 0px 2px; padding: 0px; border-width: 0px; border-style: none; vertical-align: top; cursor: pointer; display: block; max-width: none;" width="400"/></font></a></div><div style="margin: 0px; padding: 0px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-family: Arial, sans-serif;"><font style="font-size: 12pt;">微服务方式，多个服务之间的设计相互独立，数据也应该相互独立（比如，某个微服务的数据库结构定义方式改变，可能会中断其它服务），因此，每个微服务都应该有自己的私有业务数据库，也可能会有公共的中心数据库。<br/></font></div><div style="margin: 0px; padding: 0px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); font-family: Arial, sans-serif;"><a href="https://blogcdn.maxleap.cn/wp-content/uploads/2016/03/1_8.png"><font color="#000000" style="font-size: 12pt;"><img src="微服务架构自我认知_files/Image [3].png" type="image/png" data-filename="Image.png" style="margin: 0px 2px; padding: 0px; border-width: 0px; border-style: none; vertical-align: top; cursor: pointer; display: block; max-width: none;" width="400"/></font></a></div><div style="margin: 0px; padding: 0px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); font-family: Arial, sans-serif;"><span style="font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-family: Arial, sans-serif;"><font style="font-size: 12pt;">数据去中心化的核心要点：</font></span></div><ul style="margin: 10px 0px 0px; padding: 0px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); font-family: Arial, sans-serif;"><li style="margin: 0px 0px 0px 40px; padding: 0px; list-style: disc;"><font style="font-size: 12pt;">每个微服务有自己私有的数据库持久化业务数据</font></li><li style="margin: 0px 0px 0px 40px; padding: 0px; list-style: disc;"><font style="font-size: 12pt;">每个微服务只能访问自己的数据库和中心数据库，而不能访问其它服务的数据库</font></li><li style="margin: 0px 0px 0px 40px; padding: 0px; list-style: disc;"><font style="font-size: 12pt;">某些业务场景下，需要在一个事务中更新多个数据库。这种情况也不能直接访问其它微服务的数据库，而是通过对于微服务进行操作。</font></li></ul><div><span style="font-family: Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 12pt;">数据的去中心化，进一步降低了微服务之间的耦合度，不同服务可以采用不同的数据库技术（SQL、NoSQL等）。</font></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12pt;">5.权限的中心化管理</font></span></div><div><span style="font-size: 16px;">用户认证和资源授权是应用系统中不得不谈论的话题，对于微服务系统，因为系统多而细，因此必须要使用中心化的权限认证管理。</span></div><div><span style="font-size: 16px;">一般而言有如下两种方案：</span></div><div><span style="font-size: 16px;">（1）基于spring security oauth2的token认证，使用Redis作为token存储介质。</span></div><div><span style="font-size: 16px;">（2）SSO登录。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12pt;">6.使用分布式事务、分布式锁或TICKET幂等保证并发和数据安全</font></span></div><div><font style="font-size: 12pt;"> 分布式事务相关链接：</font></div><div>  <a href="Spring的分布式事务实现.html" style="color: #69aa35; font-size: 12pt;">Spring的分布式事务实现</a></div><div>  <a href="聊聊分布式事务，再说说解决方案.html" style="color: #69aa35; font-size: 12pt;">聊聊分布式事务，再说说解决方案</a></div><div>  <a href="分布式事务 TCC-Transaction 源码分析 —— TCC 实现.html" style="color: #69aa35; font-size: 12pt;">分布式事务 TCC-Transaction 源码分析 —— TCC 实现</a></div><div><font style="font-size: 12pt;"> 分布式锁相关链接：</font></div><div><span style="font-size: 16px;"> </span><a href="分布式锁之三种分布式锁实现.html" style="color: #69aa35; font-size: 12pt;">分布式锁之三种分布式锁实现</a></div><div> <a href="分布式锁之zookeeper的分布式锁实现（多种）.html" style="color: #69aa35; font-size: 12pt;">分布式锁之zookeeper的分布式锁实现（多种）</a></div><div><font style="font-size: 12pt;"> TICKET幂等：</font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"> </span><a href="使用Ticket实现HTTP API的幂等性.html" style="color: #69aa35; font-size: 12pt;">使用Ticket实现HTTP API的幂等性</a></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12pt;">7.中间件</font></span></div><div><font style="font-size: 12pt;">   消息队列、RPC、读写分离中间件、分库分表中间件、作业中间件、缓存中间件、权限认证中间件、分布式session......）</font></div><div><font style="font-size: 12pt;">   消息队列：RabbitMQ，ApacheMQ,Kafka .....</font></div><div><font style="font-size: 12pt;">   RPC：dubbo(多种协议），Thrift，RMI，soap（webservices）等等。</font></div><div><font style="font-size: 12pt;">   读写分离中间件：sharding-jdbc</font></div><div><font style="font-size: 12pt;">   缓存中间件：Ehcache、Memory-cache、Redis</font></div><div><font style="font-size: 12pt;">   作业中间件：Elastic-job</font></div><div><font style="font-size: 12pt;">   权限认证中间件：JWT、<span style="font-size: 12pt;">spring security</span><span style="font-size: 12pt;"> 、</span>spring security oauth</font></div><div><font style="font-size: 12pt;">    分布式Session：Session同步、粘性Session、基于缓存服务器的session共享，如下图所示：</font></div><div><img src="微服务架构自我认知_files/Image [4].png" type="image/png" data-filename="Image.png" style="font-size: 12pt;"/></div><div><span style="font-weight: bold;"><font style="font-size: 12pt;">8.高效缓存</font></span></div><div><font style="font-size: 12pt;">  一致性哈希具有单调性，可以避免服务器变更对缓存的影响，还可以通过使用虚拟机节点调节每台物理缓存机器所承受的权重。</font></div><div><font style="font-size: 12pt;">  参考： <a href="一致性哈希算法.html" style="color: #69aa35; font-size: 12pt;">一致性哈希算法</a></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-weight: bold;">9.</span><span style="font-weight: bold;">负载均衡、故障转移和</span><span style="font-weight: bold;">服务熔断机制</span></font></div><div><font style="font-size: 12pt;">  负载均衡： <a href="Spring Cloud 使用 Ribbon 和 Feign做负载均衡.html" style="color: #69aa35; font-size: 12pt;">Spring Cloud 使用 Ribbon 和 Feign做负载均衡</a></font></div><div><font style="font-size: 12pt;">  故障转移：待总结</font></div><div><font style="font-size: 12pt;">  服务熔断： <a href="Spring Cloud熔断器 Hystrix.html" style="color: #69aa35; font-size: 12pt;">Spring Cloud熔断器 Hystrix</a></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12pt;">10.服务监控和日志管理</font></span></div><div><font style="font-size: 12pt;"> dubbo和spring cloud两套体系都提供了自己的服务监控和管理平台</font></div><div><font style="font-size: 12pt;"> 参见： <a href="监控与管理dubbo服务.html" style="color: #69aa35; font-size: 12pt;">监控与管理dubbo服务</a></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12pt;">11.日志监控和日志管理</font></span></div><div><font style="font-size: 12pt;">    日志监控和日志管理一方面是可以通过日志监视和统计微服务系统中各个组件的健康状态，统计bug数量等等</font></div><div><font style="font-size: 12pt;">    另外一个方面是基于全文搜索，可以给开发人员提供一个中心化的日志查看和搜索平台，从而提高开发和维护效率。</font></div><div><font style="font-size: 12pt;">    经典Logstash + kibana+ElasticSearch：</font></div><div><font style="font-size: 12pt;">    参考： <a href="基于ElasticSearch+Logstash+Kibana的日志监控平台.html" style="color: rgb(0, 0, 0);">基于ElasticSearch+Logstash+Kibana的日志监控平台</a></font></div><div><font style="font-size: 12pt;">  </font></div><h1 style="box-sizing: border-box; margin: 0px 0px 15px; text-rendering: optimizeLegibility;"><span style="box-sizing: border-box; text-rendering: optimizeLegibility;"><span style="font-weight: bold; line-height: 1.7;"><font style="color: rgb(20, 113, 145); font-size: 18pt;">微服务架构的优缺点</font></span></span></h1><ul style="box-sizing: border-box; margin: -5px 0px 20px 20px; padding: 0px; word-break: break-word !important;"><li style="box-sizing: border-box;"><font style="font-size: 12pt;"><span style="line-height: 30px;"><b>优点</b></span><br/><span style="line-height: 30px;">复杂度可控，独立按需扩展，技术选型灵活，容错，可用性高</span></font></li><li style="box-sizing: border-box;"><font style="font-size: 12pt;"><span style="line-height: 30px;"><b>缺点</b></span><br/><span style="line-height: 30px;">多服务运维难度，系统部署依赖，服务间通信成本，数据一致性，系统集成测试，重复工作，性能监控等</span></font></li></ul><h1 style="box-sizing: border-box; margin: 0px 0px 15px; text-rendering: optimizeLegibility;"><span style="box-sizing: border-box; text-rendering: optimizeLegibility;"><span style="font-weight: bold; line-height: 1.7;"><font style="color: rgb(20, 113, 145); font-size: 18pt;">微服务架构的思考</font></span></span></h1><div style="box-sizing: border-box; margin: 0px 0px 25px; word-break: break-word !important;"><span style="box-sizing: border-box; word-break: break-word !important;"><font style="font-size: 12pt;">微服务对我们的思考，更多的是思维上的转变。对于微服务架构：技术上不是问题，意识比工具重要。</font></span></div><div style="box-sizing: border-box; margin: 0px 0px 25px; word-break: break-word !important;"><span style="box-sizing: border-box; word-break: break-word !important;"><font style="font-size: 12pt;">关于微服务的几点设计出发点：</font></span></div><ol style="box-sizing: border-box; margin: -5px 0px 20px 20px; word-break: break-word !important; padding: 0px;"><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">应用程序的核心是业务逻辑，按照业务或客户需求组织资源（这是最难的）</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">做有生命的产品，而不是项目</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">头狼战队，全栈化</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">后台服务贯彻Single Responsibility Principle（单一职责原则）</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">VM-&gt;Docker （to PE）</font></span></li><li style="box-sizing: border-box;"><span style="line-height: 30px;"><font style="font-size: 12pt;">DevOps (to PE)</font></span></li></ol><div style="box-sizing: border-box; margin: 0px 0px 25px; word-break: break-word !important;"><span style="font-size: 12pt;">最后，一般提到微服务都离不开DevOps和Docker，理解微服务架构是核心，devops和docker是工具，是手段</span><br/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 