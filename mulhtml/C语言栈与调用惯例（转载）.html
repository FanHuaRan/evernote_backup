<html>
<head>
  <title>C语言栈与调用惯例（转载）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1391"/>
<h1>C语言栈与调用惯例（转载）</h1>

<div>
<span><div><div><b><font color="#1A90B9" style="font-size: 12pt;">原文地址：<a href="http://www.cnblogs.com/Anker/p/3244857.html" style="color: rgb(26, 144, 185);">http://www.cnblogs.com/Anker/p/3244857.html</a></font></b></div><h1 style="margin: 0px 0px 10px; padding: 0px 0px 0px 5px; font-size: 15.6px; font-weight: bold; border: 0px; float: left; width: 764.938px; clear: both; line-height: 1.5; color: rgb(0, 0, 0); font-family: &quot;Helvetica Neue&quot;, Helvetica, Verdana, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><a href="http://www.cnblogs.com/Anker/p/3244857.html" style="font-size: 15.6px; font-weight: bold; border: 0px; width: 764.938px; clear: both; line-height: 1.5; color: rgb(33, 117, 155); font-family: &quot;Helvetica Neue&quot;, Helvetica, Verdana, Arial, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); outline: none;">C语言栈与调用惯例</a></h1><div style="margin: 0px; padding: 0px; clear: both; color: rgb(0, 0, 0); font-family: &quot;Helvetica Neue&quot;, Helvetica, Verdana, Arial, sans-serif; font-size: 12px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></div><div style="margin: 0px 0px 20px; padding: 0px; word-break: break-word; font-weight: bold;"><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold;">1、前言</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold;">　　最近在再看《程序员的自我修养》这本书，对程序的链接、装载与库有了更深入的认识。关于这本书的评价可以去豆瓣看看</span><a href="http://book.douban.com/subject/3652388/" style="text-indent: 0px; outline: none; color: black; font-weight: bold; text-decoration: underline;">http://book.douban.com/subject/3652388/</a><span style="text-indent: 0px; font-weight: bold;">，强烈推荐给每一位程序员哈。今天看了第十章内存，主要讲的是栈和堆的管理。主要问题是：函数在栈中是如何布局的，如何通过缓冲区溢出来调用另外一个函数，即堆栈溢出攻击。</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold;">2、基本概念</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold;">　　栈（stack）：我第一次接触栈是从数据结构中，此时的栈是一种基本数据结构，栈的基本属性是先进后出（FILO)。</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold;">　　在计算机系统中，</span><span style="text-indent: 0px; color: rgb(255, 0, 255); font-weight: bold;">栈是一个具有先进后出属性的动态内存区域</span><span style="text-indent: 0px; font-weight: bold;">。程序可以将数据压入栈，也可以将数据从栈顶弹出。</span><span style="text-indent: 0px; font-weight: bold; color: rgb(255, 0, 255);">栈的增长方向是向下增长，即由高地址向低地址方向。</span><span style="text-indent: 0px; font-weight: bold;">在i386下，esp寄存器定位栈顶，ebp寄存器定位栈底（栈指针）。esp始终指向栈顶，随着函数的执行，esp不断的变化，而ebp固定在栈底位置不变。</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold;">3、栈的作用</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold;">　　用于维护函数调用的上下文，离开了栈函数调用没法实现。栈中保存了一个函数调用所需要的维护信息，通常称为堆栈帧或活动记录。</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold;">　　</span><span style="text-indent: 0px; font-weight: bold; color: rgb(255, 0, 255);">堆栈栈包括的内容：</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold; color: rgb(255, 0, 255);">　　（1）函数的返回地址和参数</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold; color: rgb(255, 0, 255);">　　（2）临时变量</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold; color: rgb(255, 0, 255);">　　（3）保存的上下文，例如函数调用前后保持不变的寄存器。</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold;">4、函数调用过程</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold;">　　</span><span style="text-indent: 0px; font-weight: bold; color: rgb(255, 0, 255);">（1）把所有的参数压入栈</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold; color: rgb(255, 0, 255);">　　（2）把当前指令的下一条指令的地址压入栈中（函数的返回地址）[可以实现堆栈溢出攻击]</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold; color: rgb(255, 0, 255);">　　（3）跳转到函数体执行</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold;">　　　其中（2）（3）由指令call一起执行的。</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold;">例如下图所示的程序：</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><img src="https://images0.cnblogs.com/blog/305504/201308/07234525-c09da16594a942deadcaa492140128c6.png" style="margin: 0px; padding: 0px; border: 0px; max-width: 700px; font-weight: bold;"></img> <img src="https://images0.cnblogs.com/blog/305504/201308/07234525-c09da16594a942deadcaa492140128c6.png" style="font-weight: bold;"></img> <img src="https://images0.cnblogs.com/blog/305504/201308/07234525-c09da16594a942deadcaa492140128c6.png" style="font-weight: bold;"></img><img src="C语言栈与调用惯例（转载）_files/Image.png" type="image/png" data-filename="Image.png" style="font-weight: bold;"/></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold;">汇编代码如下图所示：</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><img src="https://images0.cnblogs.com/blog/305504/201308/07234553-a4c35f11dbe2447f8946a764af01f872.png" style="margin: 0px; padding: 0px; border: 0px; max-width: 700px; font-weight: bold;"></img><img src="C语言栈与调用惯例（转载）_files/Image [1].png" type="image/png" data-filename="Image.png" style="font-weight: bold;"/></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold;">5、堆栈溢出攻击</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold;">　　通过堆栈溢出改变函数的返回地址，调用另外一个过程。例如下面的程序：</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><img src="https://images0.cnblogs.com/blog/305504/201308/07235109-d68849cb79b7403c9146d3996c338771.png" style="margin: 0px; padding: 0px; border: 0px; max-width: 700px; font-weight: bold;"></img><img src="C语言栈与调用惯例（转载）_files/Image [2].png" type="image/png" data-filename="Image.png" style="font-weight: bold;"/></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold;">汇编程序如下所示：</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><img src="https://images0.cnblogs.com/blog/305504/201308/07235809-425bec2473774c578af11ca45dd1f112.png" style="margin: 0px; padding: 0px; border: 0px; max-width: 700px; font-weight: bold;"></img><img src="C语言栈与调用惯例（转载）_files/Image [3].png" type="image/png" data-filename="Image.png" style="font-weight: bold;"/></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><img src="https://images0.cnblogs.com/blog/305504/201308/07235827-8be723ccd12b4e2094343b52175531f4.png" style="margin: 0px; padding: 0px; border: 0px; max-width: 700px; font-weight: bold;"></img><img src="C语言栈与调用惯例（转载）_files/Image [4].png" type="image/png" data-filename="Image.png" style="font-weight: bold;"/></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><span style="text-indent: 0px; font-weight: bold;">程序输出结果如下所示：</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px; font-weight: bold;"><img src="https://images0.cnblogs.com/blog/305504/201308/08000034-19d5120963c04a20a0722ea1b09a09da.png" style="margin: 0px; padding: 0px; border: 0px; max-width: 700px; font-weight: bold;"></img><img src="C语言栈与调用惯例（转载）_files/Image [5].png" type="image/png" data-filename="Image.png" style="font-weight: bold;"/></div></div><div style="margin: 0px; padding: 0px; font-weight: bold;"><span style="font-weight: bold;">冷静思考，勇敢面对，把握未来！</span></div><div><br/></div></div></span>
</div></body></html> 