<html>
<head>
  <title>深入理解G1收集器</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1276"/>
<h1>深入理解G1收集器</h1>

<div>
<span><div style="margin: 0px 340px 0px 5px; padding: 39px 54.6406px 0px; border-top: 1px solid rgb(204, 204, 204);"><h3 style="margin: 0px 0px 0px -5px; font-size: 20px; background: url(&quot;img/title.gif&quot;) left 45px no-repeat; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="border-top: 1px solid rgb(204, 204, 204); color: rgb(102, 102, 102); font-family: Arial, Helvetica, sans-serif; font-size: 20px; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 28px;">深入理解G1垃圾收集器</span></h3></div><div><div style="margin: 0px 0px 1em; padding: 0px;"><span style="line-height: 35px;">G1 GC是Jdk7的新特性之一、Jdk7+版本都可以自主配置G1作为JVM GC选项；作为JVM GC算法的一次重大升级、DK7u后G1已相对稳定、且未来计划替代CMS、所以有必要深入了解下：</span></div><div style="margin: 0px 0px 1em; padding: 0px;"><span style="line-height: 35px;">不同于其他的分代回收算法、G1将堆空间划分成了互相独立的区块。每块区域既有可能属于O区、也有可能是Y区，且每类区域空间可以是不连续的（对比CMS的O区和Y区都必须是连续的）。这种将O区划分成多块的理念源于：当并发后台线程寻找可回收的对象时、有些区块包含可回收的对象要比其他区块多很多。虽然在清理这些区块时G1仍然需要暂停应用线程、但可以用相对较少的时间优先回收包含垃圾最多区块。这也是为什么G1命名为Garbage First的原因：第一时间处理垃圾最多的区块。</span></div><div style="margin: 0px 0px 1em; padding: 0px; line-height: 35px;"></div><div style="margin: 0px 0px 1em; padding: 0px;"><span style="line-height: 35px;">平时工作中大多数系统都使用CMS、即使静默升级到JDK7默认仍然采用CMS、那么G1相对于CMS的区别在：</span></div><ol style="margin: 0px 0px 1em 19px; padding: 0px;"><li style="padding: 0px 0px 5px; margin: 0px;"><span style="line-height: 28px;">G1在压缩空间方面有优势</span></li><li style="padding: 0px 0px 5px; margin: 0px;"><span style="line-height: 28px;">G1通过将内存空间分成区域（Region）的方式避免内存碎片问题</span></li><li style="padding: 0px 0px 5px; margin: 0px;"><span style="line-height: 28px;">Eden, Survivor, Old区不再固定、在内存使用效率上来说更灵活</span></li><li style="padding: 0px 0px 5px; margin: 0px;"><span style="line-height: 28px;">G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象</span></li><li style="padding: 0px 0px 5px; margin: 0px;"><span style="line-height: 28px;">G1在回收内存后会马上同时做合并空闲内存的工作、而CMS默认是在STW（stop the world）的时候做</span></li><li style="padding: 0px 0px 5px; margin: 0px;"><span style="line-height: 28px;">G1会在Young GC中使用、而CMS只能在O区使用</span></li></ol><div style="margin: 0px 0px 1em; padding: 0px;"><span style="line-height: 35px;">就目前而言、CMS还是默认首选的GC策略、可能在以下场景下G1更适合：</span></div><ol style="margin: 0px 0px 1em 19px; padding: 0px;"><li style="padding: 0px 0px 5px; margin: 0px;"><span style="line-height: 28px;">服务端多核CPU、JVM内存占用较大的应用（至少大于4G）</span></li><li style="padding: 0px 0px 5px; margin: 0px;"><span style="line-height: 28px;">应用在运行过程中会产生大量内存碎片、需要经常压缩空间</span></li><li style="padding: 0px 0px 5px; margin: 0px;"><span style="line-height: 28px;">想要更可控、可预期的GC停顿周期；防止高并发下应用雪崩现象</span></li></ol><h3 style="margin: 0px 0px 10px;"><span style="line-height: 26.208px;">一次完整G1GC的详细过程：</span></h3><div style="margin: 0px 0px 1em; padding: 0px;"><span style="line-height: 35px;">G1在运行过程中主要包含如下4种操作方式：</span></div><ol style="margin: 0px 0px 1em 19px; padding: 0px;"><li style="padding: 0px 0px 5px; margin: 0px;"><span style="line-height: 28px;">YGC（不同于CMS）</span></li><li style="padding: 0px 0px 5px; margin: 0px;"><span style="line-height: 28px;">并发阶段</span></li><li style="padding: 0px 0px 5px; margin: 0px;"><span style="line-height: 28px;">混合模式</span></li><li style="padding: 0px 0px 5px; margin: 0px;"><span style="line-height: 28px;">full GC （一般是G1出现问题时发生）</span></li></ol><h4 style="margin: 0px 0px 10px;"><span style="line-height: 22.4px;">YGC：</span></h4><div style="margin: 0px 0px 1em; padding: 0px;"><span style="line-height: 35px;">下面是一次YGC前后内存区域是示意图：</span></div><div style="margin: 0px 0px 1em; padding: 0px;"><a href="http://ifeve.com/wp-content/uploads/2015/03/G1-1.jpg" style="line-height: 35px;"><img src="深入理解G1收集器 [2]_files/Image.jpg" type="image/jpeg" data-filename="Image.jpg" style="border: none; height: auto; max-width: 100%; width: auto;" width="300"/></a></div><div style="margin: 0px 0px 1em; padding: 0px;"><a href="http://ifeve.com/wp-content/uploads/2015/03/G1-2.jpg" style="line-height: 35px;"><img src="深入理解G1收集器 [2]_files/Image [1].jpg" type="image/jpeg" data-filename="Image.jpg" style="border: none; height: auto; max-width: 100%; width: auto;" width="300"/></a></div><div style="margin: 0px 0px 1em; padding: 0px;"><div><span style="line-height: 35px;">图中每个小区块都代表G1的一个区域（Region），区块里面的字母代表不同的分代内存空间类型（如[E]Eden,[O]Old,[S]Survivor）空白的区块不属于任何一个分区；G1可以在需要的时候任意指定这个区域属于Eden或是O区之类的。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="line-height: 35px;">G1 YoungGC在Eden充满时触发，在回收之后所有之前属于Eden的区块全变成空白。然后至少有一个区块是属于S区的（如图半满的那个区域），同时可能有一些数据移到了O区。</span></div></div><div style="margin: 0px 0px 1em; padding: 0px;"><span style="line-height: 35px;">目前淘系的应用大都使用PrintGCDetails参数打出GC日志、这个参数对G1同样有效、但日志内容颇为不同；下面是一个Young GC的例子：</span></div><div style="margin: 0px 0px 1em; padding: 0px;"><div><span style="line-height: 35px;">23.430: [GC pause (young), 0.23094400 secs]</span></div><div><span style="line-height: 35px;">...</span></div><div><span style="line-height: 35px;">[Eden: 1286M(1286M)-&gt;0B(1212M)</span></div><div><span style="line-height: 35px;">Survivors: 78M-&gt;152M Heap: 1454M(4096M)-&gt;242M(4096M)]</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="line-height: 35px;">[Times: user=0.85 sys=0.05, real=0.23 secs]</span></div></div><div style="margin: 0px 0px 1em; padding: 0px;"><div><span style="line-height: 35px;">上面日志的内容解析：Young GC实际占用230毫秒、其中GC线程占用850毫秒的CPU时间</span></div><div><span style="line-height: 35px;">E：内存占用从1286MB变成0、都被移出</span></div><div><span style="line-height: 35px;">S：从78M增长到了152M、说明从Eden移过来74M</span></div><div><span style="line-height: 35px;">Heap:占用从1454变成242M、说明这次Young GC一共释放了1212M内存空间</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="line-height: 35px;">很多情况下，S区的对象会有部分晋升到Old区，另外如果S区已满、Eden存活的对象会直接晋升到Old区，这种情况下Old的空间就会涨</span></div></div><h4 style="margin: 0px 0px 10px;"><span style="line-height: 22.4px;">并发阶段：</span></h4><div style="margin: 0px 0px 1em; padding: 0px;"><span style="line-height: 35px;">一个并发G1回收周期前后内存占用情况如下图所示：</span></div><div style="margin: 0px 0px 1em; padding: 0px;"><a href="http://ifeve.com/wp-content/uploads/2015/03/G1-3.jpg" style="line-height: 35px;"><img src="深入理解G1收集器 [2]_files/Image [2].jpg" type="image/jpeg" data-filename="Image.jpg" style="border: none; height: auto; max-width: 100%; width: auto;" width="300"/></a></div><div style="margin: 0px 0px 1em; padding: 0px;"><a href="http://ifeve.com/wp-content/uploads/2015/03/G1-4.jpg" style="line-height: 35px;"><img src="深入理解G1收集器 [2]_files/Image [3].jpg" type="image/jpeg" data-filename="Image.jpg" style="border: none; height: auto; max-width: 100%; width: auto;" width="300"/></a></div><div style="margin: 0px 0px 1em; padding: 0px;"><div><span style="line-height: 35px;">从上面的图表可以看出以下几点：</span></div><div><span style="line-height: 35px;">1、Young区发生了变化、这意味着在G1并发阶段内至少发生了一次YGC（这点和CMS就有区别），Eden在标记之前已经被完全清空，因为在并发阶段应用线程同时在工作、所以可以看到Eden又有新的占用</span></div><div><span style="line-height: 35px;">2、一些区域被X标记，这些区域属于O区，此时仍然有数据存放、不同之处在G1已标记出这些区域包含的垃圾最多、也就是回收收益最高的区域</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="line-height: 35px;">3、在并发阶段完成之后实际上O区的容量变得更大了（O+X的方块）。这时因为这个过程中发生了YGC有新的对象进入所致。此外，这个阶段在O区没有回收任何对象：它的作用主要是标记出垃圾最多的区块出来。对象实际上是在后面的阶段真正开始被回收</span></div></div><div style="margin: 0px 0px 1em; padding: 0px;"><span style="line-height: 35px;">G1并发标记周期可以分成几个阶段、其中有些需要暂停应用线程。第一个阶段是初始标记阶段。这个阶段会暂停所有应用线程-部分原因是这个过程会执行一次YGC、下面是一个日志示例：</span></div><div style="margin: 0px 0px 1em; padding: 0px;"><div><span style="line-height: 35px;">50.541: [GC pause (young) (initial-mark), 0.27767100 secs]</span></div><div><span style="line-height: 35px;">[Eden: 1220M(1220M)-&gt;0B(1220M)</span></div><div><span style="line-height: 35px;">Survivors: 144M-&gt;144M Heap: 3242M(4096M)-&gt;2093M(4096M)]</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="line-height: 35px;">[Times: user=1.02 sys=0.04, real=0.28 secs]</span></div></div><div style="margin: 0px 0px 1em; padding: 0px;"><div><span style="line-height: 35px;">上面的日志表明发生了YGC、应用线程为此暂停了280毫秒，Eden区被清空（71MB从Young区移到了O区）。</span></div><div><span style="line-height: 35px;">日志里面initial-mark的字样表明后台的并发GC阶段开始了。因为初始标记阶段本身也是要暂停应用线程的，</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="line-height: 35px;">G1正好在YGC的过程中把这个事情也一起干了。为此带来的额外开销不是很大、增加了20%的CPU，暂停时间相应的略微变长了些。</span></div></div><div style="margin: 0px 0px 1em; padding: 0px;"><span style="line-height: 35px;">接下来，G1开始扫描根区域、日志示例：</span></div><div style="margin: 0px 0px 1em; padding: 0px;"><div><span style="line-height: 35px;">50.819: [GC concurrent-root-region-scan-start]</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="line-height: 35px;">51.408: [GC concurrent-root-region-scan-end, 0.5890230]</span></div></div><div style="margin: 0px 0px 1em; padding: 0px;"><div><span style="line-height: 35px;">一共花了580毫秒，这个过程没有暂停应用线程；是后台线程并行处理的。这个阶段不能被YGC所打断、因此后台线程有足够的CPU时间很关键。如果Young区空间恰好在Root扫描的时候</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="line-height: 35px;">满了、YGC必须等待root扫描之后才能进行。带来的影响是YGC暂停时间会相应的增加。这时的GC日志是这样的：</span></div></div><div style="margin: 0px 0px 1em; padding: 0px;"><div><span style="line-height: 35px;">350.994: [GC pause (young)</span></div><div><span style="line-height: 35px;">351.093: [GC concurrent-root-region-scan-end, 0.6100090]</span></div><div><span style="line-height: 35px;">351.093: [GC concurrent-mark-start],0.37559600 secs]</span></div><div><br/></div><div><span style="line-height: 35px;">GC暂停这里可以看出在root扫描结束之前就发生了，表明YGC发生了等待，等待时间大概是100毫秒。</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="line-height: 35px;">在root扫描完成后，G1进入了一个并发标记阶段。这个阶段也是完全后台进行的；GC日志里面下面的信息代表这个阶段的开始和结束：</span></div></div><div style="margin: 0px 0px 1em; padding: 0px;"><div><span style="line-height: 35px;">111.382: [GC concurrent-mark-start]</span></div><div><span style="line-height: 35px;">....</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="line-height: 35px;">120.905: [GC concurrent-mark-end, 9.5225160 sec]</span></div></div><div style="margin: 0px 0px 1em; padding: 0px;"><span style="line-height: 35px;">并发标记阶段是可以被打断的，比如这个过程中发生了YGC就会。这个阶段之后会有一个二次标记阶段和清理阶段：</span></div><div style="margin: 0px 0px 1em; padding: 0px;"><div><span style="line-height: 35px;">120.910: [GC remark 120.959:</span></div><div><span style="line-height: 35px;">[GC ref-PRC, 0.0000890 secs], 0.0718990 secs]</span></div><div><span style="line-height: 35px;">[Times: user=0.23 sys=0.01, real=0.08 secs]</span></div><div><span style="line-height: 35px;">120.985: [GC cleanup 3510M-&gt;3434M(4096M), 0.0111040 secs]</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="line-height: 35px;">[Times: user=0.04 sys=0.00, real=0.01 secs]</span></div></div><div style="margin: 0px 0px 1em; padding: 0px;"><span style="line-height: 35px;">这两个阶段同样会暂停应用线程，但时间很短。接下来还有额外的一次并发清理阶段：</span></div><div style="margin: 0px 0px 1em; padding: 0px;"><div><span style="line-height: 35px;">120.996: [GC concurrent-cleanup-start]</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="line-height: 35px;">120.996: [GC concurrent-cleanup-end, 0.0004520]</span></div></div><div style="margin: 0px 0px 1em; padding: 0px;"><span style="line-height: 35px;">到此为止，正常的一个G1周期已完成–这个周期主要做的是发现哪些区域包含可回收的垃圾最多（标记为X），实际空间释放较少。</span></div><h4 style="margin: 0px 0px 10px;"><span style="line-height: 22.4px;">混合GC：</span></h4><div style="margin: 0px 0px 1em; padding: 0px;"><span style="line-height: 35px;">接下来G1执行一系列的混合GC。这个时期因为会同时进行YGC和清理上面已标记为X的区域，所以称之为混合阶段，下面是一个混合GC执行的前后示意图：</span></div><div style="margin: 0px 0px 1em; padding: 0px;"><a href="http://ifeve.com/wp-content/uploads/2015/03/G1-5.jpg" style="line-height: 35px;"><img src="深入理解G1收集器 [2]_files/Image [4].jpg" type="image/jpeg" data-filename="Image.jpg" style="border: none; height: auto; max-width: 100%; width: auto;" width="300"/></a></div><div style="margin: 0px 0px 1em; padding: 0px;"><a href="http://ifeve.com/wp-content/uploads/2015/03/G1-6.jpg" style="line-height: 35px;"><img src="深入理解G1收集器 [2]_files/Image [5].jpg" type="image/jpeg" data-filename="Image.jpg" style="border: none; height: auto; max-width: 100%; width: auto;" width="300"/></a></div><div style="margin: 0px 0px 1em; padding: 0px;"><span style="line-height: 35px;">像普通的YGC那样、G1完全清空掉Eden同时调整survivor区。另外，两个标记也被回收了，他们有个共同的特点是包含最多可回收的对象，因此这两个区域绝对部分空间都被释放了。这两个区域任何存活的对象都被移到了其他区域（和YGC存活对象晋升到O区类似）。这就是为什么G1的堆比CMS内存碎片要少很多的原因–移动这些对象的同时也就是在压缩对内存。下面是一个混合GC的日志：</span></div><div style="margin: 0px 0px 1em; padding: 0px;"><div><span style="line-height: 35px;">79.826: [GC pause (mixed), 0.26161600 secs]</span></div><div><span style="line-height: 35px;">....</span></div><div><span style="line-height: 35px;">[Eden: 1222M(1222M)-&gt;0B(1220M)</span></div><div><span style="line-height: 35px;">Survivors: 142M-&gt;144M Heap: 3200M(4096M)-&gt;1964M(4096M)]</span></div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="line-height: 35px;">[Times: user=1.01 sys=0.00, real=0.26 secs]</span></div></div><div style="margin: 0px 0px 1em; padding: 0px;"><span style="line-height: 35px;">上面的日志可以注意到Eden释放了1222MB、但整个堆的空间释放内存要大于这个数目。数量相差看起来比较少、只有16MB，但是要考虑同时有survivor区的对象晋升到O区；另外，每次混合GC只是清理一部分的O区内存，整个GC会一直持续到几乎所有的标记区域垃圾对象都被回收，这个阶段完了之后G1会重新回到正常的YGC阶段。周期性的，当O区内存占用达到一定数量之后G1又会开启一次新的并行GC阶段.</span></div><div style="margin-top: 15px;"><div style="margin: 0px 0px 1em; padding: 0px;"><span style="font-style: italic; line-height: 35px; font-weight: bold;">原创文章，转载请注明：</span><span style="font-style: italic; line-height: 35px;"> </span><span style="font-style: italic; line-height: 35px;">转载自</span><a href="http://ifeve.com/" style="outline: none; font-style: italic; line-height: 35px; color: rgb(0, 161, 158); text-decoration: underline;">并发编程网 – ifeve.com</a><span style="font-style: italic; line-height: 35px; font-weight: bold;">本文链接地址:</span><span style="font-style: italic; line-height: 35px;"> </span><a href="http://ifeve.com/%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3g1%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8/" style="outline: none; font-style: italic; line-height: 35px; color: rgb(0, 161, 158); text-decoration: underline;">深入理解G1垃圾收集器</a></div></div></div><div><br/></div></span>
</div></body></html> 