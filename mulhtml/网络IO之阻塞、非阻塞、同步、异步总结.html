<html>
<head>
  <title>网络IO之阻塞、非阻塞、同步、异步总结</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1387"/>
<h1>网络IO之阻塞、非阻塞、同步、异步总结</h1>

<div>
<span><div><span style="font-weight: bold; color: rgb(26, 144, 185); font-size: 18pt;">个人总结</span></div><div><span style="font-size: 12pt;">1.网络I/O模型有两个判断标准：是否阻塞，同步还是异步，这两个标准是两回事。</span></div><div><span style="font-size: 12pt;">2.以read操作为例：</span></div><div><span style="font-size: 12pt;">  read的具体操作分为以下两个部分(可以参考：</span><a href="http://www.cnblogs.com/charlesblc/p/6202402.html" style="font-size: 12pt;">http://www.cnblogs.com/charlesblc/p/6202402.html</a><span style="font-size: 12pt;">):</span></div><div><span style="font-size: 12pt;">　　（1）内核等待数据可读(实际的数据到达是由操作系统完成的)</span></div><div><span style="font-size: 12pt;">　　（2）将内核读到的数据拷贝到进程（用户态）</span></div><div><span style="font-size: 12pt;">  当用户进程阻塞在了等待数据可读的阶段，即为阻塞，不阻塞在该阶段即为非阻塞</span></div><div><span style="font-size: 12pt;">  当用户进程将内核数据拷贝到进程，即为同步，当内核主动将内核数据拷贝到进程的缓冲区即为异步。</span></div><div><span style="font-size: 12pt;">3.针对第二条不难得出结论：判断是否是block的依据是用户进程是否block在等待数据阶段，判断是同步还是异步的依据是把数据从内核态复制到用户态是内核主动还用户进程主动</span></div><div><span style="font-size: 12pt;">4.常见IO模型有如下几种：同步阻塞模型、同步非阻塞模型、IO多路复用模型、异步非阻塞模型</span></div><div><span style="font-size: 12pt;">  同步阻塞模型、同步非阻塞模型、IO多路复用模型均为同步模型，</span></div><div><span style="font-size: 12pt;">  异步虽然是在第二个步骤才区分，不过只要是异步之间区分阻塞和非阻塞已经没有意义，异步肯定是非阻塞的</span></div><div><span style="font-size: 12pt;">  IO多路复用模型有人叫它异步阻塞模型，这是错误的，它实际上是同步的（进程主动去内核取数据），在第一步是没有阻塞的，究其原理是通过select机制进行的，可以理解为一种特殊的同步非阻塞模型</span></div><div><span style="font-size: 12pt;">5.IO多路复用的核心是Reactor模式</span></div><div><span style="font-size: 12pt;">   异步非阻塞IO的核心是Proactor模式（核心是回调）</span></div><div><span style="font-size: 12pt;">6.java BIO包是同步阻塞模型，NIO包是多路复用模型，NIO2(AIO)包异步非阻塞模型</span></div><div><span style="font-size: 12pt;">7.关于非阻塞同步模型，它实际上是检测是否可读，如果不可读就会直接返回，后面的绝对不再执行，因此需要使用用户进程需要使用轮训去判断是否可读！！恼火的东西</span></div><div><span style="font-weight: bold; color: rgb(26, 144, 185); font-size: 18pt;">原文</span></div><div><span style="font-size: 12pt; font-weight: bold;">地址：</span><a href="http://www.cnblogs.com/Anker/p/3254269.html" style="font-size: 12pt; font-weight: bold;">http://www.cnblogs.com/Anker/p/3254269.html</a></div><div><h1 style="margin: 0px 0px 10px; padding: 0px 0px 0px 5px; font-size: 15.6px; border: 0px; float: left; width: 764.938px; clear: both; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><a href="http://www.cnblogs.com/Anker/p/3254269.html" style="font-size: 15.6px; border: 0px; width: 764.938px; clear: both; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; outline: none; color: rgb(33, 117, 155); font-family: &quot;Helvetica Neue&quot;, Helvetica, Verdana, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; line-height: 1.5;">网络IO之阻塞、非阻塞、同步、异步总结</a></h1></div><div style="margin: 0px; padding: 0px; clear: both; color: rgb(0, 0, 0); font-family: &quot;Helvetica Neue&quot;, Helvetica, Verdana, Arial, sans-serif; font-size: 12px; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"></div><div style="margin: 0px 0px 20px; padding: 0px; word-break: break-word;"><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="text-indent: 0px; font-weight: bold;">1、前言</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="text-indent: 0px;">　　在网络编程中，阻塞、非阻塞、同步、异步经常被提到。unix网络编程第一卷第六章专门讨论五种不同的IO模型，Stevens讲的非常详细，我记得去年看第一遍时候，似懂非懂，没有深入理解。网上有详细的分析：</span><a href="http://blog.csdn.net/historyasamirror/article/details/5778378" style="text-indent: 0px; outline: none; color: black; text-decoration: underline;">http://blog.csdn.net/historyasamirror/article/details/5778378</a><span style="text-indent: 0px;">。我结合网上博客和书总结一下，加以区别，加深理解。</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="text-indent: 0px; font-weight: bold;">2、数据流向</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="text-indent: 0px;">　　网络IO操作实际过程涉及到内核和调用这个IO操作的进程。以read为例，read的具体操作分为以下两个部分:</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="text-indent: 0px;">　　（1）内核等待数据可读</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="text-indent: 0px;">　　（2）将内核读到的数据拷贝到进程</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="text-indent: 0px;">详细过程如下图所示：</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><img src="https://images0.cnblogs.com/blog/305504/201308/12224938-4db3844232b84fb284d057a21df5f149.png" style="margin: 0px; padding: 0px; border: 0px; max-width: 700px;"></img> <img src="https://images0.cnblogs.com/blog/305504/201308/12224938-4db3844232b84fb284d057a21df5f149.png"></img><img src="网络IO之阻塞、非阻塞、同步、异步总结_files/Image.png" type="image/png" data-filename="Image.png"/></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="text-indent: 0px; font-weight: bold;">3、网络IO模型详细分析</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="text-indent: 0px;">　　常见的IO模型有阻塞、非阻塞、IO多路复用，异步。以一个生动形象的例子来说明这四个概念。周末我和女友去逛街，中午饿了，我们准备去吃饭。周末人多，吃饭需要排队，我和女友有以下几种方案：</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="text-indent: 0px;">　　（1）我和女友点完餐后，不知道什么时候能做好，只好坐在餐厅里面等，直到做好，然后吃完才离开。</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="text-indent: 0px;">女友本想还和我一起逛街的，但是不知道饭能什么时候做好，只好和我一起在餐厅等，而不能去逛街，直到吃完饭才能去逛街，中间等待做饭的时间浪费掉了。这就是典型的阻塞。网络中IO阻塞如下图所示：</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><img src="https://images0.cnblogs.com/blog/305504/201308/12230408-c8b30331f20a41dcb224d20719ffa1da.png" style="margin: 0px; padding: 0px; border: 0px; max-width: 700px;"></img><img src="网络IO之阻塞、非阻塞、同步、异步总结_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="text-indent: 0px;">　　（2）我女友不甘心白白在这等，又想去逛商场，又担心饭好了。所以我们逛一会，回来询问服务员饭好了没有，来来回回好多次，饭都还没吃都快累死了啦。这就是非阻塞。需要不断的询问，是否准备好了。网络IO非阻塞如下图所示：</span><img src="https://images0.cnblogs.com/blog/305504/201308/12231306-35dca310d92e4184bd4c0b3f42bee2c1.png" style="margin: 0px; padding: 0px; border: 0px; max-width: 700px;"></img></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><img src="网络IO之阻塞、非阻塞、同步、异步总结_files/Image [2].png" type="image/png" data-filename="Image.png"/><br/></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="text-indent: 0px;">　　（3）与第二个方案差不多，餐厅安装了电子屏幕用来显示点餐的状态，这样我和女友逛街一会，回来就不用去询问服务员了，直接看电子屏幕就可以了。这样每个人的餐是否好了，都直接看电子屏幕就可以了，这就是典型的IO多路复用，如select、poll、epoll。网络IO具体模型如下图所示：</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><img src="https://images0.cnblogs.com/blog/305504/201308/12232204-08fdf03d1d8a40a68d2286c6c43fb036.png" style="margin: 0px; padding: 0px; border: 0px; max-width: 700px;"></img><img src="网络IO之阻塞、非阻塞、同步、异步总结_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="text-indent: 0px;">　　（4）女友不想逛街，又餐厅太吵了，回家好好休息一下。于是我们叫外卖，打个电话点餐，然后我和女友可以在家好好休息一下，饭好了送货员送到家里来。这就是典型的异步，只需要打个电话说一下，然后可以做自己的事情，饭好了就送来了。linux提供了AIO库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如libevent、libev、libuv。异步过程如下图所示：</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><img src="https://images0.cnblogs.com/blog/305504/201308/12233159-16ec6876a48d424d8e6b524d1fb91689.png" style="margin: 0px; padding: 0px; border: 0px; max-width: 700px;"></img><img src="网络IO之阻塞、非阻塞、同步、异步总结_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="text-indent: 0px; font-weight: bold;">4、同步与异步</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="text-indent: 0px;">　　实际上同步与异步是针对应用程序与内核的交互而言的。同步过程中进程触发IO操作并等待或者轮询的去查看IO操作是否完成。异步过程中进程触发IO操作以后，直接返回，做自己的事情，IO交给内核来处理，完成后内核通知进程IO完成。同步与异步如下图所示：</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><img src="https://images0.cnblogs.com/blog/305504/201308/12233922-2a81723a872b4ac5a3395bcf778309b8.png" style="margin: 0px; padding: 0px; border: 0px; max-width: 700px;"></img><img src="网络IO之阻塞、非阻塞、同步、异步总结_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="text-indent: 0px; font-weight: bold;">5、阻塞与非阻塞</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="text-indent: 0px;">　　简单理解为需要做一件事能不能立即得到返回应答，如果不能立即获得返回，需要等待，那就阻塞了，否则就可以理解为非阻塞。详细区别如下图所示：</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><img src="https://images0.cnblogs.com/blog/305504/201308/12234337-ea19e65c6c72464499a307e4a950148a.png" style="margin: 0px; padding: 0px; border: 0px; max-width: 700px;"></img><img src="网络IO之阻塞、非阻塞、同步、异步总结_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="text-indent: 0px;"> </span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><span style="text-indent: 0px;">参考资料：</span></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><a href="http://www.open-open.com/doc/view/cbb2c3363c3b49ceb5812220a9c42e42" style="text-indent: 0px; outline: none; color: black; text-decoration: underline;">http://www.open-open.com/doc/view/cbb2c3363c3b49ceb5812220a9c42e42</a></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><a href="http://blog.csdn.net/historyasamirror/article/details/5778378" style="text-indent: 0px; outline: none; color: black; text-decoration: underline;">http://blog.csdn.net/historyasamirror/article/details/5778378</a></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><a href="http://www.zhihu.com/question/19732473" style="text-indent: 0px; outline: none; color: black; text-decoration: underline;">http://www.zhihu.com/question/19732473</a></div><div style="margin: 10px auto; padding: 0px; text-indent: 0px;"><a href="http://www.ibm.com/developerworks/cn/linux/l-async/" style="text-indent: 0px; outline: none; color: black; text-decoration: underline;">http://www.ibm.com/developerworks/cn/linux/l-async/</a></div></div><div style="margin: 0px; padding: 0px;">冷静思考，勇敢面对，把握未来！</div><div><br/></div></span>
</div></body></html> 