<html>
<head>
  <title>数据库事务深度总结</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1355"/>
<h1>数据库事务深度总结</h1>

<div>
<span><div><font style="font-size: 18pt;"><span style="color: rgb(26, 144, 185); font-size: 18pt; font-weight: bold;">基本概念</span></font></div><div><span style="font-size: 12pt;">(1)数据库事务是具有ACID特性的一种数据库操作逻辑，解决不同事务的并发问题的时候需要根据不同并发问题设置不同的隔离级别，而不同的隔离级别的实现就是用的不同的数据库锁策略，包括行锁，表锁，页锁等</span></div><div><span style="font-size: 12pt;">(2)数据库锁一般不需要我们显式调用，数据库事务及其隔离级别在底层已经通过锁给我们做好了解决各种并发问题的措施，几种隔离级别分别可以解决脏读、不可重复读、幻读和丢失更新的并发问题，所以一般我们不需要去使用锁(悲观锁和乐观锁相关策略除外)，只需要使用好事务及其隔离级别即可</span></div><div><span style="font-size: 12pt;">(3)丢失更新虽然可以使用串行化隔离级别的事务来解决，不过因为其效率太低，所以一般是使用乐观锁策略或者悲观锁策略来解决该问题</span></div><div><span style="font-size: 16px;">注意：不可重复读的重点在于update和delete，而幻读的重点在于insert，innodb引擎的可重复读同时解决脏读、不可重复读和幻读问题。</span></div><div><br/></div><div><font style="font-size: 18pt;"><span style="color: rgb(26, 144, 185); font-size: 18pt; font-weight: bold;">事务的四大特性</span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">(1)原子性(Atomicity)</span></font></div><div><span style="font-size: 12pt;">   原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">(2)一致性(Consistency)</span></font></div><div><span style="font-size: 12pt;">   一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是一致性。</span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">(3)隔离性(Isolation)</span></font></div><div><span style="font-size: 12pt;">   隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行，数据库提供了多种隔离级别来应对各种并发需求。</span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">(4)持久性(Durability)</span></font></div><div><span style="font-size: 12pt;">   持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</span></div><div><br/></div><div><font color="#1A90B9" style="font-size: 18pt;"><span style="color: rgb(26, 144, 185); font-size: 18pt; font-weight: bold;">数据库并发的问题</span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">(1)脏读</span></font></div><div><span style="font-size: 12pt;">   脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</span></div><div><span style="font-size: 12pt;">   当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据,就会造成两个事务得到的数据不一致。</span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">(2)不可重复读</span></font></div><div><span style="font-size: 12pt;">　不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</span></div><div><span style="font-size: 12pt;">　不可重复读和脏读的区别是:脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</span></div><div><span style="font-size: 12pt;">   在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。</span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">(3)虚读(幻读)</span></font></div><div><span style="font-size: 12pt;">　 幻读是事务非独立执行时发生的一种现象。事务A读的时候读出了15条记录，事务B在事务A执行的过程中增加了1条,事务A再读的时候就变成了 16 条，这种情况就叫做幻影读。</span></div><div><span style="font-size: 12pt;">　 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">(4)丢失更新</span></font></div><div><span style="font-size: 12pt;">   两个不同事务同时获得相同数据，然后在各自事务中同时修改了该数据</span><span style="font-size: 12pt; color: rgb(227, 0, 0);">（该修改对旧数据有依赖性）</span><span style="font-size: 12pt;">，那么先提交的事务更新会被后提交事务的更新给覆盖掉，这种情况下事务A的更新就被覆盖掉了、丢失了。比如取值-修改-写完，带判断的逻辑的修改等等。</span></div><div><br/></div><div><font style="font-size: 18pt;"><span style="color: rgb(26, 144, 185); font-size: 18pt; font-weight: bold;">数据库事务隔离级别解决的问题</span></font></div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"></col><col style="width: 130px;"></col><col style="width: 130px;"></col><col style="width: 130px;"></col><col style="width: 130px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">隔离级别</span></font></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">脏读</span></font></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">不可重复读</span></font></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">幻读 </span></font></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">丢失更新</span></font></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><span style="font-size: 12pt;">未提交读</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><span style="font-size: 12pt;">可能</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><span style="font-size: 12pt;">可能</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><span style="font-size: 12pt;">可能</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><span style="font-size: 12pt;">可能</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><span style="font-size: 12pt;">已提交读</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><span style="font-size: 12pt;">不可能</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><span style="font-size: 12pt;">可能</span></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><span style="font-size: 12pt;">可能</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><span style="font-size: 12pt;">可能</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><span style="font-size: 12pt;">可重复读</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><span style="font-size: 12pt;">不可能</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><span style="font-size: 12pt;">不可能</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><span style="font-size: 12pt;">可能</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><span style="font-size: 12pt;">可能</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><span style="font-size: 12pt;">串行化</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><span style="font-size: 12pt;">不可能</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><span style="font-size: 12pt;">不可能</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><span style="font-size: 12pt;">不可能</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><span style="font-size: 12pt;">不可能</span></div></td></tr></tbody></table><div><br/></div></div><div><span style="font-size: 12pt;">    注意：</span></div><div><span style="font-size: 12pt;">    从上到下越来越安全，但是并发性和效率越来越低，MySQL缺省隔离级别是是&quot;可重复读&quot;（REPEATABLE READ）</span></div><div><span style="font-size: 12pt;">    串行化一般是尽量避免使用，所以解决丢失更新问题尽量是使用悲观锁或者乐观锁。</span></div><div><br/></div><div><font color="#1A90B9" style="font-size: 18pt;"><span style="color: rgb(26, 144, 185); font-size: 18pt; font-weight: bold;">事务隔离级别通过锁的实现机制</span></font></div><div><span style="font-size: 12pt;">    两个锁：排他锁(与任何锁互斥)、共享锁(与共享锁不互斥，与排他锁互斥)</span></div><div><span style="font-size: 12pt;">    在运用排他锁和共享锁对数据对象加锁时，还需要约定一些规则，例如何时申请排他锁或共享锁、持锁时间、何时释放等。这些规被称为封锁协议（LockingProtocol）。对封锁方式规定不同的规则，就形成了各种不同的封锁协议。</span></div><div><br/></div><div><font style="font-size: 18pt;"><span style="color: rgb(26, 144, 185); font-size: 18pt; font-weight: bold;">参考文章</span></font></div><div><span style="font-size: 12pt;">(1)数据库事务隔离级别和锁实现机制:</span><a href="http://blog.csdn.net/flyingfalcon/article/details/53045672" style="font-size: 12pt; color: rgb(26, 144, 185);">http://blog.csdn.net/flyingfalcon/article/details/53045672</a></div><div><span style="font-size: 12pt;">(2)数据库隔离级别及其实现原理:</span><a href="http://www.cnblogs.com/wajika/p/6680200.html" style="font-size: 12pt; color: rgb(26, 144, 185);">http://www.cnblogs.com/wajika/p/6680200.html</a></div><div><span style="font-size: 12pt;">(3)数据库事务与锁的关系:</span><a href="http://m.blog.csdn.net/dreamwbt/article/details/53371687" style="font-size: 12pt; color: rgb(26, 144, 185);">http://m.blog.csdn.net/dreamwbt/article/details/53371687</a></div></span>
</div></body></html> 