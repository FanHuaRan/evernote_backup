<html>
<head>
  <title>第十一章 晚期（运行期）优化</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1037"/>
<h1>第十一章 晚期（运行期）优化</h1>

<div>
<span><div><div><span style="min-height: 15pt;"><font style="color: rgb(26, 144, 185); font-size: 18pt;"><b>一.概述</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  热点代码</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  即时编译器不是虚拟机必需的部分，java虚拟机规范并没有规定java虚拟机内必须要有即时编译器的存在，但即时编译器编译性能的好坏、代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键指标之一。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt;"><font style="font-size: 18pt; color: rgb(26, 144, 185);"><b>二.hotspot虚拟机内的即时编译</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  这儿主要回答5个问题：</font></span></div><div style="min-height: 15pt;"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"> </span> <img src="第十一章 晚期（运行期）优化_files/Image.png" type="image/png" data-filename="Image.png" width="550"/></font></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  1<b>.解释器与编译器</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  主流商用虚拟机都同时包括解释器与编译器。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  Hotspot虚拟机内置一个解释器与两级编译器（C1编译器或者说Client编译器、C2编译器或者说Server编译器）</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  解释器可以作为编译器的逃生门</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  C1编译器也可以作为C2编译器的逃生门</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  有三种模式：</font></span></div><ol style="margin-top: 0mm; margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;"><li style="margin-left: 26pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">纯解释模式 -Xint参数</span><br/></font></li><li style="margin-left: 26pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">纯编译模式 -Xcomp参数</span><br/></font></li><li style="margin-left: 26pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">缺省混合模式（mix）: Hotspot虚拟机会自动根据自身版本和宿主机器的硬件性能选择合适的运行模式，也可以使用-Client或者-Server模式。</span><br/></font></li></ol><div style="margin-left: 10mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">Java7之后的Server模式会默认开启分层编译：</font></span></div><div style="margin-left: 10mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 209pt;"><font style="font-size: 12pt;"><img src="第十一章 晚期（运行期）优化_files/Image [1].png" type="image/png" data-filename="Image.png" width="547"/></font></div><div style="margin-left: 10mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(255, 0, 0);"><font style="font-size: 12pt;">使用编译器和解释器混合模式的意义在于可以保证快速的启动速度和高速的运行性能的平衡，解释器可以作为编译器的逃生门，解释器可以为编译器收集性能信息来为编译器优化提高性能依据。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  <b>2.编译对象与编译触发条件</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">   编译对象都是都是方法！！！</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">   热点代码有两类：</font></span></div><ol style="margin-top: 0mm; margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;"><li style="margin-left: 31pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">被多次调用的方法（标准JIT编译方式）</span><br/></font></li><li style="margin-left: 31pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">被多次执行的循环体（OSR，栈上替换，方法栈还在栈上，方法就被替换了）</span><br/></font></li></ol><div style="margin-left: 6mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">热点探测的方式有三种：</font></span></div><ol style="margin-top: 0mm; margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;"><li style="margin-left: 31pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">基于采样的热点探测</span><br/></font></li><li style="margin-left: 31pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">基于计数器的热点探测（hotspot）</span><br/></font></li><li style="margin-left: 31pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">基于踪迹的热点探测（dalvik）</span><br/></font></li></ol><div style="margin-left: 6mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">方法调用计数器触发即时编译：</font></span></div><div style="margin-left: 6mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">方法调用计数器触发即时编译的阈值在client下默认是1500次、server下默认是10000次，这个阈值可以通过虚拟机参数-XX:CompileThrehold来设定，方法调用计数器有半衰期。</font></span></div><div style="margin-left: 6mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 466pt;"><font style="font-size: 12pt;"><img src="第十一章 晚期（运行期）优化_files/Image [2].png" type="image/png" data-filename="Image.png" width="549"/></font></div><div style="margin-left: 6mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"> 回边计数器触发即时编译：</font></span></div><div style="margin-left: 6mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><img src="第十一章 晚期（运行期）优化_files/Image [3].png" type="image/png" data-filename="Image.png" style="font-size: 12pt; color: rgb(1, 1, 1);"/><br/></font></span></div><div style="margin-left: 6mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><font style="font-size: 12pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"> </span> <img src="第十一章 晚期（运行期）优化_files/Image [4].png" type="image/png" data-filename="Image.png" width="552"/></font></div><div style="margin-left: 6mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"> 回边计数器无半衰期，空循环不算回边</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  3.编译过程</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">   略</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  4.查看及分析即时编译结果</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">   略</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt;"><font color="#1A90B9" style="font-size: 18pt;"><b>三.编译优化技术</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  <b>1.优化技术概览</b></font></span></div><div style="min-height: 15pt;"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"> </span> <img src="第十一章 晚期（运行期）优化_files/Image [5].png" type="image/png" data-filename="Image.png" width="552"/><img src="第十一章 晚期（运行期）优化_files/Image [6].png" type="image/png" data-filename="Image.png" width="553"/></font></div><div style="min-height: 204pt;"><font style="font-size: 12pt;"><img src="第十一章 晚期（运行期）优化_files/Image [7].png" type="image/png" data-filename="Image.png" width="552"/></font></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  <b>2.公共子表达式消除</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  略</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  <b>3.数组边界检查消除法</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  Java访问数组和访问对象都会检查边界和内存值，从而会抛出数组越界和空指针异常，从而才能保证安全性，当上下文确定不会抛出异常，可以取消这些检查</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  <b>4.方法内联</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  非虚方法可以内联，虚方法当只有一个待选版本可以激进优化，基于继承链分析</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  <b>5.逃逸分析</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  逃逸分析与继承链分析都不是优化技术，但可以为其它优化手段提供参考依据。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  逃逸分析中包括方法逃逸和线程逃逸，只要没逃逸，可能进行一些优化：</font></span></div><ol style="margin-top: 0mm; margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;"><li style="margin-left: 26pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">栈上分配</span><br/></font></li><li style="margin-left: 26pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">同步消除</span><br/></font></li><li style="margin-left: 26pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">标量替换</span><br/></font></li><li style="margin-left: 26pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">锁消除等等</span><br/></font></li></ol><div style="min-height: 15pt;"><span style="min-height: 15pt;"><font style="color: rgb(26, 144, 185); font-size: 18pt;"><b>四.java与C/C++编译器对比</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  <b>Java编译器的弱势</b></font></span></div><ol style="margin-top: 0mm; margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;"><li style="margin-left: 26pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">即时编译占用了用户程序的运行时间</span><br/></font></li><li style="margin-left: 26pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">动态的类型安全语言，有虚拟机托管，所以有很多安全检查，要消耗一点时间</span><br/></font></li><li style="margin-left: 26pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">Java的虚方法比C++多得多，内联效果没有那么理想</span><br/></font></li><li style="margin-left: 26pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">全局优化难以支持</span><br/></font></li><li style="margin-left: 26pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">垃圾回收机制与程序直接控制内存相比，速度更慢</span><br/></font></li></ol><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><b>Java编译器的优势</b></font></span></div><ol style="margin-top: 0mm; margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;"><li style="margin-left: 26pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">更容易的进行别名分析</span><br/></font></li><li style="margin-left: 26pt; margin-right: 0pt; padding-left: 0pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">运行期性能监控可以获得宝贵的运行信息，如调用频率预测，分支频率预测、裁剪未被选择的分支、从而可以进行锁优化等手段。</span></font><br/></li></ol></div></span>
</div></body></html> 