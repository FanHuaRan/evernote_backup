<html>
<head>
  <title>第八章 虚拟机字节码执行引擎</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1007"/>
<h1>第八章 虚拟机字节码执行引擎</h1>

<div>
<span><div><div><span style="min-height: 15pt;"><font style="font-size: 18pt; color: rgb(26, 144, 185);"><b>一.概述</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，而虚拟机的执行引擎是在物理机的执行引擎上自己实现的，因此可以自定义指令集与执行引擎的结构体系。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个模型成为各种虚拟机执行引擎的外观。在外观的背后，有解释执行、编译执行、也可能两者兼备或者具备几个不同级别的编译器执行引擎。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  作用都是一致的：输入的是字节码，处理过程是字节码解析的等效过程，输出的是执行结果。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt;"><font style="font-size: 18pt; color: rgb(26, 144, 185);"><b>二.运行时栈帧结构</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈中的栈元素。栈帧存储了方法的局部变量表、操作数栈和方法返回地址等信息。每一个方法从调用开始到执行完成的过程都对应着一个栈帧在虚拟机里面从入栈到出栈的过程。</font></span></div><div style="min-height: 15pt;"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">  每一个栈帧都包括了局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。</span><span style="min-height: 15pt; color: rgb(255, 0, 0);">在编译java文件的时候，栈帧需要多大的局部变量表、多深的操作数栈都已经完全确定，并且写入到方法表的Code属性当中，因此一个栈帧需要分配多少的内存不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</span></font></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  栈帧结构图：</font></span></div><div style="min-height: 15pt;"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"> </span> <img src="第八章 虚拟机字节码执行引擎_files/Image.png" type="image/png" data-filename="Image.png" width="552"/></font></div><div style="margin-left: 0mm; margin-right: 0mm; text-indent: 4mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 4mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><b>1.局部变量表</b></font></span></div><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  局部变量表是一组变量值存储空间，用于存储方法参数和方法内部定义局部变量。</font></span></div><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  使用javac编译时就已经确定了该方法需要分配的局部变量表的最大容量。</font></span></div><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  局部变量表的容量以变量槽为单位（Slot），虚拟机规范中并没有明确指明一个Slot应占用的内存空间大小，只是说明每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据，也从来未指明每个slot占用32位空间，它准许Slot的长度可以随着处理器、操作系统和虚拟机的不同而发生变化。如果使用64位长度实现slot，那虚拟机会使用对其和补白的手段保证64位开起来和32位一样。</font></span></div><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  经过实践和理论（一个slot必须能存放引用）证明：</font></span></div><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  32位和64位开启指针压缩的hotspot虚拟机，一个slot占用32位。</font></span></div><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  64位未开启指针压缩的hotspot虚拟机，一个slot占用64位。</font></span></div><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  注意：</font></span></div><ol style="margin-top: 0mm; margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;"><li style="margin-left: 36pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">在32位的虚拟机上，long和double分割成两个slot存放，取值和存值必须两个一前以后操作，虚拟机会自动校验。Long和double的这种原则可能导致在32位虚拟机上有线程问题。</span><br/></font></li><li style="margin-left: 36pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">非静态方法的Slot0是对象的引用，this指针</span><br/></font></li><li style="margin-left: 36pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">Slot是可重用的，只要一个局部变量已经超过了它的存活周期，那么局部变量所在的Slot就可以重用，这儿需要注意在某些情况会因为Slot上局部变量存储的对象引用还在，导致本该回收的对象没有被回收。因此局部变量手动赋null可以帮助垃圾回收，但对于JIT编译后的情况（会优化掉），该做法没有帮助。</span><br/></font></li></ol><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><b>2.操作数栈</b></font></span></div><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  Java虚拟机的解释执行引擎是基于栈的执行引擎，这个栈就是操作数栈，</font></span></div><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 4mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 4mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">操作数栈的每个元素存储为32位（64位未压缩指针的虚拟机应该是64位）</font></span></div><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 4mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 4mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">操作数栈只存储基本数据类型和引用等。</font></span></div><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 4mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 4mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">Hotspot虚拟机对栈帧进行了优化，上层栈的部分局部变量表与下层栈的部分操作数栈重合。</font></span></div><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><b>3.动态链接</b></font></span></div><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法的动态调用。有些符号引用会在类加载阶段或者第一次调用是就直接转换为直接引用地址，但有些符号引用会在运行时转换为直接引用，这种就是动态链接。</font></span></div><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><b>4.方法返回地址</b></font></span></div><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  方法返回地址的作用是为了让方法返回时正确返回到方法被调用的位置。</font></span></div><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 7mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 7mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">方法正常返回时，调用者的PC计数器的值可以作为返回地址。</font></span></div><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 7mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 7mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">方法异常退出时，返回地址通过异常处理表来确定</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">    方法退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者的操作数栈中，调整PC计数器到下一指令。</font></span></div><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><b>5.附加信息</b></font></span></div><div style="margin-left: 4mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 0mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  在实际开发中，一般把动态链接、方法返回地址与其它附加信息归为一类，称为栈帧信息。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt;"><font style="color: rgb(26, 144, 185); font-size: 18pt;"><b>三.方法调用</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  方法调用不等同于方法执行，方法调用的唯一目标就是被确定被调用的方法的版本和内存入口。Class文件的编译过程不包括传统编译的链接步骤，存储的都是符号引用，不是方法的内存入口地址。而是在方法运行时或者类加载时来链接。Java虚拟机提供了5条方法调用指令：</font></span></div><div style="min-height: 141pt;"><font style="font-size: 12pt;"><img src="第八章 虚拟机字节码执行引擎_files/Image [1].png" type="image/png" data-filename="Image.png" width="551"/></font></div><div style="margin-left: 0mm; margin-right: 0mm; text-indent: 4mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 4mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><b>1.解析</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">   在类加载的解析阶段会将一部分方法的符号引用转换为直接引用（方法入口地址），这些方法应该符合编译期可知，运行期不可变。这些方法包括静态方法、实例构造器方法、私有方法（本类中的私有方法）、父类方法。就是invokestatic和invokespecial指令调用的方法。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  什么是非虚方法？除开静态方法、实例构造器方法、私有方法（本类中的私有方法）、父类方法、final方法的方法都叫非虚方法。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  final方法虽然是根据其它逻辑来调用，但是final方法和上面的非虚方法一样都是在类加载的解析阶段就将符号引用替换为方法的内存入口。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  解析调用是静态的过程，在编译期间可以确定，在类加载成形。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  <b>2.分派</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  而分派调用则可能是静态的，也可能是动态的，再根据分派的宗量数可以分为单分派和多分派。两两组合就有四种情况：</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  （1）静态单分派（java不支持）</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  （2）静态多分派</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  （3）动态单分派</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  （4）动态多分派（java不支持）</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  分派调用将会解释面向对象的多态特性的实现，主要是重写和重载两种。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><b>（1）静态分派</b></font></span></div><div style="margin-left: 0mm; margin-right: 0mm; text-indent: 7mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 7mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">方法的重载属于静态分派，重载依靠的是参数的静态类型</font></span></div><div style="margin-left: 0mm; margin-right: 0mm; text-indent: 7mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 7mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">主要：静态类型是变量的声明类型，动态类型是变量的实际类型</font></span></div><div style="margin-left: 0mm; margin-right: 0mm; text-indent: 7mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 7mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">重载往往只能得出一个最合适的版本，有合适的原则。</font></span></div><div style="margin-left: 0mm; margin-right: 0mm; text-indent: 7mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 7mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">静态分派因为是依靠静态类型，而静态类型在编译器可知，因此叫做静态分派</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><b>（2）动态分派</b></font></span></div><div style="margin-left: 0mm; margin-right: 0mm; text-indent: 7mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 7mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">动态分派和重写相关。</font></span></div><div style="margin-left: 0mm; margin-right: 0mm; text-indent: 7mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 7mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">重写是在方法运行时，动态根据对象的实际类型来选择方法，因此是运行期才能确定，所以叫做动态分派。Invokevirtual就是动态分派，查找逻辑是：</font></span></div><div style="margin-left: 0mm; margin-right: 0mm; text-indent: 7mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 114pt;"><font style="font-size: 12pt;"><img src="第八章 虚拟机字节码执行引擎_files/Image [2].png" type="image/png" data-filename="Image.png" width="547"/></font></div><div style="margin-left: 0mm; margin-right: 0mm; text-indent: 4mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 4mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><b>（3）单分派和多分派</b></font></span></div><div style="margin-left: 0mm; margin-right: 0mm; text-indent: 4mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 4mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">     Java是静态多分派（方法所属对象类型+参数静态类型）</font></span></div><div style="margin-left: 0mm; margin-right: 0mm; text-indent: 4mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 4mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">           动态单分派（参数静态类型）</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><b>3.动态类型语言支持</b></font></span></div><div style="margin-left: 0mm; margin-right: 0mm; text-indent: 7mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 7mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">动态类型语言的关键特征是它的类型检查的主体过程是在运行期，而不是编译期。</font></span></div><div style="margin-left: 0mm; margin-right: 0mm; text-indent: 7mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 7mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">注意：动态类型和强弱类型不是一个概念</font></span></div><div style="margin-left: 0mm; margin-right: 0mm; text-indent: 7mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 7mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">通俗的说动态类型只有在编译期才能确定方法接受者（调用者）的实际类型。</font></span></div><div style="margin-left: 0mm; margin-right: 0mm; text-indent: 7mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 7mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">核心是invokedynamic指令和java.lang.invoke包。</font></span></div><div style="margin-left: 0mm; margin-right: 0mm; text-indent: 7mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"><span style="text-indent: 7mm; min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">知识点：</font></span></div><ol style="margin-top: 0mm; margin-bottom: 0mm; margin-left: 0mm; padding-left: 0pt;"><li style="margin-left: 47pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">java.lang.invoke包只是API层面的动态类型支持，不是字节码层面的直接支持，是不会编译出invokedynamic指令的，两者应该说没多大关系。</span><br/></font></li><li style="margin-left: 47pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">MethodHandle可以类比C语言中的函数指针和dotnet中的deletegate.</span><br/></font></li><li style="margin-left: 47pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">MethodHandle在java中的语法很像反射，但与反射有区别：反射是模拟java代码层次的方法调用，后者是模拟字节码层面的方法调用；反射是重量级的，后者是轻量级的；反射不可以做优化，后者可能会被虚拟机团队做内联优化等。</span><br/></font></li><li style="margin-left: 47pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">Invokedynamic为虚拟机之上的动态语言服务，javac编译不出该字节指令</span><br/></font></li><li style="margin-left: 47pt; margin-right: 0pt; padding-left: 18pt; text-indent: 0pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">MethodHandle的API可以完成java语言不支持的操作，比如调用祖类的方法（哪怕重写了），这个反射都是无法办到的。</span><br/></font></li></ol><div style="margin-left: 11mm; margin-right: 0mm; text-indent: 0mm; margin-top: 0.00mm; margin-bottom: 0.00mm; min-height: 15pt;"></div><div style="min-height: 15pt;"><span style="min-height: 15pt;"><font style="font-size: 18pt; color: rgb(26, 144, 185);"><b>四.基于栈的字节码解释执行引擎</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><b>1. 解释执行和编译执行</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">   语言的编译过程如下：</font></span></div><div style="min-height: 15pt;"><font style="font-size: 12pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);">  </span> <img src="第八章 虚拟机字节码执行引擎_files/Image [3].png" type="image/png" data-filename="Image.png" width="549"/></font></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"> Javac完成了程序源码到指令流的过程，然后jvm再进行解释执行，但如果含有JIT，那么也可能会反向到下面那一步。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><b>2. 基于栈的指令架构和基于寄存器的指令架构</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">   略</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;"><b>3. 基于栈的解释器执行过程</b></font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">   一般来说栈的指令架构是存在于虚拟机自定义的指令当中的，所以解释执行时基于栈的架构，但如果编译执行后，没有字节码指令了，全是本地代码，也就没有栈的指令架构一说了。</font></span></div><div style="min-height: 15pt;"><span style="min-height: 15pt; color: rgb(1, 1, 1);"><font style="font-size: 12pt;">  关于解释器执行过程，本书有经典解释。</font></span></div><div style="min-height: 15pt;"></div></div></span>
</div></body></html> 