<html>
<head>
  <title>第三章 垃圾收集器与内存分配策略</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="525"/>
<h1>第三章 垃圾收集器与内存分配策略</h1>

<div>
<span><div><font style="font-size: 18pt;"><span style="font-size: 18pt; color: rgb(20, 113, 145); font-weight: bold;">一.概述</span></font></div><div>垃圾回收需要完成的三件事情：</div><div>        1.哪些内存需要回收</div><div>        2.什么时候回收</div><div>        3.怎么回收</div><div>为什么要了解GC和内存分配？</div><div>        1.排查各种内存溢出、内存泄漏问题</div><div>        2.当垃圾收集成为系统达到更高并发量的瓶颈时</div><div>程序计数器、虚拟机栈和本地方法栈三个区域随线程而生、随线程而灭；栈中的栈帧分配多少内存基本在类结构确定下来时就是已知的（可能会被jit进行优化，大体上可认为）</div><div><br/></div><div><span style="font-size: 18pt; color: rgb(20, 113, 145); font-weight: bold;">二.对象已死吗</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">    1.引用计数法</span></div><div>       给对象添加一个引用计数器（如果让我实现，我就在对象头中拿几个字节干这事），每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减一（计数器值加一可通过重载运算符实现）</div><div>       使用语言：微软com,python等</div><div>       实现简单，但无法解决循环引用问题，主流jvm虚拟机都没有采用这种算法。</div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">    2.可达性分析算法</span></font></div><div>        通过一系列的称为“GC Roots”的对象作为起始点，从这些节点往下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（GC Root到这个对象不可达），则证明此对象是不可用的。</div><div>       使用语言：java的主流虚拟机、.net、lisp。</div><div>       可作为JVM的GC Roots的对象包括下面几种：</div><div>       （1）虚拟机栈（栈帧中的本地变量表）中引用的对象。</div><div>       （2）方法区中类静态属性引用的对象。</div><div>       （3）方法区中常量引用的对象（常量包括字面量和符号引用，这儿可能主要还是值字符串常量）</div><div>       （4）本地方法栈JNI(本地方法)引用的对象</div><div>  </div><div><span style="font-size: 12pt; font-weight: bold;">  3.再谈引用</span></div><div>       jdk1.2后，java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）,软引用（Soft Reference）,弱引用（Weak Reference）,虚引用（Phantom Reference）,这四种引用的引用强度依次减弱。</div><div>       </div><div>          <span style="font-size: 11pt; color: rgb(227, 0, 0); font-weight: bold;">补充：</span></div><div>                 1.弱引用关联的对象并不是只能生存到下一次垃圾收集发生前，而是弱引用不参与对象的引用可达性分析当中，所以应该把这话修改为只被弱引用关联的对象只能生存到下一次垃圾收集发生前。</div><div>                 2.虚引用不是拿来存放对象的，而是拿来跟踪垃圾回收的，弱引用关联的对象只能生存到下一次垃圾收集发生前，被回收时该虚引用那个对象（不是被引用那个对象）将会被拿来放在这个queue当中，从而我们可以根据这个queue在程序自运行时了解垃圾回收的部分状况</div><div>                        public PhantomReference(T referent, ReferenceQueue&lt;? super T&gt; q) {</div><div>                                  super(referent, q);</div><div>                         }</div><div>   <span style="font-size: 12pt; font-weight: bold;">3.生存还是死亡</span></div><div>       即便是在可达性分析算法中不可达的对象，也并非是“必死不可”的，要真正宣告一个对象死亡，至少要经历两次标记阶段。</div><div>      第一个标记阶段：标记出引用不可达的对象</div><div>      第二个标记 阶段：在上面不可达的对象出，标记出没有必要执行finalize方法的对象（没有重写过该方法或者该方法已经被调用过）。</div><div>      </div><div>       finalize方法并不等同于C/c++中的析构函数，它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，虽然该方法可以进行资源释放和回收工作，但是完全可以使用try-finally或者try-with-resource来做,建议忘掉finalize方法的存在</div><div>       </div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">  4.方法区的回收</span></font></div><div>     java虚拟机规范当中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集性价比一般比较低。在堆中，尤其是新生代，常规引用进行一次垃圾回收一般可以回收70~95%的空间，而永久代远远低于此。</div><div>    </div><div><br/></div><div>    <span style="color: rgb(255, 0, 0); font-weight: bold;"> 补充：</span></div><div>      tomcat卸载一个web应用就会存在对方法区的垃圾回收。</div><div><br/></div><div><span style="font-size: 18pt; color: rgb(20, 113, 145); font-weight: bold;">三.垃圾收集算法</span></div><div>      <span style="font-size: 12pt; font-weight: bold;">1.标记-清除算法</span></div><div>         标记的过程就是标记GC-Root无法到达的对象</div><div>         </div><div>         不足之处：</div><div>         1.效率问题，标记和清除的效率都不高</div><div>         2.空间问题，会产生大量不连续的内存碎片</div><div>      <span style="font-size: 12pt; font-weight: bold;">2.复制算法</span></div><div>         将可用内存按容量分为大小相等的两块（可以不只两块），每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上，然后再把已经使用过的内存空间一次清理掉。</div><div>        实现简单高效，这种算法的代价是将内存缩小为了原来的一半，浪费太大。不过可以通过分成多个区来改善。</div><div>        </div><div>        现代商用虚拟机都是采用复制算法来回收新生代，新生代中的对象98%都是朝生夕死的，所以并不需要将新生代对半分（因为经历过一次垃圾收集后回收的内存并不多），Hotspot当中，将新生代分成一块较大的Eden区和两块较小的survivor区（from、to）,每次使用Eden和其中一块survivor。当垃圾回收时，将Eden和已经使用的Survivor中还存活着的对象一次性复制到另外一块survivor当中，最后清理掉Eden和刚刚使用过的Survivor空间。</div><div>        Hotspot虚拟机默认Eden和survivor的大小比例是8:1（80+10+10），因此新生代中可用内存空间为整个新生代内存空间的90%。棒！</div><div>        当然，98%的对象回收只是一般情况，我们没有办法保证每次回收都只有不到10%的对象存活。当Survivor空间不够用时，需要依赖其它内存（老年代）进行分配担保。当Survivor空间不足以容纳新生代中存活的对象时，这些对象将通过分配担保机制进入老年代。</div><div>        </div><div>      <span style="font-size: 12pt; font-weight: bold;">3.标记-整理算法</span></div><div>        复制算法在对象存活率较高时就要进行教多的复制操作，效率将会变低。如果不想浪费50的内存，就必须有额外的空间做内存担保来应对大量对象存活的情况，所以老年代当中一般选用标记-整理算法。   </div><div>    </div><div>      <span style="font-size: 12pt; font-weight: bold;">4.分代收集算法</span></div><div>      根据新生代和老年代的策略使用不同的收集算法和收集策略（收集器）</div><div>      新生代因为很多对象朝生夕灭，所以采用复制算法</div><div>      老年代因为对象存活时间长，所以采用标记-整理算法</div><div>   </div><div><span style="font-size: 18pt; color: rgb(20, 113, 145); font-weight: bold;">四.hotspot的算法实现</span></div><div>    <span style="font-size: 12pt; font-weight: bold;">1.枚举根节点</span></div><div>      </div><div>           简单的说：</div><div>           因为GC root是全局性引用（常量和静态变量）与执行上下文（如栈帧中的局部变量表），那么意味着每次进行GC的时候，需要整个遍历方法区和栈帧，这个遍历的时间开销非常大，好在现代jvm基本都实现了准确式内存管理（jvm知道对应地址上是否是对象），因此使用空间换时间，使用一个oopmap的数据存储结构记录可以作为GC ROOT的对象的引用，每次gc进行可达性分析时，直接在oopmap中取gc root就可以了。</div><div>          除非之外：</div><div>         <span style="color: rgb(227, 0, 0);">什么是GC停顿？GC停顿就是当发生GC时（无论是young gc还是full gc）需要暂停所有运行线程（sun将其称为“stop the world”）,目的是为了防止GC时，对象引用发生变化而导致同步问题，</span></div><div><span style="color: rgb(227, 0, 0);">         号称永不停顿的CMS收集器和G1收集器也会有停顿，不过他们只在使用oopmap枚举根节点时发生停顿，当找出哪些对象可以回收后，其它线程就可以继续运行。但其它几款收集器是整个gc过程都停顿。</span></div><div><br/></div><div>       <span style="font-size: 12pt; font-weight: bold;">2.安全点</span></div><div>        在oopmap的协助下，Hotspot可以快速准确的完成GC-ROOT的枚举，但是有个问题:：可能导致引用变化的指令，或者说导致oopmap变化的指令非常多，如果为每条指令都去修改oopmap，那会需要大量额外空间和时间，那么带来的gc成本也会非常高。</div><div>       因此hotspot只在特定位置上记录oopmap的信息，这些位置称为安全点，比如方法调用、循环跳转和异常跳转。</div><div>       安全点既是记录oopmap的时间点，也是进行gc的时间点，只有当所有线程(不包括执行jni的线程)都执行到安全点并停顿时才进行gc。这儿主要包括抢先式中断和主动式中断两种方法。</div><div><br/></div><div>       <span style="font-size: 12pt; font-weight: bold;">3.安全区域</span></div><div>         安全点只是针对处于处于运行态和就绪态的线程，万一一个线程处于sleep或者blocked，那该线程就无法响应gc的中断请求，从而走到安全点去</div><div>挂起，jvm可能也无法一直等待下去，这就需要安全区。</div><div>         安全区域是指在一段代码片段之中，引用关系不会发生变化（处于sleep、blocked 、waiting等状态的线程），在这个区域内的任意地方开始GC都是安全的。</div><div>补充：线程在进入safe region时肯定要进行一次记录oopmap的操作。</div><div><br/></div><div><span style="font-size: 18pt; color: rgb(20, 113, 145); font-weight: bold;">五.垃圾收集器</span></div><div><br/></div><div>       java虚拟机规范对垃圾收集器如何实现并没有规定。这里讨论的收集器基于JDK 1.7 Update 14后的Hotspot的垃圾收集器（这个版本正式提供了商用的G1收集器，之前一直处于实验阶段）。</div><div>       <img src="第三章 垃圾收集器与内存分配策略_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>          带连线代表连线两边的收集器可以搭配使用，在哪个区域表明它是属于哪个代的收集器（只有G1可以同时拿来回收新生代和老年代）</div><div>          没有最棒的收集器，只有最合适的收集器。</div><div>      <font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1.Serial收集器</span></font></div><div>      java3之前是新生代收集器的唯一选择，依靠单个GC线程使用复制算法回收内存，回收期间暂停所有用户线程，一直是client模式下的虚拟机的默认收集器，在单核机器上运行效果最佳。</div><div>     Serial垃圾收集器和Serial old收集器运行示意图：</div><div>     <img src="第三章 垃圾收集器与内存分配策略_files/Image [1].png" type="image/png" data-filename="Image.png"/>  </div><div>    </div><div>      <span style="font-size: 12pt; font-weight: bold;">2.serial old收集器</span></div><div>          serial收集器的老年代版本，使用标记整理算法。</div><div>          <img src="第三章 垃圾收集器与内存分配策略_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div> </div><div>      <span style="font-size: 12pt; font-weight: bold;">3.parnew收集器</span></div><div>         parnew收集器是serial收集器的多线程版本，除了使用多条线程进行垃圾回收，其余行为：serial收集器的控制参数、收集算法、回收期间暂停所有用户线程（stop the world）、对象分配规则与回收策略与serial收集器一致。</div><div>         该收集器在单核机器上其性能因为在回收期间多个gc线程会有上下文切换的开销和内存同步问题，所以哪怕使用超线程技术也无法和serial收集器媲美。但多核机器上是很棒的。</div><div>         parnew收集器和serial收集器时唯一能够与CMS收集器搭配的新生代收集器。注意：parnew收集器没有老年代版本。</div><div>        </div><div>        <img src="第三章 垃圾收集器与内存分配策略_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>      <span style="font-weight: bold;">4</span><span style="font-size: 12pt; font-weight: bold;">.parallel scavenge收集器</span></div><div>         和parnew一样，也是使用复制算法和多线程回收新生代的收集器。</div><div>         不同点在于parallel scavenge收集器关注的是用户程序的吞吐量（而不是GC停顿时间）和它的自适应调节策略（自适应调节是吞吐量控制的关键）。</div><div>         parallel scavenge收集器的目的是达到一个可控制的吞吐量。（这儿说的是关于用户代码运行时间和GC时间的吞吐量，吞吐量=运行用户代码的时间/(运行用户代码的时间+垃圾收集时间)）。</div><div>         该收集器提供了两个参数用于精确控制吞吐量：</div><div>         -XX:MaxGCPauseMills：控制最大垃圾收集挺顿时间，收集器尽量保证内存回收时间在该时间之内。</div><div><span style="font-size: 10pt;">        -XX:GCTimeRatio：直接控制吞吐量大小，通过自适应调节策略。</span></div><div><span style="font-size: 10pt;">        -XX:+UseAdaptiveSizePolicy：自适应调节开关，打开以后，虚拟机会自动调节新生代的大小、Eden和Survivor的比例、晋升老年代年龄等等，虚拟机会根据目前系统的运行情况收集性能监控信息，动态调整这些参数以提供合适的GC停顿时间和最大的吞吐量。</span></div><div><span style="font-size: 10pt;">        新生代越小、GC停顿时间越短、相同时间内的回收次数越多（算上GC停顿缩短的时间，可能吞吐量更低），一个很尴尬的事实。</span></div><div><span style="font-size: 10pt;">       </span></div><div><span style="font-size: 10pt;">        关注吞吐量的收集器能够提高更好的吞吐量，可以更有效利用cpu,适合计算任务多而交互少的程序。</span></div><div><span style="font-size: 10pt;">        关注GC停顿时间能够提供更短的GC停顿时间，可以让客户端或者服务端的停顿时间更少，所以适合交互多的程序。</span></div><div><span style="font-size: 10pt;">        <img src="第三章 垃圾收集器与内存分配策略_files/Image [4].png" type="image/png" data-filename="Image.png"/></span></div><div>      <span style="font-weight: bold;">5</span><span style="font-size: 12pt; font-weight: bold;">.parallel old收集器 </span></div><div>         parallel scavenge收集器的老年代版本，使用标记-整理算法，也是以吞吐量为目标。</div><div>    <img src="第三章 垃圾收集器与内存分配策略_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>      <span style="font-size: 12pt; font-weight: bold;">6.CMS收集器</span></div><div>        CMS收集器是一种以获取最短回收停顿时间为目标、基于标记清理算法的和使用多线程回收老年代收集器。</div><div>        该收集器适合用户交互多的互联网程序，能带来更好的用户体验。</div><div>        该收集器是一款并发收集器，能够与用户线程一起工作。</div><div>        收集阶段如下：</div><div>       1.初始标记：暂停用户线程，标识GC-Roots关联的对象</div><div>       2.并发标记：与用户线程一起运行，标识GC-Roots可达的对象</div><div>       3.重新标记：暂停用户线程，标记第二步并发标记期间因为用户线程的运行而导致的变化的对象。</div><div>       4.并发清除：与用户线程一起运行，并发清除不可达的对象。</div><div><br/></div><div>       <img src="第三章 垃圾收集器与内存分配策略_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>   CMS收集器有三个缺点：</div><div>      1.CMS收集器对CPU十分敏感，虽然不会导致用户线程停顿，但是在用户线程运行期间会因为回收期间占用了一部分CPU用户资源而导致用户程序的CPU资源被剥夺，因为线程切换上下文等影响，实际上吞吐量更低。</div><div>         CMS默认使用的收集线程数量是：（CPU数量+三）/4。所以当核数大于等于4核时，只有25%的线程资源被剥夺，所以可以接受。但核数低于4时，影响极大。</div><div>      2.CMS收集器无法处理浮动垃圾。浮动垃圾是指CMS收集器在进行第4个并发清除阶段时，用户线程运行又先产生的垃圾。</div><div>         这将造成两个后果：</div><div>         1.垃圾收集结束后不得不再进行一次垃圾收集</div><div>         2.内存直接溢出，所以CMS收集器都不是在内存占用快100%时收集。</div><div>         无论如何都有风险，所以CMS收集器处理问题已经无法解决时，将直接启用serial old收集器。</div><div>      3.内存碎片 问题，所以CMS收集器在适当的回收次数时，还是会暂停用户线程来进行已使用内存的压缩整理。</div><div>      <span style="font-size: 12pt; font-weight: bold;">7.G1收集器</span>       </div><div>         该收集器是收集器研究的前沿，最早在jdk7u时才可使用，jdk9已经作为默认收集器。</div><div>         该收集器的定位是面向服务端的垃圾收集器，使命是为了替换CMS收集器。</div><div>         具有以下几个特点：</div><div>           1.使用多线程进行垃圾回收，充分利用多cpu或者多核cpu的优势。</div><div>           2.分代收集：分代收集的概念在G1收集器中也有保留，不同的策略和回收模式。（唯一一个可对新生代和老年代都进行收集的收集器）</div><div>           3.空间整合：G1收集器并不是单纯的垃圾收集算法，而是整理上看起来是标记-整理算法，但局部是复制算法，所以不会产生多少内存碎片</div><div>           4.可预测的停顿</div><div>         G1虽然还有新生代和老年代的概念，不过实际上已经将堆内存分为了多个大小相等的独立区域，内存布局和我们平时认识的大为不同。</div><div>                </div><div>    <span style="font-size: 12pt; font-weight: bold;">8.垃圾收集器自我总结</span></div><div>       垃圾收集器根据使用目的和场景可以分为以下派别：</div><div>       1.Serial收集器/Serial old收集器：单线程的收集器，回收期间，停止所有用户线程。关注停顿时间。</div><div>       2.parnew收集器：多线程的收集器，回收期间，停止所有用户线程。关注停顿时间。</div><div>       3.parallel scaverage和paranew收集器：多线程的收集器，回收期间，停止所有用户线程。自适应调节策略，关注吞吐量。</div><div>       4.CMS收集器和G1收集器：多线程的收集器，回收期间与用户线程并发运行，关注停顿时间。</div><div>     因为serial、parnew这两个新生代收集器的新生代内存不会变，所以只有它们能够和CMS收集器一起使用，G1收集器是整个堆内存。</div><div>    <font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">9.GC日志的理解</span></font></div><div>       略</div><div>    <font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">10.垃圾收集器的参数</span></font></div><div>        <img src="第三章 垃圾收集器与内存分配策略_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div><img src="第三章 垃圾收集器与内存分配策略_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 18pt; color: rgb(20, 113, 145); font-weight: bold;">六.内存分配与回收策略</span></div><div>    内存分配主要是指对象在堆内存的分配，但并非都在堆上分配（可能使用TLAB分配模式，或者以后的标量分配在栈上）</div><div>  <span style="font-size: 12pt; font-weight: bold;">1.什么是Minor GC和Full GC</span></div><div>     注意：G1收集器没有这种概念</div><div>     新生代GC(Minor GC)：指发生在新生代的垃圾收集动作，非常频繁，一般回收速度较快。</div><div>     老年代GC(Major GC/Full GC)：指发生在老年代的GC，出现了Major GC,经常会伴随着至少一次的Minor GC。Major GC的速度一般会比Minor GC慢10倍以上。</div><div><br/></div><div>  <span style="font-size: 12pt; font-weight: bold;">2.对象优先在Eden区分配</span></div><div>     大多数情况下，对象在新生代Eden中分配，当Eden区没有足够的空间时，虚拟机将发起一次Minor GC。</div><div><br/></div><div>  <span style="font-size: 12pt; font-weight: bold;">3.大对象直接进入老年代</span></div><div>     大对象就是需要占用大量连续内存空间的对象,一般是数组（一个存放含有大量字段的对象的集合不算大对象，想想为什么）。</div><div>     虚拟机有一个-XX:PretenureSizeThehold参数可以设置一个阈值，当内存大于这个阈值这个的对象就会直接在老年代中分配内存</div><div>     尽量避免短暂周期的大对象。</div><div><br/></div><div>  <span style="font-size: 12pt; font-weight: bold;">4.长期存活的对象进入老年代</span></div><div>      虚拟机给每个对象定义了一个对象年龄计数器（GC分代年龄）</div><div>      虚拟机提供-XX:MaxTenuringThrehold参数控制在新生代中存活次数的对象进入老年代。</div><div>  <span style="font-size: 12pt; font-weight: bold;">5.动态对象年龄分配</span></div><div>     <img src="第三章 垃圾收集器与内存分配策略_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>  <span style="font-size: 12pt; font-weight: bold;">6.空间分配担保</span></div><div>     在发生Minor GC前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果该条件成立，那么Minor GC是安全的，那就进行Minor GC，如果Minor GC中的survivor存不下就进入老年代。</div><div>     如果不成立，虚拟机将会首先查看HandlePromotionFailure设置值是否准许担保失败。如果准许，那么会检查老年代的最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管该次Minor GC有风险（survivor区空间不够存放存活下来的对象）。 如果小于或者不准予担保失败，那这时也要进行一次Full GC。</div><div><br/></div><div>  <span style="font-size: 12pt; font-weight: bold;">7.自我总结</span></div><div>    内存越大、回收次数越少、每次回收的停顿时间越大。</div><div>    各种情形，吞吐量优先？停顿时间优先？</div><div>    两种并发,GC线程间并发------GC线程与用户线程间并发。</div><div><div><br/></div><table style="box-sizing: border-box; border-spacing: 0px; background-color: transparent; border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 118px;"></col><col style="width: 118px;"></col><col style="width: 118px;"></col><col style="width: 118px;"></col><col style="width: 118px;"></col><col style="width: 118px;"></col></colgroup><tbody style="box-sizing: border-box;"><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; text-align: center; vertical-align: bottom; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">收集器</span></div></td><td style="box-sizing: border-box; text-align: center; vertical-align: bottom; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">串行、并行or并发</span></div></td><td style="box-sizing: border-box; text-align: center; vertical-align: bottom; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">新生代/老年代</span></div></td><td style="box-sizing: border-box; text-align: center; vertical-align: bottom; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">算法</span></div></td><td style="box-sizing: border-box; text-align: center; vertical-align: bottom; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">目标</span></div></td><td style="box-sizing: border-box; text-align: center; vertical-align: bottom; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">适用场景</span></div></td></tr><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="box-sizing: border-box; font-weight: bold; line-height: 1.42857;">Serial</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">串行</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">新生代</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">复制算法</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">响应速度优先</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">单CPU环境下的Client模式</span></div></td></tr><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="box-sizing: border-box; font-weight: bold; line-height: 1.42857;">Serial Old</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">串行</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">老年代</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">标记-整理</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">响应速度优先</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">单CPU环境下的Client模式、CMS的后备预案</span></div></td></tr><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="box-sizing: border-box; font-weight: bold; line-height: 1.42857;">ParNew</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">并行</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">新生代</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">复制算法</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">响应速度优先</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">多CPU环境时在Server模式下与CMS配合</span></div></td></tr><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="box-sizing: border-box; font-weight: bold; line-height: 1.42857;">Parallel Scavenge</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">并行</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">新生代</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">复制算法</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">吞吐量优先</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">在后台运算而不需要太多交互的任务</span></div></td></tr><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="box-sizing: border-box; font-weight: bold; line-height: 1.42857;">Parallel Old</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">并行</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">老年代</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">标记-整理</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">吞吐量优先</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">在后台运算而不需要太多交互的任务</span></div></td></tr><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="box-sizing: border-box; font-weight: bold; line-height: 1.42857;">CMS</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">并发</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">老年代</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">标记-清除</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">响应速度优先</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">集中在互联网站或B/S系统服务端上的Java应用</span></div></td></tr><tr style="box-sizing: border-box;"><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="box-sizing: border-box; font-weight: bold; line-height: 1.42857;">G1</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">并发</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">both</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">标记-整理+复制算法</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">响应速度优先</span></div></td><td style="box-sizing: border-box; vertical-align: top; text-align: center; border: 1px solid rgb(204, 204, 204); width: 118px; padding: 8px;"><div><span style="line-height: 1.42857;">面向服务端应用，将来替换CMS</span></div></td></tr></tbody></table><div><br/></div></div><div><br/></div></span>
</div></body></html> 