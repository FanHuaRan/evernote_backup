<html>
<head>
  <title>消息队列的场景、作用和缺陷分析</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/306387 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1571"/>
<h1>消息队列的场景、作用和缺陷分析</h1>

<div>
<span><div><div><b><font style="color: rgb(20, 113, 145); font-size: 18pt;">个人总结</font></b></div><div><font style="font-size: 12pt;"><b>消息队列的作用</b></font></div><ul><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;"><font style="font-size: 12pt;">多个应用之间的完全解耦，由于消息是平台无关和语言无关的，而且语义上也不再是函数调用，因此更适合作为多个应用之间的松耦合的接口（<span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">在企业应用集成（EAI）中，文件传输，共享数据库，消息队列，远程过程调用都可以作为集成的方法</span>）。<br/></font></span></li><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;"><font style="font-size: 12pt;">跨系统的异步通信，所有需要异步交互的地方都可以使用消息队列。就像我们除了打电话（同步）以外，还需要发短信，发电子邮件（异步）的通讯方式。</font></span></li><li style="list-style-type: disc; list-style-position: outside;"><font style="font-size: 12pt;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">应用内的同步变异步，比如订单处理，就可以由前端应用将订单信息放到队列，后端应用从队列里依次获得消息处理，高峰时的大量订单可以积压在队列里慢慢处理掉。由于同步通常意味着阻塞，而大量线程的阻塞会降低计算机的性能。</span><br/></font></li><li style="list-style-type: disc; list-style-position: outside;"><span style="white-space: pre-wrap;"><font style="font-size: 12pt;">解决高并发瓶颈（削峰），这个福利来自于异步。</font></span></li><li style="list-style-type: disc; list-style-position: outside;"><font style="font-size: 12pt;">广播，生产者可以将通过消息队列将任务交给多个消费者完成。</font></li><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;"><font style="font-size: 12pt;">消息驱动的架构（EDA），系统分解为消息队列，和消息制造者和消息消费者，一个处理流程可以根据需要拆成多个阶段（Stage），阶段之间用队列连接起来，前一个阶段处理的结果放入队列，后一个阶段从队列中获取消息继续处理。</font></span></li></ul><div><span style="font-size: 16px;"><b><br/></b></span></div><div><span style="font-size: 16px;"><b>消息队列的成本或者不足</b></span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67; font-size: 12pt;">1.维护消息队列，引入了一定的复杂度。</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67; font-size: 12pt;">2.暂时的不一致性，消息队列是异步的，所以会存在暂时不一致。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 16px;"><b>消息队列的使用条件</b></span></div><div><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67; font-size: 12pt;">1.生产者不需要从消费者处获得反馈</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67; font-size: 12pt;">引入消息队列之前的直接调用，其接口的返回值应该为空，这才让明明下层的动作还没做，上层却当成动作做完了继续往后走——即所谓异步——成为了可能。</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67; font-size: 12pt;">2.容许短暂的不一致性</span></div><div style="margin: 0px 0px 0.72em;"><span style="font-size: 16px; white-space: pre-wrap;">  准许短暂的不一致性，但一定要保证最终的一致性。</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67; font-size: 12pt;">3.确实是有一定效果</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67; font-size: 12pt;">即解耦、提速、广播、削峰这些方面的收益，超过维护消息队列、监控消息队列这些成本。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>知乎大牛的一个消息队列应用场景案例</b></font></div><div><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67; font-size: 12pt;">假设用户在你的软件中注册，服务端收到用户的注册请求后，它会做这些操作：</span></div><ol style="padding: 0px 0px 0px 2em; margin: 1em 0px;"><li style="list-style-type: decimal; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">校验用户名等信息，如果没问题会在数据库中添加一个用户记录</span></li><li style="list-style-type: decimal; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">如果是用邮箱注册会给你发送一封注册成功的邮件，手机注册则会发送一条短信</span></li><li style="list-style-type: decimal; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">分析用户的个人信息，以便将来向他推荐一些志同道合的人，或向那些人推荐他</span></li><li style="list-style-type: decimal; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">发送给用户一个包含操作指南的系统通知</span></li><li style="list-style-type: decimal; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">等等……</span></li></ol><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67; font-size: 12pt;">但是对于用户来说，注册功能实际只需要第一步，只要服务端将他的账户信息存到数据库中他便可以登录上去做他想做的事情了。至于其他的事情，非要在这一次请求中全部完成么？值得用户浪费时间等你处理这些对他来说无关紧要的事情么？所以实际当第一步做完后，服务端就可以把其他的操作放入对应的消息队列中然后马上返回用户结果，由消息队列异步的进行这些操作。</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67; font-size: 12pt;">或者还有一种情况，同时有大量用户注册你的软件，再高并发情况下注册请求开始出现一些问题，例如邮件接口承受不住，或是分析信息时的大量计算使cpu满载，这将会出现虽然用户数据记录很快的添加到数据库中了，但是却卡在发邮件或分析信息时的情况，导致请求的响应时间大幅增长，甚至出现超时，这就有点不划算了。面对这种情况一般也是将这些操作放入消息队列（生产者消费者模型），消息队列慢慢的进行处理，同时可以很快的完成注册请求，不会影响用户使用其他功能。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="color: rgb(20, 113, 145); font-size: 18pt;"><b>知乎采摘</b></font></div><div style="margin-bottom: 10px;"><div style="margin-bottom: 0px; background: rgb(255, 255, 255); overflow: hidden; border-radius: 2px; box-shadow: rgba(26, 26, 26, 0.1) 0px 1px 3px; box-sizing: border-box;"><div style="position: relative; padding: 16px 20px;"><div style="font-size: 15px;"><a href="https://www.zhihu.com/people/ScienJus" style="position: relative; font-size: 15px; color: rgb(68, 68, 68); font-weight: bold; line-height: 1.1;">ScienJus</a><a href="https://link.zhihu.com/?target=http%3A//www.scienjus.com" style="word-break: break-word; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; cursor: pointer; border-bottom: 1px solid rgba(68, 68, 68, 0.72); font-size: 0px; text-shadow: none; color: transparent; font-family: a; font-stretch: normal; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 0;">http://www.</a><a href="https://link.zhihu.com/?target=http%3A//www.scienjus.com" style="word-break: break-word; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; cursor: pointer; border-bottom: 1px solid rgba(68, 68, 68, 0.72); font-size: 14px; color: rgb(100, 100, 100);">scienjus.com</a><div style="margin-top: 10px; margin-bottom: -4px; font-size: 14px; color: rgb(133, 144, 166);"></div></div><div style="margin-top: 9px; margin-bottom: -4px; overflow: hidden;"><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">个人认为消息队列的主要特点是异步处理，主要目的是减少请求响应时间和解耦。所以主要的使用场景就是将比较耗时而且不需要即时（同步）返回结果的操作作为消息放入消息队列。同时由于使用了消息队列，只要保证消息格式不变，消息的发送方和接收方并不需要彼此联系，也不需要受对方的影响，即解耦和。</span></div><div><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">使用场景的话，举个例子：</span></div><div><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">假设用户在你的软件中注册，服务端收到用户的注册请求后，它会做这些操作：</span></div><ol style="padding: 0px 0px 0px 2em; margin: 1em 0px;"><li style="list-style-type: decimal; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">校验用户名等信息，如果没问题会在数据库中添加一个用户记录</span></li><li style="list-style-type: decimal; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">如果是用邮箱注册会给你发送一封注册成功的邮件，手机注册则会发送一条短信</span></li><li style="list-style-type: decimal; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">分析用户的个人信息，以便将来向他推荐一些志同道合的人，或向那些人推荐他</span></li><li style="list-style-type: decimal; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">发送给用户一个包含操作指南的系统通知</span></li><li style="list-style-type: decimal; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">等等……</span></li></ol><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">但是对于用户来说，注册功能实际只需要第一步，只要服务端将他的账户信息存到数据库中他便可以登录上去做他想做的事情了。至于其他的事情，非要在这一次请求中全部完成么？值得用户浪费时间等你处理这些对他来说无关紧要的事情么？所以实际当第一步做完后，服务端就可以把其他的操作放入对应的消息队列中然后马上返回用户结果，由消息队列异步的进行这些操作。</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">或者还有一种情况，同时有大量用户注册你的软件，再高并发情况下注册请求开始出现一些问题，例如邮件接口承受不住，或是分析信息时的大量计算使cpu满载，这将会出现虽然用户数据记录很快的添加到数据库中了，但是却卡在发邮件或分析信息时的情况，导致请求的响应时间大幅增长，甚至出现超时，这就有点不划算了。面对这种情况一般也是将这些操作放入消息队列（生产者消费者模型），消息队列慢慢的进行处理，同时可以很快的完成注册请求，不会影响用户使用其他功能。</span></div><div><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">所以在软件的正常功能开发中，并不需要去刻意的寻找消息队列的使用场景，而是当出现性能瓶颈时，去查看业务逻辑是否存在可以异步处理的耗时操作，如果存在的话便可以引入消息队列来解决。否则盲目的使用消息队列可能会增加维护和开发的成本却无法得到可观的性能提升，那就得不偿失了。</span></div></div><div style="margin-top: 10px; font-size: 14px;"><a href="https://www.zhihu.com/question/34243607/answer/58314162" style="font-size: 14px; color: rgb(133, 144, 166); line-height: 1.67;">编辑于 2015-08-12</a></div><div style="-webkit-box-align: center; align-items: center; padding: 10px 20px; margin: 0px -20px -10px; color: rgb(100, 100, 100); clear: both;"></div></div><div style="position: relative; padding: 16px 20px;"><div style="font-size: 15px;"><div style="-webkit-box-align: center; align-items: center; margin-top: 0px;"><div><a href="https://www.zhihu.com/people/qi-da-fang"><img src="https://pic4.zhimg.com/v2-f5057ec52c3b7c66c45ecc82af89ff75_xs.jpg" style="background: rgb(255, 255, 255); border-radius: 2px; vertical-align: top;" width="38"></img></a></div><div style="-webkit-box-flex: 1; flex: 1 1 0%; margin-left: 14px; overflow: hidden;"><a href="https://www.zhihu.com/people/qi-da-fang" style="position: relative; font-size: 15px; color: rgb(68, 68, 68); font-weight: bold; line-height: 1.1;">祁达方</a><span style="word-break: break-word; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 14px; color: rgb(100, 100, 100);">读书，写干货。</span></div></div><div style="margin-top: 10px; margin-bottom: -4px; font-size: 14px; color: rgb(133, 144, 166);"></div></div><div style="margin-top: 9px; margin-bottom: -4px; overflow: hidden;"><div><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">小红是小明的姐姐。</span></div><div><br/></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">小红希望小明多读书，常寻找好书给小明看，之前的方式是这样：小红问小明什么时候有空，把书给小明送去，并亲眼监督小明读完书才走。久而久之，两人都觉得麻烦。</span></div><div><br/></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">后来的方式改成了：小红对小明说「我放到书架上的书你都要看」，然后小红每次发现不错的书都放到书架上，小明则看到书架上有书就拿下来看。</span></div><div><br/></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">书架就是一个消息队列，小红是生产者，小明是消费者。</span></div><div><br/></div><div><br/></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; border-bottom: 1px solid rgba(68, 68, 68, 0.72); line-height: 1.67; text-decoration: underline;">这带来的好处有：</span></div><div><br/></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">1.小红想给小明书的时候，不必问小明什么时候有空，亲手把书交给他了，小红只把书放到书架上就行了。这样小红小明的时间都更自由。</span></div><div><br/></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">2.小红相信小明的读书自觉和读书能力，不必亲眼观察小明的读书过程，小红只要做一个放书的动作，很节省时间。</span></div><div><br/></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">3.当明天有另一个爱读书的小伙伴小强加入，小红仍旧只需要把书放到书架上，小明和小强从书架上取书即可（唔，姑且设定成多个人取一本书可以每人取走一本吧，可能是拷贝电子书或复印，暂不考虑版权问题）。</span></div><div><br/></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">4.书架上的书放在那里，小明阅读速度快就早点看完，阅读速度慢就晚点看完，没关系，比起小红把书递给小明并监督小明读完的方式，小明的压力会小一些。</span></div><div><br/></div><div><br/></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; border-bottom: 1px solid rgba(68, 68, 68, 0.72); line-height: 1.67; text-decoration: underline;">这就是消息队列的四大好处：</span></div><div><br/></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">1.解耦</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">每个成员不必受其他成员影响，可以更独立自主，只通过一个简单的容器来联系。</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">小红甚至可以不知道从书架上取书的是谁，小明也可以不知道往书架上放书的人是谁，在他们眼里，都只有书架，没有对方。</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">毫无疑问，与一个简单的容器打交道，比与复杂的人打交道容易一万倍，小红小明可以自由自在地追求各自的人生。</span></div><div><br/></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">2.提速</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">小红选择相信「把书放到书架上，别的我不问」，为自己节省了大量时间。</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">小红很忙，只能抽出五分钟时间，但这时间足够把书放到书架上了。</span></div><div><br/></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">3.广播</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">小红只需要劳动一次，就可以让多个小伙伴有书可读，这大大地节省了她的时间，也让新的小伙伴的加入成本很低。</span></div><div><br/></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">4.削峰</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">假设小明读书很慢，如果采用小红每给一本书都监督小明读完的方式，小明有压力，小红也不耐烦。</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">反正小红给书的频率也不稳定，如果今明两天连给了五本，之后隔三个月才又给一本，那小明只要在三个月内从书架上陆续取走五本书读完就行了，压力就不那么大了。</span></div><div><br/></div><div><br/></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; border-bottom: 1px solid rgba(68, 68, 68, 0.72); line-height: 1.67; text-decoration: underline;">当然，使用消息队列也有其成本：</span></div><div><br/></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">1.引入复杂度</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">毫无疑问，「书架」这东西是多出来的，需要地方放它，还需要防盗。</span></div><div><br/></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">2.暂时的不一致性</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">假如妈妈问小红「小明最近读了什么书」，在以前的方式里，小红因为亲眼监督小明读完书了，可以底气十足地告诉妈妈，但新的方式里，小红回答妈妈之后会心想「小明应该会很快看完吧……」</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">这中间存在着一段「妈妈认为小明看了某书，而小明其实还没看」的时期，当然，小明最终的阅读状态与妈妈的认知会是一致的，这就是所谓的「最终一致性」。</span></div><div><br/></div><div><br/></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; border-bottom: 1px solid rgba(68, 68, 68, 0.72); line-height: 1.67; text-decoration: underline;">那么，该使用消息队列的情况需要满足什么条件呢？</span></div><div><br/></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">1.生产者不需要从消费者处获得反馈</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">引入消息队列之前的直接调用，其接口的返回值应该为空，这才让明明下层的动作还没做，上层却当成动作做完了继续往后走——即所谓异步——成为了可能。</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">小红放完书之后小明到底看了没有，小红根本不问，她默认他是看了，否则就只能用原来的方法监督到看完了。</span></div><div><br/></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">2.容许短暂的不一致性</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">妈妈可能会发现「有时候据说小明看了某书，但事实上他还没看」，只要妈妈满意于「反正他最后看了就行」，异步处理就没问题。</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">如果妈妈对这情况不能容忍，对小红大发雷霆，小红也就不敢用书架方式了。</span></div><div><br/></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">3.确实是用了有效果</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">即解耦、提速、广播、削峰这些方面的收益，超过放置书架、监控书架这些成本。</span></div><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">否则如果是盲目照搬，「听说老赵家买了书架，咱们家也买一个」，买回来却没什么用，只是让步骤变多了，还不如直接把书递给对方呢，那就不对了。</span></div></div><div style="margin-top: 10px; font-size: 14px;"><a href="https://www.zhihu.com/question/34243607/answer/140732170" style="font-size: 14px; color: rgb(133, 144, 166); line-height: 1.67;">发布于 2017-01-13</a></div><div style="-webkit-box-align: center; align-items: center; padding: 10px 20px; margin: 0px -20px -10px; color: rgb(100, 100, 100); background: rgb(255, 255, 255); clear: both;"></div></div><div style="position: relative; padding: 16px 20px;"><div style="font-size: 15px;"><div style="-webkit-box-align: center; align-items: center; margin-top: 0px;"><div><a href="https://www.zhihu.com/people/yongxinge"><img src="https://pic2.zhimg.com/188665277_xs.jpg" style="background: rgb(255, 255, 255); border-radius: 2px; vertical-align: top;" width="38"></img></a></div><div style="-webkit-box-flex: 1; flex: 1 1 0%; margin-left: 14px; overflow: hidden;"><a href="https://www.zhihu.com/people/yongxinge" style="position: relative; font-size: 15px; color: rgb(68, 68, 68); font-weight: bold; line-height: 1.1;">用心阁</a><span style="word-break: break-word; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 14px; color: rgb(100, 100, 100);">软件工程师</span></div></div><div style="margin-top: 10px; margin-bottom: -4px; font-size: 14px; color: rgb(133, 144, 166);"></div></div><div style="margin-top: 9px; margin-bottom: -4px; overflow: hidden;"><ul style="padding: 0px 0px 0px 2em; margin: 1em 0px;"><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">跨系统的异步通信，所有需要异步交互的地方都可以使用消息队列。就像我们除了打电话（同步）以外，还需要发短信，发电子邮件（异步）的通讯方式。</span></li><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">多个应用之间的耦合，由于消息是平台无关和语言无关的，而且语义上也不再是函数调用，因此更适合作为多个应用之间的松耦合的接口。基于消息队列的耦合，不需要发送方和接收方同时在线。</span></li><ul style="padding: 0px 0px 0px 2em; margin: 0px;"><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">在企业应用集成（EAI）中，文件传输，共享数据库，消息队列，远程过程调用都可以作为集成的方法。</span></li></ul><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">应用内的同步变异步，比如订单处理，就可以由前端应用将订单信息放到队列，后端应用从队列里依次获得消息处理，高峰时的大量订单可以积压在队列里慢慢处理掉。由于同步通常意味着阻塞，而大量线程的阻塞会降低计算机的性能。</span></li><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">消息驱动的架构（EDA），系统分解为消息队列，和消息制造者和消息消费者，一个处理流程可以根据需要拆成多个阶段（Stage），阶段之间用队列连接起来，前一个阶段处理的结果放入队列，后一个阶段从队列中获取消息继续处理。</span></li><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">应用需要更灵活的耦合方式，如发布订阅，比如可以指定路由规则。</span></li><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">跨局域网，甚至跨城市的通讯，比如北京机房与广州机房的应用程序的通信。</span></li></ul></div><div style="margin-top: 10px; font-size: 14px;"><a href="https://www.zhihu.com/question/34243607/answer/58893410" style="font-size: 14px; color: rgb(133, 144, 166); line-height: 1.67;">编辑于 2015-08-12</a></div></div><div style="position: relative; padding: 16px 20px;"><div style="font-size: 15px;"><div style="-webkit-box-align: center; align-items: center; margin-top: 0px;"><div><a href="https://www.zhihu.com/people/doing_what_i_love"><img src="https://pic3.zhimg.com/v2-d708c9d16d239133fc010cb8ffad0755_xs.jpg" style="background: rgb(255, 255, 255); border-radius: 2px; vertical-align: top;" width="38"></img></a></div><div style="-webkit-box-flex: 1; flex: 1 1 0%; margin-left: 14px; overflow: hidden;"><a href="https://www.zhihu.com/people/doing_what_i_love" style="position: relative; font-size: 15px; color: rgb(68, 68, 68); font-weight: bold; line-height: 1.1;">Doing</a><span style="word-break: break-word; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 14px; color: rgb(100, 100, 100);">微信公众号：EnjoyMoving</span></div></div><div style="margin-top: 10px; margin-bottom: -4px; font-size: 14px; color: rgb(133, 144, 166);"></div></div><div style="margin-top: 9px; margin-bottom: -4px; overflow: hidden;"><div style="margin: 0px 0px 0.72em;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">消息队列的一些应用场景：</span></div><ul style="padding: 0px 0px 0px 2em; margin: 1em 0px;"><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">异步处理：</span></li><ul style="padding: 0px 0px 0px 2em; margin: 0px;"><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">非核心流程异步化，提高系统响应性能</span></li></ul><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">应用解耦：</span></li><ul style="padding: 0px 0px 0px 2em; margin: 0px;"><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">系统不是强耦合，消息接受者可以随意增加，而不需要修改消息发送者的代码。消息发送者的成功不依赖消息接受者（比如有些银行接口不稳定，但调用方并不需要依赖这些接口）</span></li><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">不强依赖于非本系统的核心流程，对于非核心流程，可以放到消息队列中让消息消费者去按需消费，而不影响核心主流程</span></li></ul><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">最终一致性：最终一致性不是消息队列的必备特性，但确实可以依靠消息队列来做最终一致性的事情。</span></li><ul style="padding: 0px 0px 0px 2em; margin: 0px;"><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">先写消息再操作，确保操作完成后再修改消息状态。定时任务补偿机制实现消息可靠发送接收、业务操作的可靠执行，要注意消息重复与幂等设计</span></li><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">所有不保证100%不丢消息的消息队列，理论上无法实现最终一致性。</span></li></ul><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">广播：</span></li><ul style="padding: 0px 0px 0px 2em; margin: 0px;"><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">只需要关心消息是否送达了队列，至于谁希望订阅，是下游的事情</span></li></ul><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">流量削峰与流控：</span></li><ul style="padding: 0px 0px 0px 2em; margin: 0px;"><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的“漏斗”。在下游有能力处理的时候，再进行分发。</span></li></ul><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">日志处理：</span></li><ul style="padding: 0px 0px 0px 2em; margin: 0px;"><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题</span></li></ul><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">消息通讯：</span></li><ul style="padding: 0px 0px 0px 2em; margin: 0px;"><li style="list-style-type: disc; list-style-position: outside;"><span style="word-break: break-word; white-space: pre-wrap; line-height: 1.67;">消息队列一般都内置了高效的通信机制，因此也可以用于单纯的消息通讯，比如实现点对点消息队列或者聊天室等。</span></li></ul></ul></div></div></div></div><div><br/></div></div></span>
</div></body></html> 